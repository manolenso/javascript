<html><head><link rel="stylesheet" type="text/css" href="css/book.css"/><link rel="stylesheet" type="text/css" href="css/highlight.css"/><link rel="stylesheet" type="text/css" href="css/console.css"/><link rel="stylesheet" type="text/css" href="css/codemirror.css"/><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Print Version -- JavaScript Éloquent</title></head><body><div class="content"><h1><span class="number">Chapitre 1: </span>Introduction</h1><div class="block"><p>Lorsque les premiers ordinateurs personnels sont apparus, la plupart d’entre
eux étaient fournis avec un langage de programmation simple, généralement une
variante de <a name="key1"></a>BASIC. Les interactions avec l’ordinateur étaient fortement liées
à ce langage, et tout utilisateur d’un ordinateur devait dès lors y goûter,
qu’il le veuille ou non. À présent que les ordinateurs sont devenus nombreux et
bon marché, les utilisateurs moyens se contentent la plupart du temps de ce
qu’ils peuvent faire en cliquant avec la souris. Pour nombre d’entre eux, cela
fonctionne très bien. Mais pour ceux d’entre nous qui ont une inclination
naturelle au bricolage technique, la disparition de la programmation dans
l’usage quotidien d’un ordinateur représente une forme de barrière.</p><p>Heureusement, avec l’évolution du World Wide Web, il se trouve que chaque
ordinateur équipé d’un navigateur web moderne a également un environnement pour
programmer en JavaScript. Il est gardé bien caché car il est dans l’air du
temps de ne pas ennuyer l’utilisateur avec des détails techniques, mais une
page web peut le rendre accessible et l’utiliser comme une plateforme pour
apprendre à programmer.</p><p>C’est ce que ce livre (ou hyper-livre) essaie de faire.</p></div><hr/><div class="block"><blockquote>Je n’ai pas pour but d’éclairer ceux qui ne sont pas désireux d’apprendre, ni
éveiller ceux qui ne sont pas soucieux de donner une explication eux-mêmes.
Si je leur ai montré un angle du carré et qu’ils ne peuvent pas revenir à moi
avec les trois autres, je ne devrais pas revenir sur le premier angle.<br/><br/>―&nbsp;Confucius</blockquote><p>Au-delà des explications qu’il donne sur le JavaScript, ce livre s’efforce
d’initier aux principes fondamentaux de la programmation. Programmer s’avère
être un exercice difficile. Les règles de base sont la plupart du temps simples
et claires. Cependant, même des programmes construits suivant ces règles de
base tendent à devenir suffisamment élaborés pour générer leurs propres règles
et leur propre complexité. Voilà pourquoi la programmation est rarement simple
et prévisible. Comme le dit Donald Knuth, que l’on peut considérer comme un des
pères fondateurs dans ce domaine, c’est un <em>art</em>.</p><p>Pour tirer quelque chose de ce livre, il est indispensable de faire plus que de
le lire passivement. Essayez de garder l’esprit affûté, efforcez-vous de
résoudre les exercices, et n’allez plus loin que lorsque vous êtes certain
d’avoir bien assimilé les étapes précédentes.</p></div><hr/><div class="block"><blockquote>Le programmeur en informatique est un créateur d’univers dont il est seul
responsable. Des univers d’une complexité potentiellement illimitée peuvent
être créés sous forme de programmes informatiques.<br/><br/>―&nbsp;Joseph Weizenbaum, <em>La puissance de l’ordinateur et la raison humaine</em></blockquote><p>Un programme, c’est beaucoup de choses. C’est un bout de texte tapé par un
programmeur, c’est la force directrice qui indique à l’ordinateur ce qu’il doit
faire, c’est un ensemble de données dans la mémoire de l’ordinateur, et
pourtant il contrôle les actions accomplies dans cette même mémoire. Les
analogies qui comparent les programmes à des objets qui nous sont familiers ont
tendance à tourner court alors que l’image d’une machine est, de manière
superficielle, mieux adaptée. Les roues et les engrenages d’une montre
mécanique sont ingénieusement agencés et coordonnés, et si l’horloger connaît
son affaire, la montre donnera l’heure pendant des années. Les parties d’un
programme sont de même étroitement solidaires et si le programmeur sait ce
qu’il fait, son programme fonctionnera sans plantage.</p><p>Un ordinateur est une machine conçue pour héberger ce genre de machines
immatérielles. Les ordinateurs eux-mêmes ne peuvent qu’exécuter stupidement des
choses simples. S’ils sont très utiles, c’est parce qu’ils peuvent faire ces
choses à une vitesse incroyable. Un programme peut, en combinant un grand
nombre de ces actions simples, accomplir des tâches très complexes.</p><p>Pour beaucoup d’entre nous, écrire des programmes informatiques est un jeu
fascinant. Un programme est une construction de l’esprit. Il ne coûte rien à
élaborer, il ne pèse rien et se développe facilement sous nos mains. Si nous
nous laissons aller, sa taille et sa complexité vont prendre des proportions
démesurées, au point d’échapper au contrôle même de celui qui l’a créé. C’est
le principal problème de la programmation. C’est la raison pour laquelle
beaucoup de logiciels aujourd’hui finissent par planter, échouer et tout
saloper.</p><p>Quand un programme fonctionne, c’est beau. L’art de la programmation est l’art
de contrôler la complexité. Un programme de grande qualité est discret et
apparaît simple malgré sa complexité.</p></div><hr/><div class="block"><p>Aujourd’hui, beaucoup de programmeurs croient que cette complexité est plus
facile à gérer en utilisant seulement un petit jeu de techniques bien comprises
dans leurs programmes. Ils ont élaboré des règles strictes concernant la forme
que devraient adopter les programmes, et les plus zélés d’entre eux dénonceront
ceux qui enfreignent ces règles comme de <em>mauvais</em> programmeurs.</p><p>Quelle hostilité envers la richesse de la programmation&nbsp;! Essayer de la réduire
à quelque chose de direct et de prévisible, jeter l’opprobre sur tous les
programmes bizarres et magnifiques… Le champ des techniques de programmation
est gigantesque, fascinant par sa diversité et encore largement inexploré. Il
est certainement bourré de chausse-trappes et de pièges à loups, menaçant de
faire commettre au programmeur inexpérimenté toutes sortes d’affreuses erreurs.
Cela signifie seulement que vous devez procéder avec prudence et garder votre
sang-froid. En apprenant, vous rencontrerez toujours de nouveaux défis, de
nouveaux territoires à explorer. Le programmeur qui refuse l’exploration va
sûrement végéter, ne plus trouver ça drôle, perdre le désir de programmer (et
devenir chef de projet).</p><p>En ce qui me concerne, le critère décisif pour évaluer un programme est :
«&nbsp;Est-il correct&nbsp;?&nbsp;». L’efficacité, la clarté et la taille sont également
importantes, mais pouvoir mesurer avec exactitude le poids de l’un et le poids
de l’autre est toujours une question d’opinion, une opinion que doit se faire
chaque programmeur. Les règles générales sont utiles, mais on ne devrait jamais
avoir peur de les transgresser.</p></div><hr/><div class="block"><p>Au début de l’informatique, lorsqu’elle venait de naître, il n’existait pas de
langage de programmation. Les programmes ressemblaient à ceci :</p><pre class="preformatted">00110001 00000000 00000000
00110001 00000001 00000001
00110011 00000001 00000010
01010001 00001011 00000010
00100010 00000010 00001000
01000011 00000001 00000000
01000001 00000001 00000001
00010000 00000010 00000000
01100010 00000000 00000000</pre><p>Il s’agit d’un programme qui fait la somme des nombres de 1 à 10 et donne le
résultat (1 + 2 + … + 10 = 55). Il pourrait tourner sur l’ordinateur le plus
simple. Pour programmer les premiers ordinateurs, il était nécessaire de
disposer de grandes séries d’interrupteurs dans la bonne position, ou de
perforer des trous dans des cartes que l’on faisait avaler à la machine. Vous
imaginez facilement à quel point la procédure était fastidieuse et sujette à
erreurs. Écrire ne serait-ce qu’un programme simple exigeait beaucoup
d’intelligence et de discipline, les programmes complexes étaient carrément
hors d’atteinte.</p><p>Bien entendu, saisir à la main des masques de bits (c’est ainsi qu’on appelle
en général les suites de 1 et de 0 ci-dessus) donnait au programmeur
l’impression d’être un puissant sorcier. Cela ne peut pas compter pour du
beurre en ce qui concerne la satisfaction professionnelle.</p><p>Chaque ligne de programme contient une instruction unique. On pourrait
l’exprimer en français sous cette forme :</p><ol><li>Stocker le nombre 0 à l’adresse mémoire 0</li><li>Stocker le nombre 1 à l’adresse mémoire 1</li><li>Stocker la valeur de l’adresse mémoire 1 dans l’adresse mémoire 2</li><li>Soustraire 11 de la valeur stockée à l’adresse mémoire 2</li><li>Si la valeur à l’adresse mémoire 2 est le nombre 0, continuer à l’instruction 9</li><li>Ajouter la valeur de l’adresse mémoire 1 à la valeur de l’adresse mémoire 0</li><li>Ajouter le nombre 1 à la valeur de l’adresse mémoire 1</li><li>Continuer avec l’instruction 3</li><li>Donner la valeur de l’adresse mémoire 0</li></ol><p>Alors que c’est déjà plus lisible que la soupe binaire, cela reste assez
désagréable. Il pourrait être utile d’utiliser des noms au lieu de nombres pour
les instructions et les adresses mémoire :</p><pre class="preformatted"> Mettre 0 à 'total'
 Mettre 1 à 'compteur'
[boucle]
 Mettre 'compteur' à 'comparaison'
 Soustraire 11 à 'comparaison'
 Si 'comparaison' est zéro, continuer à [fin]
 Ajouter 'compteur' à 'total'
 Ajouter 1 à 'compteur'
 Continuer à [boucle]
[fin]
 Afficher 'total'</pre><p>À partir de là il n’est pas trop difficile de deviner comment fonctionne le
programme. Qu’en dites-vous&nbsp;? Les deux premières lignes donnent leur valeur
initiale aux adresses mémoire : <code>total</code> sera utilisé pour calculer le résultat
du programme et <code>compteur</code> conserve le nombre courant. Les lignes qui utilisent
<code>comparaison</code> sont probablement les plus bizarres. Ce que le programme cherche
à savoir c’est si <code>compteur</code> est égal à 11, de manière à savoir s’il doit
interrompre le calcul. Comme la machine est très rudimentaire, il peut
seulement tester si un nombre est zéro, et prend une décision (sauter) basée
sur ce critère. Il utilise donc l’adresse mémoire nommée <code>comparaison</code> pour
calculer la valeur de <code>compteur - 11</code>, et décide suivant la valeur obtenue. Les
deux lignes suivantes ajoutent la valeur de <code>compteur</code> au résultat, et
l’incrémentent <code>compteur</code> d’une unité à chaque fois que le programme a décidé
qu’il n’avait pas encore atteint 11.</p><p>Voici maintenant le même programme en JavaScript :</p><pre class="code"><span class="keyword">var</span> <span class="variable">total</span> = <span class="atom">0</span>, <span class="variable">compteur</span> = <span class="atom">1</span>;
<span class="keyword">while</span> (<span class="variable">compteur</span> &lt;= <span class="atom">10</span>) {
  <span class="variable">total</span> += <span class="variable">compteur</span>;
  <span class="variable">compteur</span> += <span class="atom">1</span>;
}
<span class="variable">print</span>(<span class="variable">total</span>);</pre><p>C’est encore un peu mieux pour nous. Le plus important c’est qu’il n’est plus
nécessaire de préciser la façon dont nous voulons que le programme fasse un
bond par-ci par-là. Le mot magique <code>while</code><a class="footref" href="#footnote1">1</a> s’en occupe. Le programme continue
à exécuter les lignes ci-dessous tant que la condition qu’on lui a donnée est
satisfaite : <code>compteur &lt;= 10</code>, ce qui veut dire tant que «&nbsp;<code>compteur</code> est
inférieur ou égal à <code>10</code>&nbsp;». Apparemment, il n’y a plus besoin de créer une
valeur temporaire et de la comparer à zéro. C’était un petit détail stupide, et
le pouvoir des langages de programmation est justement qu’ils règlent pour nous
ce genre de choses accessoires.</p><p>Finalement, voici à quoi pourrait ressembler le programme si nous nous étions
arrangés pour que les opérations <code>serie</code> et <code>somme</code> soient disponibles, la
première créant une collection de nombres dans une série tandis que la seconde
calcule la somme d’une série de nombres :</p><pre class="code"><span class="variable">print</span>(<span class="variable">somme</span>(<span class="variable">serie</span>(<span class="atom">1</span>, <span class="atom">10</span>)));</pre><p>La morale de cette histoire est donc que le même programme peut être exprimé de
façon brève ou longue, lisible ou illisible. La première version du programme
était extrêmement obscure, tandis que la dernière est quasiment du français :
<code>print</code> (afficher) la <code>somme</code> de la <code>serie</code> des nombres de <code>1</code> à <code>10</code>. Nous
verrons par la suite dans d’autres chapitres comment construire des choses
telles que <code>somme</code> et <code>serie</code>.</p><p>Un bon langage de programmation aide le programmeur en lui fournissant une
manière plus abstraite de s’exprimer. Il masque les détails inintéressants,
procure des composants de base pratiques (comme la construction <code>while</code>) et, la
plupart du temps, permet au programmeur d’ajouter lui-même de telles briques
(comme les opérations <code>somme</code> et <code>serie</code>).</p></div><hr/><div class="block"><p>JavaScript est le langage qui est, actuellement, le plus utilisé pour faire
toutes sortes de choses géniales et horribles avec des pages sur le World Wide
Web. <a href="http://steve-yegge.blogspot.com/2007/02/next-big-language.html">Certains</a> prétendent que
la prochaine version de JavaScript en fera un langage de référence pour
d’autres tâches également. J’ignore si cela va se produire, mais si vous êtes
intéressé par la programmation, JavaScript est sans aucun doute un langage
utile à apprendre. Même si en fin de compte vous ne faites pas tellement de
programmation web, les programmes hallucinants que je vais vous montrer dans
cet ouvrage resteront toujours en vous, à vous hanter et à influencer les
programmes que vous écrirez dans d’autres langages.</p><p>Certains vous diront des choses <em>terribles</em> à propos de JavaScript. Beaucoup de
ces reproches sont fondés. La première fois que j’ai dû écrire quelque chose en
JavaScript, j’ai rapidement méprisé ce langage. Il acceptait à peu près tout ce
que je tapais, mais l’interprétait d’une façon complètement différente de celle
que je voulais. Cela venait surtout du fait que je n’avais aucune idée de ce
que je faisais, mais il y a aussi un véritable problème ici : JavaScript est
absurdement laxiste dans ce qu’il permet. L’idée derrière cette conception
était de rendre la programmation en JavaScript plus facile pour les débutants.
En réalité, il rend surtout plus difficile la recherche des problèmes dans vos
programmes, parce que le système ne vous les montrera pas.</p><p>Toutefois, la souplesse de ce langage est aussi un avantage. Elle laisse la
place à de nombreuses techniques que les langages de programmation plus rigides
ne permettent pas, et on peut l’utiliser pour compenser certains défauts de
JavaScript. Après l’avoir étudié correctement et avoir travaillé avec un
certain temps, j’ai vraiment appris à <em>aimer</em> ce langage.</p></div><hr/><div class="block"><p>Contrairement à ce que son nom suggère, JavaScript a très peu à voir avec le
langage de programmation nommé Java. Le nom similaire a été inspiré par des
considérations commerciales plutôt que rationnelles. En 1995, quand le
JavaScript a été lancé par Netscape, le langage Java était promu partout et
gagnait en popularité. Apparemment, quelqu’un a dû penser que c’était une bonne
idée d’essayer de surfer sur la mode du moment. Nous voilà aujourd’hui coincés
avec ce nom.</p><p>Il existe un langage associé au JavaScript et qui s’appelle ECMAScript. Quand
les navigateurs autres que Netscape ont commencé à prendre en charge le
JavaScript, ou quelque chose du même genre, on a écrit une documentation pour
décrire avec précision comment le langage en question devait fonctionner. On
l’a appelé ECMAScript, d’après le nom de l’organisation qui l’a standardisé.</p><p>ECMAScript décrit un langage de programmation à usage général, mais ne dit rien
sur l’intégration de ce langage dans un navigateur internet. Le JavaScript
c’est ECMAScript plus des outils supplémentaires pour gérer les pages web et
les fenêtres de navigation.</p><p>Quelques autres logiciels utilisent le langage décrit dans le document
ECMAScript. Plus important, le langage ActionScript utilisé par Flash est basé
sur ECMAScript (bien qu’il ne suive pas précisément le standard). Flash est un
système utilisé pour ajouter des trucs qui bougent et font du bruit sur les
pages web. Ça ne vous fera pas de mal de connaître JavaScript si vous devez un
jour apprendre à faire des animations en Flash.</p><p>JavaScript continue d’évoluer. Depuis la sortie de cet ouvrage, ECMAScript 5
est sorti, il est compatible avec la version décrite ici, mais y ajoute, en
tant que méthodes natives, quelques fonctionnalités que nous écrirons
nous-même. La dernière génération de navigateurs fournit cette version
augmentée de JavaScript. En 2011, «&nbsp;ECMAScript harmony&nbsp;», une extension plus
radicale du langage, était en cours de standardisation. Vous ne devriez pas
trop craindre que ces nouvelles versions rendent obsolètes ce que vous apprenez
dans ce livre. Il ne s’agira que d’une extension du langage dont nous disposons
actuellement, donc pratiquement tout ce qui est écrit dans ce livre restera
valide.</p></div><hr/><div class="block"><p>La plupart des chapitres de ce livre contiennent une quantité non négligeable
de code<a class="footref" href="#footnote2">2</a>. D’après mon expérience, lire et écrire du code est une part
importante de l’apprentissage de la programmation. Essayez de ne pas seulement
jeter un œil sur ces exemples mais lisez-les vraiment attentivement et
comprenez-les. Cela peut être long et déroutant au début, mais vous prendrez
rapidement le coup. Il en va de même concernant les exercices. N’estimez pas
les comprendre avant d’avoir effectivement écrit une solution qui fonctionne.</p><p>Le fonctionnement même du Web fait qu’il est toujours possible d’examiner les
programmes JavaScript que les gens utilisent dans leurs pages web. Cela peut
être un bon moyen d’apprendre comment certaines choses sont réalisées. Étant
donné que la plupart des programmeurs web ne sont pas des programmeurs «
professionnels&nbsp;», ou qu’ils ne considèrent pas la programmation JavaScript
comme suffisamment intéressante pour en faire convenablement l’apprentissage,
beaucoup du code que vous pourrez trouver ainsi sera de <em>très</em> mauvaise
qualité. Quand vous apprenez à partir de code laid et incorrect, la laideur et
la confusion se propagent dans votre propre code&nbsp;; faites donc très attention
de qui vous prenez vos leçons.</p></div><hr/><div class="block"><p>Pour vous permettre d’essayer les programmes, aussi bien les exemples que le
code que vous écrirez vous-même, ce livre utilise ce que l’on appelle une
<a name="key2"></a>console. Si vous utilisez un navigateur graphique moderne (Internet Explorer
version 6 ou supérieur, Firefox 1.5 ou supérieur, Opera 9 ou supérieur, Safari
3 ou supérieur, Chrome), les pages de ce livre vont afficher une barre bleuâtre
en bas de votre écran. Vous pouvez ouvrir la console en cliquant sur la petite
flèche à l’extrémité droite de cette barre (notez qu’il ne s’agit pas de la
console intégrée de votre navigateur).</p><p>La console contient trois éléments importants. Il y a une fenêtre de sortie,
qui est utilisée pour montrer les messages d’erreurs et les choses qu’affichent
les programmes. Sous celle-ci se trouve une ligne où vous pouvez saisir un bout
de JavaScript. Essayez de saisir un nombre et appuyez sur la touche Entrée pour
lancer ce que vous avez tapé. Si le texte que vous avez saisi a produit quelque
chose de sensé, cela sera affiché dans la fenêtre de sortie. Maintenant,
essayez de taper <code>mauvais!</code>, et appuyez à nouveau sur Entrée. La fenêtre de
sortie va afficher un message d’erreur. Vous pouvez utiliser les touches flèche
vers le haut et flèche vers le bas pour revenir aux commandes que vous avez
saisies précédemment.</p><p>Pour les bouts de code plus importants, ceux qui s’étendent sur plusieurs
lignes et que vous voulez conserver un peu, la zone de droite peut être
utilisée. Le bouton «&nbsp;Lancer&nbsp;» est utilisé pour exécuter les programmes écrits
dans cette zone. Il est possible d’avoir plusieurs programmes ouverts en même
temps. Utilisez le bouton «&nbsp;Nouveau&nbsp;» pour ouvrir un nouveau tampon vide. Quand
il y a plus d’un programme ouvert, le menu après le bouton «&nbsp;Lancer&nbsp;» peut être
utilisé pour choisir lequel est affiché. Le bouton «&nbsp;Fermer&nbsp;», comme vous
pouvez vous en douter, ferme un programme.</p><p>Il y a toujours un petit bouton avec une flèche dans le coin supérieur droit
des programmes d’exemple de ce livre, qui peut être utilisé pour les lancer.
L’exemple que nous avons vu auparavant ressemblait à ceci :</p><pre class="code"><span class="keyword">var</span> <span class="variable">total</span> = <span class="atom">0</span>, <span class="variable">compteur</span> = <span class="atom">1</span>;
<span class="keyword">while</span> (<span class="variable">compteur</span> &lt;= <span class="atom">10</span>) {
  <span class="variable">total</span> += <span class="variable">compteur</span>;
  <span class="variable">compteur</span> += <span class="atom">1</span>;
}
<span class="variable">print</span>(<span class="variable">total</span>);</pre><p>Lancez-le en cliquant sur la flèche. Il y a aussi un autre bouton qui sert à
charger le programme dans la console. N’hésitez pas à le modifier et à essayer
le résultat. Le pire qu’il puisse arriver est que vous créiez une boucle sans
fin. Une boucle infinie est ce que vous obtenez lorsque la condition d’un
<code>while</code> ne devient jamais fausse, par exemple si vous choisissez d’ajouter <code>0</code>
au lieu de <code>1</code> à la variable compteur. Alors le programme va tourner pour
toujours.</p><p>Heureusement, les navigateurs gardent un œil sur les programmes qu’ils font
tourner. Lorsque l’un d’eux prend un délai démesuré pour se terminer, ils vous
demandent si vous voulez l’interrompre.</p></div><hr/><div class="block"><p>Dans certains chapitres à venir, nous créerons des programmes d’exemple qui
seront constitués de multiples blocs de code. Souvent, vous devrez lancer
chacun d’eux pour faire fonctionner le programme. Comme vous l’avez peut-être
remarqué, la flèche d’un bloc de code devient violette lorsque le bloc a été
exécuté. Lorsque vous lisez un chapitre, essayez de lancer chaque bloc de code
que vous rencontrez, particulièrement ceux qui «&nbsp;définissent&nbsp;» quelque chose de
nouveau (vous verrez ce que cela signifie dans le prochain chapitre).</p><p>Il est évidemment possible que vous ne puissiez pas lire un chapitre d’une
seule traite. Ça veut dire que vous devrez commencer à mi-chemin quand vous
reprendrez votre lecture, mais si vous ne lancez pas tout le code en commençant
du haut du chapitre, certaines choses peuvent ne pas fonctionner. En maintenant
la touche majuscule pendant que vous appuyez sur la flèche «&nbsp;Lancer&nbsp;» d’un bloc
de code, tous les blocs précédant celui-ci seront également exécutés, ainsi
lorsque vous commencez au milieu d’un chapitre, maintenez la touche majuscule
enfoncée la première fois que vous faites tourner un morceau de code, et tout
devrait fonctionner comme prévu.</p></div><ol class="footnotes"><li><a name="footnote1"></a>NdT : <code>while</code> n’est pas traduit car c’est un mot du langage JavaScript,
<code>print</code> non plus, c’est un des différents mots que vous retrouverez souvent en
anglais dans la littérature ou dans d’autres programmes.</li><li><a name="footnote2"></a>Le «&nbsp;Code&nbsp;» est la substance dont sont composés les programmes. Chaque
morceau de programme, que ce soit une ligne unique ou tout un ensemble, peut
être appelé «&nbsp;code&nbsp;».</li></ol><h1><span class="number">Chapitre 2: </span>Les bases du JavaScript : valeurs, variables et structures de contrôle</h1><div class="block"><p>Dans le monde des ordinateurs, seules les données existent. Ce qui n’est pas
une donnée n’existe pas. Fondamentalement, toutes les données sont similaires,
car elles ne sont par essence que des séquences de bits<a class="footref" href="#footnote1">1</a>. Cependant, chaque
donnée joue un rôle qui lui est propre. Dans le système JavaScript, la plupart
de ces données sont soigneusement réparties entre des choses appelées
<a name="key1"></a>valeurs. Chaque valeur a un type qui détermine le rôle qu’elle peut jouer. Il
y a six types de valeurs de base : les nombres (<code>number</code>), les chaînes de
caractères (<code>string</code>), les booléens (<code>boolean</code>), les objets (<code>object</code>), les
fonctions (<code>function</code>) et les valeurs indéfinies (<code>undefined</code>).</p><p>Pour créer une valeur, on doit seulement invoquer son nom. C’est très pratique.
Vous n’avez pas à rassembler du matériel de construction pour vos valeurs, ou
payer pour elles, il vous suffit d’en appeler une et <em>hop</em>, vous l’avez. Elles
ne sont pas créées à partir de rien, évidemment. Chaque valeur doit être
stockée quelque part, et si vous voulez en utiliser un grand nombre en même
temps la mémoire de l’ordinateur pourrait venir à manquer. Heureusement, ce
problème ne se présente que si vous devez les utiliser simultanément. Dès que
vous n’utiliserez plus une valeur, elle se dissipera en ne laissant que
quelques bits derrière elle. Ces bits sont recyclés pour fabriquer la
génération suivante de valeurs.</p></div><hr/><div class="block"><p>Les valeurs de type <a name="key2"></a>nombre sont, comme vous l’aurez peut-être déduit, des
valeurs numériques. Elles sont écrites de la manière dont sont habituellement
écrits les nombres :</p><pre class="code expression"><span class="atom">144</span></pre><p>Saisissez cela dans la console et la même chose est affichée dans la fenêtre de
sortie. Le texte que vous avez saisi a donné naissance à une valeur numérique&nbsp;;
la console a pris ce nombre et l’a affiché de nouveau à l’écran. Dans ce cas,
c’était assez inutile, mais nous produirons bientôt des valeurs de manières
moins directes et il pourra être utile de «&nbsp;les essayer&nbsp;» dans la console pour
voir ce qu’elles produisent.</p><p>Voilà à quoi ressemble <code>144</code> écrit sous forme de bits<a class="footref" href="#footnote2">2</a>:</p><pre class="preformatted">0100000001100010000000000000000000000000000000000000000000000000</pre><p>Le nombre précédent a 64 bits. C’est le cas de tous les nombres en JavaScript.
Cela a une répercussion importante : il y a une quantité limitée de nombres
pouvant être exprimés. Avec une décimale à trois chiffres, seuls les nombres de
0 à 999 peuvent être écrits, soit 10<sup>3</sup> = 1000 nombres différents. Avec 64
chiffres binaires, on peut écrire 2<sup>64</sup> nombres différents. Cela en fait
beaucoup, plus de 10<sup>19</sup> (un 1 suivi de dix-neuf zéros).</p><p>Tous les nombres inférieurs à 10<sup>19</sup> ne tiennent cependant pas dans un nombre
JavaScript. D’une part, il y a aussi les nombres négatifs, ce qui oblige à
utiliser un des bits pour stocker le signe du nombre. Mais ensuite, la
représentation des nombres décimaux est un problème encore plus important. Pour
permettre celle-ci, 11 bits sont utilisés pour stocker la position de la
virgule au sein du nombre.</p><p>Il nous reste donc 52 bits<a class="footref" href="#footnote3">3</a>. Tout nombre entier inférieur à 2<sup>52</sup>, ce qui
correspond à plus de 10<sup>15</sup>, sera contenu sans risque dans un nombre JavaScript.
Dans la plupart des cas, les nombres que nous utilisons restent bien en-deçà,
nous n’avons donc absolument pas besoin de nous préoccuper des bits, ce qui
nous arrange. Je n’ai rien de particulier contre les bits, mais vous <em>avez</em>
besoin de beaucoup d’entre eux pour pouvoir faire quoi que ce soit. Chaque fois
que c’est possible, il est donc plus agréable de travailler avec des outils
plus abstraits.</p><p>Les nombres décimaux s’écrivent en utilisant un point.</p><pre class="code expression"><span class="atom">9.81</span></pre><p>Pour les nombres très grands ou très petits, il est possible d’utiliser la
notation «&nbsp;scientifique&nbsp;», en ajoutant un <code>e</code> suivi de l’exposant du nombre :</p><pre class="code expression"><span class="atom">2.998e8</span></pre><p>Ce qui donne 2.998 * 10<sup>8</sup> = 299800000.</p><p>Les opérations avec des nombres sans virgule (aussi appelés nombres entiers)
tenant en 52 bits ont une précision garantie. Malheureusement, les opérations
avec des nombres fractionnels ne sont pas dans le même cas. Tout comme π (pi)
qui ne peut être exprimé de manière précise par un nombre fini de chiffres à
décimales, beaucoup de nombres perdent en précision lorsqu’on ne dispose que de
64 bits pour les stocker. C’est dommage, mais cela ne crée de problèmes
pratiques que dans des situations très spécifiques. Le plus important est d’en
être conscient et de considérer les nombres fractionnels décimaux comme des
approximations et non des valeurs précises.</p></div><hr/><div class="block"><p>On utilise les nombres principalement en arithmétique. Les opérations
arithmétiques, comme l’addition ou la multiplication, prennent deux valeurs de
type nombre pour créer un nouveau nombre. Voici ce que cela donne en
JavaScript :</p><pre class="code expression"><span class="atom">100</span> + <span class="atom">4</span> * <span class="atom">11</span></pre><p>Les symboles <a name="key3"></a><code>+</code> et <a name="key4"></a><code>*</code> sont appelés des opérateurs. Le premier correspond
à l’addition et le second à la multiplication. Placer un opérateur entre deux
valeurs le fera s’appliquer <a name="key5"></a> à ces deux valeurs et produire une
nouvelle valeur.</p><p>L’exemple veut-il dire «&nbsp;ajouter 4 et 100 puis multiplier le résultat par 11&nbsp;»,
ou la multiplication est-elle effectuée avant l’addition&nbsp;? Comme vous l’avez
probablement deviné, la multiplication a lieu en premier. Mais comme en
mathématiques, cela peut être modifié en entourant l’addition de
parenthèses<a name="key6"></a> :</p><pre class="code expression">(<span class="atom">100</span> + <span class="atom">4</span>) * <span class="atom">11</span></pre><p>Pour la soustraction, il y a l’opérateur <a name="key7"></a><code>-</code>, et la division peut être
effectuée avec <a name="key8"></a><code>/</code>. Lorsque des opérateurs apparaissent ensemble sans
parenthèses, l’ordre dans lequel ils sont appliqués est déterminé par la
<a name="key9"></a>priorité des opérateurs. Le premier exemple montre que la multiplication a
une priorité plus forte que l’addition. La division et la multiplication
viennent toujours avant la soustraction et l’addition. Lorsque plusieurs
opérateurs ayant la même priorité se suivent (<code>1 - 1 + 1</code>) ils sont appliqués
de gauche à droite.</p><p>Essayez de trouver la valeur que produit cette opération, puis exécutez-la en
console pour voir si vous aviez raison…</p><pre class="code expression"><span class="atom">115</span> * <span class="atom">4</span> - <span class="atom">4</span> + <span class="atom">88</span> / <span class="atom">2</span></pre><p>Vous ne devriez pas avoir à vous inquiéter de ces règles de priorité. En cas de
doute, ajoutez simplement des parenthèses.</p><p>Il y a encore un opérateur arithmétique qui vous est sûrement moins familier.
Le symbole <a name="key10"></a><code>%</code> est utilisé pour représenter l’opération <a name="key11"></a>modulo. <code>X</code> modulo
<code>Y</code> est le reste de la division de <code>X</code> par <code>Y</code>. Par exemple <code>314 % 100</code> vaut
<code>14</code>, <code>10 % 3</code> vaut <code>1</code> et <code>144 % 12</code> vaut <code>0</code>. Modulo a le même ordre de
priorité que la multiplication et la division.</p></div><hr/><div class="block"><p>Le type de données suivant est la <a name="key12"></a>chaîne de caractères. Son utilisation n’est
pas aussi évidente à deviner d’après son nom que pour le type de données
nombre, mais elle remplit également un rôle très basique. Les chaînes de
caractères sont utilisées pour représenter du texte, le nom est censé venir du
fait qu’il enchaîne un groupe de caractères ensemble. Les chaînes de caractères
sont écrites en insérant leur contenu entre des guillemets :</p><pre class="code expression"><span class="string">&quot;Colmater mon bateau avec du chewing-gum.&quot;</span></pre><p>On peut mettre pratiquement tout ce qu’on veut entre des guillemets et le
JavaScript fera la conversion en une valeur de type <code>string</code>. Mais pour
certains caractères c’est un peu tordu. Vous pouvez imaginer à quel point il
est délicat de mettre des guillemets entre guillemets. Les <a name="key13"></a>
sauts de lignes, comme vous en faites en appuyant sur Entrée, ne peuvent pas
non plus être mis entre guillemets, la chaîne doit tenir sur une seule ligne.</p><p>Pour mettre de tels caractères dans une chaîne, on emploie l’astuce suivante :
à chaque fois qu’on trouve un antislash («&nbsp;<code>\</code>&nbsp;») dans un texte entre
guillemets, cela signifie que le caractère qui le suit a une signification
particulière. Un guillemet qui est précédé d’un antislash n’achèvera pas la
chaîne mais en fera partie. Quand le caractère «&nbsp;<code>n</code>&nbsp;» se trouve derrière
l’antislash, il est interprété comme un saut de ligne. De même, un «&nbsp;<code>t</code>&nbsp;»
derrière un antislash signifie un caractère de tabulation<a class="footref" href="#footnote4">4</a>.</p><pre class="code expression"><span class="string">&quot;Voici une première ligne\nEt maintenant la seconde&quot;</span></pre><p>Remarquez que si vous entrez cette chaîne dans la console, elle s’affiche sous
forme «&nbsp;source&nbsp;», avec des guillemets et des anti-slashes. Pour ne voir que du
texte, vous pouvez entrer <code>print(&quot;a\nb&quot;)</code>. Ce que cela fait précisément sera
bientôt expliqué.</p><p>Il existe bien entendu des cas où vous voudriez que l’antislash dans une chaîne
soit juste un antislash et pas un caractère d’échappement. Si deux anti-slashes
se succèdent, ils vont se combiner et seul l’un d’eux sera conservé dans la
chaîne résultante :</p><pre class="code expression"><span class="string">&quot;Un caractère de saut de ligne est écrit ainsi \&quot;\\n\&quot;.&quot;</span></pre></div><hr/><div class="block"><p>Les chaînes ne peuvent être divisées, multipliées ou soustraites. L’opérateur
<a name="key14"></a><code>+</code> <em>peut</em> être utilisé avec des chaînes. Il n’ajoute rien au sens
mathématique mais concatène les chaînes, il les colle ensemble.</p><pre class="code expression"><span class="string">&quot;con&quot;</span> + <span class="string">&quot;cat&quot;</span> + <span class="string">&quot;é&quot;</span> + <span class="string">&quot;ner&quot;</span></pre><p>Il existe bien d’autres outils pour manipuler des chaînes de caractères, nous
les exposerons par la suite.</p></div><hr/><div class="block"><p>Tous les opérateurs ne sont pas des symboles. Certains sont écrits sous forme
de mots. Par exemple l’opérateur <a name="key15"></a><code>typeof</code> qui renvoie une chaîne de
caractères spécifiant le type d’une valeur.</p><pre class="code expression">typeof <span class="atom">4.5</span></pre><p>Les autres opérateurs que nous avons vus opèrent toujours sur deux valeurs,
<code>typeof</code> sur une seule. Les opérateurs qui utilisent deux valeurs sont appelés
des <a name="key16"></a>opérateurs binaires alors que ceux qui n’en n’utilisent
qu’une sont des <a name="key17"></a>opérateurs unaires. Le <a name="key18"></a>signe moins
peut être utilisé aussi bien comme un opérateur binaire que comme un unaire :</p><pre class="code expression">- (<span class="atom">10</span> - <span class="atom">2</span>)</pre></div><hr/><div class="block"><p>Il existe enfin des valeurs de type <a name="key19"></a>booléen. Il n’en existe que deux :
<a name="key20"></a><code>true</code> pour vrai et <a name="key21"></a><code>false</code> pour faux. Voici un moyen de produire une
valeur <code>true</code> :</p><pre class="code expression"><span class="atom">3</span> &gt; <span class="atom">2</span></pre><p>Et on peut produire <code>false</code> comme ceci :</p><pre class="code expression"><span class="atom">3</span> &lt; <span class="atom">2</span></pre><p>J’espère que vous connaissiez déjà les signes <a name="key22"></a><code>&gt;</code> et <a name="key23"></a><code>&lt;</code>. Ils signifient,
respectivement, «&nbsp;plus grand que&nbsp;» et «&nbsp;plus petit que&nbsp;». Ce sont des
opérateurs binaires et le résultat de leur application est une valeur booléenne
qui indique dans ce cas si l’expression est vérifiée ou non.</p><p>On peut comparer des chaînes de la même façon :</p><pre class="code expression"><span class="string">&quot;Aardvark&quot;</span> &lt; <span class="string">&quot;Zoroaster&quot;</span></pre><p>Le classement des chaînes suit plus ou moins l’ordre alphabétique. Plus ou
moins parce que… les lettres majuscules sont toujours «&nbsp;plus petites que&nbsp;» les
minuscules, donc <code>&quot;Z&quot; &lt; &quot;a&quot;</code> («&nbsp;Z&nbsp;» en majuscule, «&nbsp;a&nbsp;» en minuscule) vaut
<code>true</code> et les caractères non alphabétiques («&nbsp;<code>!</code>&nbsp;», «&nbsp;<code>@</code>&nbsp;», etc.) sont
également inclus dans ce classement. Le véritable principe sur lequel repose la
comparaison est le standard <a name="key24"></a>Unicode. Ce dernier assigne un nombre à
potentiellement tout caractère dont on peut avoir besoin, y compris les
caractères de langues comme le grec, l’arabe, le japonais, le tamoul, et ainsi
de suite. Disposer de tels nombres est bien pratique pour stocker des chaînes
de caractères dans un ordinateur ― vous pouvez les représenter comme une série
de nombres. En comparant les chaînes, le JavaScript se contente de comparer les
nombres associés aux caractères dans la chaîne, de gauche à droite.</p><p>Voici d’autres opérateurs du même genre : <a name="key25"></a><code>&gt;=</code> («&nbsp;supérieur ou égal à&nbsp;»),
<a name="key26"></a><code>&lt;=</code> («&nbsp;inférieur ou égal à&nbsp;»), <a name="key27"></a><code>==</code> («&nbsp;égal à&nbsp;»), et <a name="key28"></a><code>!=</code> («&nbsp;n’est pas
égal à&nbsp;»).</p><pre class="code expression"><span class="string">&quot;Itchy&quot;</span> != <span class="string">&quot;Scratchy&quot;</span></pre><pre class="code expression"><span class="atom">5e2</span> == <span class="atom">500</span></pre></div><hr/><div class="block"><p>Il existe également des opérations très utiles qui peuvent être appliquées aux
valeurs booléennes elles-mêmes. JavaScript prend en charge trois opérateurs
logiques : <em>et</em>, <em>ou</em> et <em>non</em>, que l’on peut utiliser pour des opérations
logiques sur les booléens.</p><p>L’opérateur <a name="key29"></a><code>&amp;&amp;</code> représente le <em>et</em> logique. C’est un opérateur binaire dont
le résultat est <code>true</code> seulement si les deux valeurs qu’on lui donne sont
<code>true</code>.</p><pre class="code expression"><span class="atom">true</span> &amp;&amp; <span class="atom">false</span></pre><p><a name="key30"></a><code>||</code> est le <em>ou</em> logique, qui vaut <code>true</code> si l’une ou l’autre des valeurs
qu’on lui attribue est <code>true</code> :</p><pre class="code expression"><span class="atom">true</span> || <span class="atom">false</span></pre><p><em>Non</em> s’écrit avec un point d’exclamation : <a name="key31"></a><code>!</code>, c’est un opérateur unaire
qui inverse la valeur qu’on lui attribue, <code>!true</code> devient <code>false</code> et <code>!false</code>
signifie <code>true</code>.</p></div><hr/><div class="block"><a name="exercise1"></a><div class="exercisenum">Ex. 2.1</div><div class="exercise"><pre class="code expression">((<span class="atom">4</span> &gt;= <span class="atom">6</span>) || (<span class="string">&quot;herbe&quot;</span> != <span class="string">&quot;verte&quot;</span>)) &amp;&amp;
   !(((<span class="atom">12</span> * <span class="atom">2</span>) == <span class="atom">144</span>) &amp;&amp; <span class="atom">true</span>)</pre><p>Est-ce vrai (<code>true</code>)&nbsp;? Pour une meilleure lisibilité, on peut se séparer d’un
grand nombre de parenthèses inutiles ici. Cette version, plus simple, signifie
la même chose :</p><pre class="code expression">(<span class="atom">4</span> &gt;= <span class="atom">6</span> || <span class="string">&quot;herbe&quot;</span> != <span class="string">&quot;verte&quot;</span>) &amp;&amp;
   !(<span class="atom">12</span> * <span class="atom">2</span> == <span class="atom">144</span> &amp;&amp; <span class="atom">true</span>)</pre></div><div class="solution"><p>Oui, l’expression vaut bien <code>true</code>. Vous pouvez la décomposer étape par étape
comme ceci :</p><pre class="code expression">(<span class="atom">false</span> || <span class="atom">true</span>) &amp;&amp; !(<span class="atom">false</span> &amp;&amp; <span class="atom">true</span>)</pre><pre class="code expression"><span class="atom">true</span> &amp;&amp; !<span class="atom">false</span></pre><pre class="code expression"><span class="atom">true</span></pre><p>J’espère que vous avez remarqué que <code>&quot;herbe&quot; != &quot;verte&quot;</code> est <code>true</code>. L’herbe
est peut-être verte, mais elle n’est pas égale à &quot;verte&quot;.</p></div></div><hr/><div class="block"><p>Il n’est pas toujours évident de savoir si des parenthèses sont nécessaires. En
pratique, on peut généralement s’en sortir en sachant que parmi tous les
opérateurs rencontrés, <code>||</code> a la priorité la plus basse, viennent ensuite, dans
l’ordre, <code>&amp;&amp;</code> puis les opérateurs de comparaisons (<code>&gt;</code>, <code>==</code>, etc.) et enfin
tout le reste. Ceci a été déterminé de telle sorte que, dans les cas simples,
on ne doive utiliser les parenthèses que si elles sont strictement nécessaires.</p></div><hr/><div class="block"><p>Les exemples rencontrés jusqu’à présent utilisent le langage JavaScript de la
même façon que l’on se sert d’une calculatrice de poche : utiliser des valeurs
et leur appliquer des opérateurs pour obtenir d’autres valeurs. Créer de telles
valeurs est une partie essentielle de chaque programme JavaScript, mais ce n’en
est qu’une partie. Un bout de code qui produit une valeur s’appelle une
<a name="key32"></a>expression. Chaque valeur écrite directement (telle que <code>22</code> ou
<code>&quot;psychanalyse&quot;</code>) est une expression. Une expression entre parenthèses est
également une expression. Un opérateur binaire appliqué à deux expressions, ou
un opérateur unaire appliqué à une seule expression est également une expression.</p><p>Il existe quelques autres moyens de construire des expressions, qui seront
dévoilés lorsque le moment sera venu.</p><p>Il existe une unité plus grande que l’expression. On l’appelle <a name="key33"></a>instruction.
Un programme est une suite d’instructions. La plupart des instructions se
terminent par un <a name="key34"></a>point-virgule (<code>;</code>). La forme la plus simple d’une
instruction est une expression avec un point-virgule après. Voici un
programme :</p><pre class="code"><span class="atom">1</span>;
!<span class="atom">false</span>;</pre><p>Ce programme est inutile. Une expression peut se contenter de produire une
valeur, mais une instruction ne vaudra quelque chose que si elle change un peu
le monde. Elle peut imprimer quelque chose à l’écran ―&nbsp;ce qui compte comme un
changement du monde&nbsp;― ou elle peut modifier l’état interne du programme de
telle sorte que cela affecte les instructions qui suivent. Ces modifications
sont appelées «&nbsp;<a name="key35"></a>effets de bord&nbsp;». Les instructions de l’exemple
ci-dessus ne renvoient que les valeurs <code>1</code> et <code>true</code> puis les jettent au
récupérateur de bits<a class="footref" href="#footnote5">5</a>. Ceci ne laisse aucune trace dans ce monde et ça n’a
aucun effet de bord.</p></div><hr/><div class="block"><p>Comment un programme conserve-t-il un état interne&nbsp;? Comment se rappelle-t-il
les choses&nbsp;? Nous avons vu de quelle façon créer de nouvelles valeurs à partir
de vieilles valeurs, mais cela ne modifie pas les valeurs de celles-ci, et la
nouvelle valeur doit être utilisée immédiatement ou elle disparaîtra. Pour «
attraper&nbsp;» et conserver des valeurs, JavaScript fournit un mécanisme appelé la
<a name="key36"></a>variable.</p><pre class="code"><span class="keyword">var</span> <span class="variable">attrape</span> = <span class="atom">5</span> * <span class="atom">5</span>;</pre><p>Une variable possède toujours un nom et elle peut pointer vers une valeur et la
conserver. L’instruction ci-dessus crée une variable appelée <code>attrape</code> et
l’utilise pour conserver le nombre produit par la multiplication de <code>5</code> par
<code>5</code>.</p><p>Après avoir exécuté le programme ci-dessus, vous pouvez entrer le mot <code>attrape</code>
dans la console et cela ressortira la valeur <code>25</code> à votre place. Le nom d’une
variable est utilisé pour récupérer sa valeur. <code>attrape + 1</code> fonctionne
également. Un nom de variable peut être utilisé comme expression et ainsi faire
partie de plus grandes expressions.</p><p>Le mot-clé <a name="key37"></a><code>var</code> est utilisé pour créer des variables. Le nom de la variable
suit <code>var</code>. Les noms de variable peuvent être à peu près n’importe quel mot,
mais ils ne peuvent pas contenir d’espaces. Les chiffres peuvent faire partie
du nom de variable, <code>attrape22</code> est un nom valide, mais le nom ne doit pas
commencer par un chiffre. Les caractères «&nbsp;<code>$</code>&nbsp;» et «&nbsp;<code>_</code>&nbsp;» peuvent être
utilisés dans les noms comme s’ils étaient des lettres, ainsi <code>$_$</code> est un nom
de variable correct.</p><p>Si vous souhaitez que la nouvelle variable contienne tout de suite une valeur,
comme c’est souvent le cas, vous pouvez utiliser l’opérateur <a name="key38"></a><code>=</code> pour lui
affecter la valeur d’une expression.</p><p>Si une variable pointe vers une valeur, cela ne veut pas dire qu’elles soient
liées pour toujours. Vous pouvez utiliser l’opérateur <code>=</code> à tout moment sur une
variable existante pour lui enlever sa valeur actuelle et la faire pointer sur
une nouvelle valeur.</p><pre class="code"><span class="variable">attrape</span> = <span class="atom">4</span> * <span class="atom">4</span>;</pre></div><hr/><div class="block"><p>Il est préférable d’imaginer les variables comme des tentacules plutôt que
comme des boîtes. Elles ne <em>contiennent</em> pas de valeurs, elles s’en
<em>saisissent</em> (et deux variables peuvent se référer à la même valeur). Seules
les valeurs qui sont encore retenues par le programme lui sont accessibles.
Quand vous avez besoin de vous souvenir de quelque chose, vous dressez un
tentacule pour l’accrocher fermement ou enserrez une nouvelle valeur dans un
tentacule existant : pour vous souvenir de la somme en dollars que Luigi vous
doit encore, vous pouvez faire :</p><pre class="code"><span class="keyword">var</span> <span class="variable">detteLuigi</span> = <span class="atom">140</span>;</pre><p>Puis, à chaque fois que Luigi vous rembourse quelque chose, ce montant peut
être décrémenté en allouant un nouveau nombre à la variable :</p><pre class="code"><span class="variable">detteLuigi</span> = <span class="variable">detteLuigi</span> - <span class="atom">35</span>;</pre><p>L’ensemble des variables et de leurs valeurs à un moment donné s’appelle
l’<a name="key39"></a>environnement. Quand le programme se lance, cet environnement n’est pas
vide. Il contient toujours un certain nombre de variables standards. Quand
votre navigateur charge une nouvelle page, il crée un nouvel environnement et
lui affecte les valeurs standards. Les variables créées et modifiées par les
programmes d’une page sont conservées jusqu’à ce que le navigateur aille sur
une nouvelle page.</p></div><hr/><div class="block"><p>Beaucoup de valeurs fournies par l’environnement standard sont de type «
<code>function</code>&nbsp;» (fonction)<a name="key40"></a>. Une fonction est une partie de programme
contenue dans une valeur. Généralement, cette portion de programme fait quelque
chose d’utile qui peut être invoquée en utilisant le nom défini pour la
fonction. Dans un navigateur, la variable <a name="key41"></a><code>alert</code> contient une fonction qui
ouvre une petite fenêtre avec un message. Elle s’utilise comme ceci :</p><pre class="code"><span class="variable">alert</span>(<span class="string">&quot;Au feu&nbsp;!&quot;</span>);</pre><p><a name="key42"></a>Quand on exécute le code d’une fonction, on dit qu’on
l’<a name="key43"></a>invoque, qu’on l’<a name="key44"></a>appelle ou qu’on l’applique. La notation pour
faire ça utilise des parenthèses. Chaque expression qui produit une valeur de
type fonction peut être invoquée en plaçant des parenthèses à sa suite. Dans
cet exemple, la valeur <code>&quot;Au feu&nbsp;!&quot;</code> est donnée à la fonction <code>alert</code> qui
l’utilise comme un texte à afficher dans une fenêtre de dialogue. Les valeurs
données aux fonctions sont appelées <a name="key45"></a>paramètres ou <a name="key46"></a>arguments. <code>alert</code> n’en a
besoin que d’un seul, mais d’autres fonctions peuvent en vouloir plus.</p></div><hr/><div class="block"><p>Afficher une fenêtre de dialogue est un effet de bord. Beaucoup de fonctions
sont utiles par leurs effets de bord. Une fonction peut aussi produire une
valeur et dans ce cas elle n’a pas besoin de produire un effet de bord pour
être utile. Par exemple, il existe une fonction <a name="key47"></a><code>Math.max</code>, qui prend un
nombre quelconque d’arguments numériques et retourne le plus grand d’entre
eux :</p><pre class="code"><span class="variable">alert</span>(<span class="variable">Math</span>.<span class="property">max</span>(<span class="atom">2</span>, <span class="atom">4</span>));</pre><p><a name="key48"></a>Quand une fonction produit une valeur, on dit qu’elle la
<a name="key49"></a>retourne. En JavaScript, les choses qui produisent des valeurs sont toujours
des expressions, c’est pourquoi les appels de fonctions peuvent être utilisés
comme une partie d’une expression plus longue :</p><pre class="code"><span class="variable">alert</span>(<span class="variable">Math</span>.<span class="property">min</span>(<span class="atom">2</span>, <span class="atom">4</span>) + <span class="atom">100</span>);</pre><p>Nous examinerons dans le <a href="chapter3.html">chapitre 3</a> la façon de créer vos propres fonctions.</p></div><hr/><div class="block"><p>Comme l’a montré l’exemple précédent, <code>alert</code> peut être utile pour montrer le
résultat de certaines expressions. Mais cliquer pour fermer toutes ces petites
fenêtres peut devenir très vite énervant, donc à partir de maintenant nous
allons plutôt utiliser une fonction similaire appelée <a name="key50"></a><code>print</code> qui ne fait pas
apparaître de fenêtre, mais écrit seulement une valeur dans la zone de sortie
de la console. <code>print</code> n’est pas une fonction standard du JavaScript, les
navigateurs ne la fournissent pas, mais il est possible de l’utiliser dans ce
livre, donc vous pouvez l’utiliser sur ces pages.</p><pre class="code"><span class="variable">print</span>(<span class="string">&quot;N&quot;</span>);</pre><p>Une fonction similaire également disponible sur ces pages est <code>show</code>. Alors que
<code>print</code> affichera son argument en texte brut, <a name="key51"></a><code>show</code> essayera de l’afficher à
la manière dont un programme le ferait. Ce qui signifie qu’il donnera plus
d’informations sur le type de la valeur. Par exemple, les chaînes de caractères
garderont leurs guillemets, en utilisant <code>show</code> :</p><pre class="code"><span class="variable">show</span>(<span class="string">&quot;N&quot;</span>);</pre><p>L’environnement standard fourni par les navigateurs contient quelques fonctions
supplémentaires pour faire apparaître des fenêtres. Vous pouvez poser une
question à l’utilisateur en lui demandant de répondre par «&nbsp;Oui&nbsp;» ou «&nbsp;Non&nbsp;»,
en utilisant la fonction prédéfinie <a name="key52"></a><code>confirm</code>. Elle retourne un booléen,
<code>true</code> si l’utilisateur choisit «&nbsp;Oui&nbsp;» et <code>false</code> si l’utilisateur choisit
«&nbsp;Non&nbsp;».</p><pre class="code"><span class="variable">show</span>(<span class="variable">confirm</span>(<span class="string">&quot;Continuons-nous&nbsp;?&quot;</span>));</pre><p><a name="key53"></a><code>prompt</code> peut être utilisé pour poser une question «&nbsp;ouverte&nbsp;». Le premier
argument est la question, le deuxième est le texte par défaut, proposé comme la
réponse de l’utilisateur. Une ligne de texte peut alors être tapée dans la case
de texte de la fenêtre et la fonction la retournera comme une chaîne de
caractères.</p><pre class="code"><span class="variable">show</span>(<span class="variable">prompt</span>(<span class="string">&quot;Dites-nous tout ce que vous savez.&quot;</span>, <span class="string">&quot;…&quot;</span>));</pre></div><hr/><div class="block"><p>Dans l’environnement, il est possible de donner une nouvelle valeur à presque
toutes les variables. Ça peut être utile mais aussi dangereux. Si vous donnez
la valeur <code>8</code> à <code>print</code>, vous ne pourrez plus jamais rien afficher.
Heureusement, il y a un bouton «&nbsp;Réinitialiser&nbsp;» sur la console, qui rétablit
totalement l’environnement d’origine.</p></div><hr/><div class="block"><p>Des programmes d’une ligne ne sont pas très intéressant. Quand vous mettez plus
d’une instruction dans un programme ces dernières sont, comme on peut s’en
douter, exécutées une à la fois de haut en bas.</p><pre class="code"><span class="keyword">var</span> <span class="variable">leNombre</span> = <span class="variable">Number</span>(<span class="variable">prompt</span>(<span class="string">&quot;Choisissez un nombre&quot;</span>, <span class="string">&quot;&quot;</span>));
<span class="variable">print</span>(<span class="string">&quot;Votre nombre est la racine carrée de &quot;</span> +
      (<span class="variable">leNombre</span> * <span class="variable">leNombre</span>));</pre><p>La fonction <a name="key54"></a><code>Number</code> convertit une valeur en nombre, ce qui est nécessaire
dans notre cas parce que le résultat de <code>prompt</code> est une chaîne de caractères.
Il existe des fonctions similaires appelées <a name="key55"></a><code>String</code> et <a name="key56"></a><code>Boolean</code> qui
convertissent des valeurs dans ces types.</p></div><hr/><div class="block"><p>Considérons un programme qui affiche tous les nombres pairs de 0 à 12. Une
façon de le faire est d’écrire :</p><pre class="code"><span class="variable">print</span>(<span class="atom">0</span>);
<span class="variable">print</span>(<span class="atom">2</span>);
<span class="variable">print</span>(<span class="atom">4</span>);
<span class="variable">print</span>(<span class="atom">6</span>);
<span class="variable">print</span>(<span class="atom">8</span>);
<span class="variable">print</span>(<span class="atom">10</span>);
<span class="variable">print</span>(<span class="atom">12</span>);</pre><p>Ça marche, mais lorsque nous écrivons un programme l’idée est de nous épargner
du travail et non pas de nous en donner plus. Si nous avions besoin des nombres
pairs jusqu’à 100 cette méthode deviendrait tout simplement inexploitable. Nous
avons besoin d’une manière de répéter une portion de code automatiquement.</p><pre class="code"><span class="keyword">var</span> <span class="variable">nombreCourant</span> = <span class="atom">0</span>;
<span class="keyword">while</span> (<span class="variable">nombreCourant</span> &lt;= <span class="atom">12</span>) {
  <span class="variable">print</span>(<span class="variable">nombreCourant</span>);
  <span class="variable">nombreCourant</span> = <span class="variable">nombreCourant</span> + <span class="atom">2</span>;
}</pre><p>Vous avez sûrement vu dans l’introduction le mot <a name="key57"></a><code>while</code>. Une instruction
démarrant par <code>while</code> crée une <a name="key58"></a>boucle. Une boucle est une perturbation dans
la séquence des instructions ―&nbsp;il fera répéter plusieurs fois au programme une
séquence de code. Dans notre cas le mot <code>while</code> est suivi par une expression
entre parenthèses (les parenthèses étant obligatoires) qui détermine si la
boucle continue à s’exécuter ou si elle doit s’arrêter. Aussi longtemps que la
valeur booléenne produite par cette expression est <code>true</code>, le code à
l’intérieur de la boucle est répété. Dès qu’elle devient <code>false</code> le programme
se place à la fin de la boucle et reprend à la normale.</p><p>La variable <code>nombreCourant</code> montre la façon dont une variable peut suivre la
progression d’un programme. À chaque fois que la boucle est répétée la variable
est incrémentée de <code>2</code> et à chaque début elle est comparée au nombre <code>12</code> pour
décider si la boucle continue ou non.</p><p>La troisième partie d’une instruction <code>while</code> est une autre instruction. C’est
le <a name="key59"></a>corps de la boucle qui contient les actions qui doivent se reproduire
plusieurs fois. Si nous ne devions pas afficher les nombres le programme aurait
pu être :</p><pre class="code"><span class="keyword">var</span> <span class="variable">nombreCourant</span> = <span class="atom">0</span>;
<span class="keyword">while</span> (<span class="variable">nombreCourant</span> &lt;= <span class="atom">12</span>)
  <span class="variable">nombreCourant</span> = <span class="variable">nombreCourant</span> + <span class="atom">2</span>;</pre><p>Ici <code>nombreCourant = nombreCourant + 2;</code> est l’instruction qui forme le corps
de la boucle. Mais nous devons aussi afficher le nombre, donc la boucle sera
constituée d’une instruction supplémentaire. Les<a name="key60"></a>accolades (<code>{</code> et <code>}</code>)
sont utilisées pour grouper des instructions dans des <a name="key61"></a>blocs. Pour le reste du
code un bloc compte comme une seule et même instruction. Dans l’exemple
précédent ceci est utilisé pour inclure dans la boucle à la fois l’appel à la
fonction <code>print</code> et l’instruction qui actualise la variable <code>nombreCourant</code>.</p></div><hr/><div class="block"><a name="exercise2"></a><div class="exercisenum">Ex. 2.2</div><div class="exercise"><p>Utilisez cette technique pour écrire un programme qui calcule et affiche la
valeur de 2<sup>10</sup> (2 à la puissance 10). Vous n’êtes bien sûr pas autorisé à
tricher en écrivant juste <code>2 * 2 * …</code>.</p><p>Si vous avez des problèmes avec ça, essayez de comparer avec l’exemple des
nombres pairs. Le programme doit exécuter une action un certain nombre de fois.
Pour cela, on peut utiliser une variable compteur avec une boucle <code>while</code>. À la
place d’afficher le compteur, le programme doit multiplier quelque chose par
deux. Ce quelque chose doit être une variable dans laquelle le résultat sera
construit.</p><p>Ne vous inquiétez pas si vous ne voyez pas tout de suite comment cela peut
fonctionner. Même si vous comprenez parfaitement tous les concepts de ce
chapitre, il peut être difficile de les appliquer à des problèmes concrets.
Lire et écrire du code vous aidera à développer votre sensibilité pour ça.
Donc, étudiez la solution, et essayez le prochain exercice.</p></div><div class="solution"><pre class="code"><span class="keyword">var</span> <span class="variable">resultat</span> = <span class="atom">1</span>;
<span class="keyword">var</span> <span class="variable">compteur</span> = <span class="atom">0</span>;
<span class="keyword">while</span> (<span class="variable">compteur</span> &lt; <span class="atom">10</span>) {
  <span class="variable">resultat</span> = <span class="variable">resultat</span> * <span class="atom">2</span>;
  <span class="variable">compteur</span> = <span class="variable">compteur</span> + <span class="atom">1</span>;
}
<span class="variable">show</span>(<span class="variable">resultat</span>);</pre><p>Le compteur peut aussi commencer à <code>1</code> et être vérifié pour <code>&lt;= 10</code>, mais pour
des raisons que nous vous exposerons après il est préférable de commencer à
compter depuis 0.</p><p>Évidemment vos solutions n’ont pas à être exactement identiques aux miennes.
Elles doivent fonctionner. Et dans le cas où elles seraient très différentes,
assurez-vous d’avoir compris la mienne.</p></div></div><hr/><div class="block"><a name="exercise3"></a><div class="exercisenum">Ex. 2.3</div><div class="exercise"><p>Avec quelques petites modifications, la solution à l’exercice précédent peut
être utilisée pour tracer un triangle. Et quand je dis «&nbsp;tracer un triangle&nbsp;»,
je veux dire «&nbsp;afficher du texte qui ressemble presque à un triangle quand on
louche&nbsp;».</p><p>Affichez dix lignes. Sur la première, mettez un «&nbsp;#&nbsp;». Sur la deuxième
mettez-en deux, et ainsi de suite.</p><p>Comment avoir une chaîne composée de X «&nbsp;#&nbsp;»&nbsp;? Une solution est de la
construire avec une «&nbsp;boucle imbriquée&nbsp;», c’est-à-dire une boucle dans une
boucle. Une méthode plus simple est de réutiliser la chaîne de la précédente
itération, et d’y ajouter un caractère.</p></div><div class="solution"><pre class="code"><span class="keyword">var</span> <span class="variable">ligne</span> = <span class="string">&quot;&quot;</span>;
<span class="keyword">var</span> <span class="variable">compteur</span> = <span class="atom">0</span>;
<span class="keyword">while</span> (<span class="variable">compteur</span> &lt; <span class="atom">10</span>) {
  <span class="variable">ligne</span> = <span class="variable">ligne</span> + <span class="string">&quot;#&quot;</span>;
  <span class="variable">print</span>(<span class="variable">ligne</span>);
  <span class="variable">compteur</span> = <span class="variable">compteur</span> + <span class="atom">1</span>;
}</pre></div></div><hr/><div class="block"><p>Vous remarquerez les espaces que j’ai mis devant certaines instructions. Ils ne
sont pas nécessaires : l’ordinateur accepte très bien un programme sans ces
espaces. En fait, même les retours à la ligne sont facultatifs.</p><p>Vous pouvez les écrire sur une seule longue ligne si cela vous fait plaisir. Le
rôle de l’<a name="key62"></a>indentation dans les blocs est de construire la structure du code
de manière plus claire et lisible pour les humains. Parce qu’on peut créer un
nouveau bloc dans un autre et il peut alors devenir difficile de voir où un
bloc finit et où un autre commence dans des parties complexes de code. Quand
les lignes sont indentées, la forme visuelle du code correspond à la forme des
blocs. Je préfère utiliser deux espaces pour chaque nouveau bloc, mais les
goûts varient.</p><p>La zone de la console où vous pouvez taper des programmes ajoutera
automatiquement ces espaces. Ça peut sembler pénible au début, mais quand vous
écrirez beaucoup de code, vous verrez que c’est un gain de temps important.
Appuyer sur la touche «&nbsp;tab&nbsp;» réindentera la ligne sur laquelle est le curseur.</p><p>Dans quelques cas, le JavaScript vous autorise à omettre le point-virgule en
fin d’instruction. Dans d’autres cas, il faut le mettre sans quoi des choses
étranges se produiront. Les règles définissant quand on peut les oublier sont
complexes et particulières. Dans ce livre, je ne les enlèverai jamais et je
vous conseille vivement de faire de même pour vos propres programmes.</p></div><hr/><div class="block"><p>L’utilisation de <code>while</code> que nous avons vu plus haut suit toujours le même
modèle. Premièrement une variable «&nbsp;compteur&nbsp;» est créée. Elle tracera la
progression dans la boucle. L’instruction <code>while</code> contient une vérification,
généralement pour voir si le compteur a atteint sa limite. Ensuite, à la fin du
corps de la boucle, le compteur est mis à jour.</p><p>Beaucoup de boucles obéissent à ce schéma. C’est pour cette raison que le
JavaScript, comme d’autres langages, s’affiche sous une forme plus ramassée et
plus complète :</p><pre class="code"><span class="keyword">for</span> (<span class="keyword">var</span> <span class="variable">nombre</span> = <span class="atom">0</span>; <span class="variable">nombre</span> &lt;= <span class="atom">12</span>; <span class="variable">nombre</span> = <span class="variable">nombre</span> + <span class="atom">2</span>)
  <span class="variable">show</span>(<span class="variable">nombre</span>);</pre><p>Ce code est strictement équivalent à l’exemple précédent qui affichait les
nombres pairs. La seule différence est que toutes les instructions liées à
l’état de la boucle sont maintenant sur une seule ligne. La parenthèse après le
<a name="key63"></a><code>for</code> doit contenir deux points-virgules. La première partie <em>initialise</em> la
boucle, généralement en définissant une variable. La deuxième est l’instruction
qui <em>vérifie</em> l’état de la boucle. Et la dernière partie <em>modifie</em> l’état de la
boucle. Dans beaucoup de cas, cette forme est plus claire et concise qu’une
construction avec <code>while</code>.</p></div><hr/><div class="block"><p>J’ai utilisé une <a name="key64"></a>casse plutôt bizarre dans certains noms de variables. Comme
vous ne pouvez pas utiliser d’espace dans ces noms ― l’ordinateur les lirait
comme deux variables distinctes ―&nbsp;vos choix pour un nom composé de plusieurs
mots sont plus ou moins limités aux solutions suivantes : <code>petitpandaroux</code>,
<code>petit_panda_roux</code>, <code>PetitPandaRoux</code> ou <code>petitPandaRoux</code>. Le premier est
difficile à lire. Personnellement, j’aime celui avec les tirets bas, bien que
ce soit un peu pénible à taper. Toutefois, les fonctions JavaScript standards
et la plupart des programmeurs JavaScript suivent la dernière syntaxe. Il n’est
pas compliqué de s’habituer à ce genre de petites choses, alors je vais
simplement suivre la majorité et mettre une majuscule à la première lettre de
chaque mot excepté le premier.</p><p>Dans quelques cas, comme dans la fonction <code>Number</code>, la première lettre d’une
variable est également en majuscule. Cela a été défini pour marquer cette
fonction comme étant un constructeur. Ce qu’est un constructeur deviendra clair
dans le <a href="chapter8.html">chapitre 8</a>. Pour l’instant, l’important est de ne pas se soucier de cet
apparent manque de cohérence.</p><p>Notez que les noms ayant une signification spéciale tels que <code>var</code>, <code>while</code> et
<code>for</code> ne peuvent pas être utilisés en tant que noms de variables. Ils sont
appelés <a name="key65"></a>mots-clés. Il y a également un certain nombre de <a name="key66"></a>mots qui sont «&nbsp;réservés pour l’utilisation&nbsp;» dans de futures versions
de JavaScript. Ceux-ci ne sont également officiellement pas autorisés à être
utilisés comme noms de variables, bien que certains navigateurs les autorisent.
La liste complète est assez longue :</p><pre class="preformatted">abstract boolean break byte case catch char class const continue debugger
default delete do double else enum export extends false final finally float
for function goto if implements import in instanceof int interface long
native new null package private protected public return short static super
switch synchronized this throw throws transient true try typeof var void
volatile while with</pre><p>Ne vous souciez pas de les mémoriser pour le moment, mais souvenez-vous qu’ils
peuvent être la cause d’un problème lorsque quelque chose ne fonctionne pas
comme prévu. D’après mon expérience, <code>char</code> (pour stocker une chaîne d’un seul
caractère) et <a name="key67"></a><code>class</code> sont les noms d’utilisation incorrecte les plus
communs.</p></div><hr/><div class="block"><a name="exercise4"></a><div class="exercisenum">Ex. 2.4</div><div class="exercise"><p>Réécrivez les solutions des deux exercices précédents en utilisant <code>for</code> à la
place de <code>while</code>.</p></div><div class="solution"><pre class="code"><span class="keyword">var</span> <span class="variable">resultat</span> = <span class="atom">1</span>;
<span class="keyword">for</span> (<span class="keyword">var</span> <span class="variable">compteur</span> = <span class="atom">0</span>; <span class="variable">compteur</span> &lt; <span class="atom">10</span>; <span class="variable">compteur</span> = <span class="variable">compteur</span> + <span class="atom">1</span>)
  <span class="variable">resultat</span> = <span class="variable">resultat</span> * <span class="atom">2</span>;
<span class="variable">show</span>(<span class="variable">compteur</span>);</pre><p>Notez que même s’il n’y a pas de bloc ouvert avec une «&nbsp;<code>{</code>&nbsp;», l’instruction
dans la boucle est toujours indentée avec deux espaces pour bien spécifier son
«&nbsp;appartenance&nbsp;» à la ligne du dessus.</p><pre class="code"><span class="keyword">var</span> <span class="variable">ligne</span> = <span class="string">&quot;&quot;</span>;
<span class="keyword">for</span> (<span class="keyword">var</span> <span class="variable">compteur</span> = <span class="atom">0</span>; <span class="variable">compteur</span> &lt; <span class="atom">10</span>; <span class="variable">compteur</span> = <span class="variable">compteur</span> + <span class="atom">1</span>) {
  <span class="variable">ligne</span> = <span class="variable">ligne</span> + <span class="string">&quot;#&quot;</span>;
  <span class="variable">print</span>(<span class="variable">ligne</span>);
}</pre></div></div><hr/><div class="block"><p><a name="key68"></a><a name="key69"></a><a name="key70"></a><a name="key71"></a>Un programme a souvent besoin «&nbsp;d’actualiser&nbsp;» une
variable avec une valeur basée sur sa valeur précédente. Par exemple <code>compteur
= compteur + 1</code>. JavaScript fournit un raccourci pour cela : <code>compteur += 1</code>.
Ça fonctionne également pour beaucoup d’autres opérateurs, par exemple
<code>resultat *= 2</code> pour doubler la valeur de <code>resultat</code>, ou <code>compteur -= 1</code> pour
compter à rebours.</p><p><a name="key72"></a><a name="key73"></a>Pour <code>compteur += 1</code> et <code>compteur -= 1</code>, il existe même des
versions abrégées : <code>compteur++</code> et <code>compteur--</code>.</p></div><hr/><div class="block"><p>On dit que les boucles affectent le <a name="key74"></a>flux d’exécution d’un programme. Elles
changent l’ordre dans lequel les instructions sont exécutées. Dans de nombreux
cas, un autre type de flux est utile : les instructions de sauts.</p><p>Nous voulons afficher tous les nombres en dessous de 20 qui sont divisibles à
la fois par 3 et par 4.</p><pre class="code"><span class="keyword">for</span> (<span class="keyword">var</span> <span class="variable">compteur</span> = <span class="atom">0</span>; <span class="variable">compteur</span> &lt; <span class="atom">20</span>; <span class="variable">compteur</span>++) {
  <span class="keyword">if</span> (<span class="variable">compteur</span> % <span class="atom">3</span> == <span class="atom">0</span> &amp;&amp; <span class="variable">compteur</span> % <span class="atom">4</span> == <span class="atom">0</span>)
    <span class="variable">show</span>(<span class="variable">compteur</span>);
}</pre><p>Le mot-clé <a name="key75"></a><code>if</code> n’est pas très différent du mot-clé <code>while</code> : il vérifie la
condition qu’on lui donne (entre parenthèses) et exécute l’instruction suivante
en fonction de cette condition. Mais il ne fait cela qu’une seule fois, donc
l’instruction est exécutée zéro ou une fois.</p><p>L’astuce avec l’opérateur modulo (<a name="key76"></a><code>%</code>) est une manière simple de tester si un
nombre est divisible par un autre nombre. S’il l’est, le reste de leur
division, qui est ce que modulo produit, est zéro.</p><p>Si nous avions voulu afficher tous les nombres en dessous de 20, mais en
affichant entre parenthèses ceux n’étant pas divisibles par 4, nous aurions pu
le faire de cette façon :</p><pre class="code"><span class="keyword">for</span> (<span class="keyword">var</span> <span class="variable">compteur</span> = <span class="atom">0</span>; <span class="variable">compteur</span> &lt; <span class="atom">20</span>; <span class="variable">compteur</span>++) {
  <span class="keyword">if</span> (<span class="variable">compteur</span> % <span class="atom">4</span> == <span class="atom">0</span>)
    <span class="variable">print</span>(<span class="variable">compteur</span>);
  <span class="keyword">if</span> (<span class="variable">compteur</span> % <span class="atom">4</span> != <span class="atom">0</span>)
    <span class="variable">print</span>(<span class="string">&quot;(&quot;</span> + <span class="variable">compteur</span> + <span class="string">&quot;)&quot;</span>);
}</pre><p>Mais maintenant le programme doit déterminer si <code>compteur</code> est divisible par
<code>4</code> deux fois. Le même effet peut être obtenu en ajoutant une partie <code>else</code> («
sinon&nbsp;») après l’instruction <code>if</code>. L’instruction <a name="key77"></a><code>else</code> est exécutée
seulement lorsque la condition <code>if</code> est fausse.</p><pre class="code"><span class="keyword">for</span> (<span class="keyword">var</span> <span class="variable">compteur</span> = <span class="atom">0</span>; <span class="variable">compteur</span> &lt; <span class="atom">20</span>; <span class="variable">compteur</span>++) {
  <span class="keyword">if</span> (<span class="variable">compteur</span> % <span class="atom">4</span> == <span class="atom">0</span>)
    <span class="variable">print</span>(<span class="variable">compteur</span>);
  <span class="keyword">else</span>
    <span class="variable">print</span>(<span class="string">&quot;(&quot;</span> + <span class="variable">compteur</span> + <span class="string">&quot;)&quot;</span>);
}</pre><p>Pour aller plus loin avec cet exemple trivial, nous voulons maintenant afficher
ces mêmes nombres tout en leur ajoutant deux étoiles lorsqu’ils sont plus
grands que 15, une étoile lorsqu’ils sont plus grands que 10 (mais pas plus
grands que 15), et aucune étoile dans les autres cas.</p><pre class="code"><span class="keyword">for</span> (<span class="keyword">var</span> <span class="variable">compteur</span> = <span class="atom">0</span>; <span class="variable">compteur</span> &lt; <span class="atom">20</span>; <span class="variable">compteur</span>++) {
  <span class="keyword">if</span> (<span class="variable">compteur</span> &gt; <span class="atom">15</span>)
    <span class="variable">print</span>(<span class="variable">compteur</span> + <span class="string">&quot;**&quot;</span>);
  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">compteur</span> &gt; <span class="atom">10</span>)
    <span class="variable">print</span>(<span class="variable">compteur</span> + <span class="string">&quot;*&quot;</span>);
  <span class="keyword">else</span>
    <span class="variable">print</span>(<span class="variable">compteur</span>);
}</pre><p>Cela montre que vous pouvez enchaîner des instructions <code>if</code>. Dans ce cas, le
programme regarde d’abord si <code>compteur</code> est plus grand que <code>15</code>. Si c’est le
cas, les deux étoiles sont affichées et les autres tests sont ignorés. Si ce
n’est pas le cas, on continue à vérifier si la valeur est supérieure à <code>10</code>. Et
on n’arrive à la dernière instruction <code>print</code> que si <code>compteur</code> n’est pas
supérieur à <code>10</code>.</p></div><hr/><div class="block"><a name="exercise5"></a><div class="exercisenum">Ex. 2.5</div><div class="exercise"><p>Écrivez un programme qui vous demandera, en utilisant <code>prompt</code>, quelle est la
valeur de 2 + 2. Si la réponse est «&nbsp;4&nbsp;», utilisez <code>alert</code> pour afficher un
message sympa. Si c’est «&nbsp;3&nbsp;» ou «&nbsp;5&nbsp;», affichez «&nbsp;Ça y était presque&nbsp;!&nbsp;». Dans
les autres cas, n’hésitez pas à dire quelque chose de méchant.</p></div><div class="solution"><pre class="code"><span class="keyword">var</span> <span class="variable">reponse</span> = <span class="variable">prompt</span>(<span class="string">&quot;Hé vous&nbsp;! Quelle est la valeur de 2 + 2&nbsp;?&quot;</span>, <span class="string">&quot;&quot;</span>);
<span class="keyword">if</span> (<span class="variable">reponse</span> == <span class="string">&quot;4&quot;</span>)
  <span class="variable">alert</span>(<span class="string">&quot;Vous êtes un vrai génie&nbsp;!&quot;</span>);
<span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">reponse</span> == <span class="string">&quot;3&quot;</span> || <span class="variable">reponse</span> == <span class="string">&quot;5&quot;</span>)
  <span class="variable">alert</span>(<span class="string">&quot;Ça y était presque&nbsp;!&quot;</span>);
<span class="keyword">else</span>
  <span class="variable">alert</span>(<span class="string">&quot;Vous êtes nul&nbsp;!&quot;</span>);</pre></div></div><hr/><div class="block"><p>Lorsqu’une boucle n’a pas systématiquement besoin d’aller jusqu’au bout de ses
instructions, le mot-clé <a name="key78"></a><code>break</code> peut être utile. Il permet de sortir de la
boucle et d’exécuter les instructions suivantes. Ce programme trouve le premier
nombre supérieur à 20 et divisible par 7 :</p><pre class="code"><span class="keyword">for</span> (<span class="keyword">var</span> <span class="variable">courant</span> = <span class="atom">20</span>; ; <span class="variable">courant</span>++) {
  <span class="keyword">if</span> (<span class="variable">courant</span> % <span class="atom">7</span> == <span class="atom">0</span>)
    <span class="keyword">break</span>;
}
<span class="variable">print</span>(<span class="variable">courant</span>);</pre><p>La structure <code>for</code> présentée ci-dessus n’a pas de mécanisme qui vérifie quand
terminer la boucle. Cela signifie qu’elle est dépendante de l’instruction
<code>break</code> qui est à l’intérieur pour pouvoir s’arrêter. Le même programme aurait
pu s’écrire aussi simplement…</p><pre class="code"><span class="keyword">for</span> (<span class="keyword">var</span> <span class="variable">courant</span> = <span class="atom">20</span>; <span class="variable">courant</span> % <span class="atom">7</span> != <span class="atom">0</span>; <span class="variable">courant</span>++)
  ;
<span class="variable">print</span>(<span class="variable">courant</span>);</pre><p>Dans ce cas, le corps de la boucle est vide. Un point-virgule isolé peut être
utilisé pour produire une instruction vide. Ici, le seul effet de la boucle est
d’incrémenter la variable <code>courant</code> à la valeur voulue. Mais j’avais besoin
d’un exemple utilisant <code>break</code>, donc prêtez également attention à la première
version.</p></div><hr/><div class="block"><a name="exercise6"></a><div class="exercisenum">Ex. 2.6</div><div class="exercise"><p>Ajoutez un <code>while</code>, et optionnellement un <code>break</code>, à votre solution du
précédent exercice, afin que le programme continue à répéter la question
jusqu’à ce qu’une réponse correcte soit donnée.</p><p>Notez que <code>while (true) …</code> peut être utilisé pour créer une boucle qui ne
s’arrêtera pas d’elle-même. C’est un peu ridicule, vous demandez au programme
de boucler tant que <code>true</code> est <code>true</code>, mais c’est une astuce utile.</p></div><div class="solution"><pre class="code"><span class="keyword">var</span> <span class="variable">reponse</span>;
<span class="keyword">while</span> (<span class="atom">true</span>) {
  <span class="variable">reponse</span> = <span class="variable">prompt</span>(<span class="string">&quot;Hé vous&nbsp;! Quelle est la valeur de 2 + 2&nbsp;?&quot;</span>, <span class="string">&quot;&quot;</span>);
  <span class="keyword">if</span> (<span class="variable">reponse</span> == <span class="string">&quot;4&quot;</span>) {
    <span class="variable">alert</span>(<span class="string">&quot;Vous êtes un vrai génie&nbsp;!&quot;</span>);
    <span class="keyword">break</span>;
  }
  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">reponse</span> == <span class="string">&quot;3&quot;</span> || <span class="variable">reponse</span> == <span class="string">&quot;5&quot;</span>) {
    <span class="variable">alert</span>(<span class="string">&quot;Ça y était presque&nbsp;!&quot;</span>);
  }
  <span class="keyword">else</span> {
    <span class="variable">alert</span>(<span class="string">&quot;Vous êtes nul&nbsp;!&quot;</span>);
  }
}</pre><p>Puisque le corps du premier <code>if</code> comporte deux instructions, j’ai ajouté des
accolades autour de tous les corps de <code>if</code>. C’est une question de goût. Avoir
une chaîne <code>if</code>/<code>else</code> où certains corps sont des blocs et d’autres des
instructions simples me semble un peu bancal. Mais je vous laisse vous faire
votre propre opinion à ce propos.</p><p>Une autre solution, probablement meilleure mais sans <code>break</code>, est la suivante :</p><pre class="code"><span class="keyword">var</span> <span class="variable">valeur</span> = <span class="atom">null</span>;
<span class="keyword">while</span> (<span class="variable">valeur</span> != <span class="string">&quot;4&quot;</span>) {
  <span class="variable">valeur</span> = <span class="variable">prompt</span>(<span class="string">&quot;Hé vous&nbsp;! Quelle est la valeur de 2 + 2&nbsp;?&quot;</span>, <span class="string">&quot;&quot;</span>);
  <span class="keyword">if</span> (<span class="variable">valeur</span> == <span class="string">&quot;4&quot;</span>)
    <span class="variable">alert</span>(<span class="string">&quot;Vous êtes un vrai génie&nbsp;!&quot;</span>);
  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">valeur</span> == <span class="string">&quot;3&quot;</span> || <span class="variable">valeur</span> == <span class="string">&quot;5&quot;</span>)
    <span class="variable">alert</span>(<span class="string">&quot;Ça y était presque&nbsp;!&quot;</span>);
  <span class="keyword">else</span>
    <span class="variable">alert</span>(<span class="string">&quot;Vous êtes nul&nbsp;!&quot;</span>);
}</pre></div></div><hr/><div class="block"><p>Dans la solution de l’exercice précédent se trouve une instruction <code>var
reponse;</code>. Elle crée une variable appelée <code>reponse</code>, mais ne lui donne pas de
valeur. Que se passe-t-il alors lorsqu’on prend la valeur de cette variable&nbsp;?</p><pre class="code"><span class="keyword">var</span> <span class="variable">variableMystere</span>;
<span class="variable">show</span>(<span class="variable">variableMystere</span>);</pre><p>En termes de tentacules, cette variable se termine dans les airs, elle ne
s’accroche à rien. Quand vous demandez la valeur d’une variable vide, vous
obtenez une valeur spéciale appelée <a name="key79"></a><code>undefined</code>. Les fonctions qui ne
retournent pas de valeur convenable, comme <code>print</code> et <code>alert</code>, retournent la
valeur <code>undefined</code>.</p><pre class="code"><span class="variable">show</span>(<span class="variable">alert</span>(<span class="string">&quot;Je suis un effet de bord.&quot;</span>));</pre><p>Il y a aussi une valeur similaire, <a name="key80"></a><code>null</code>, qui signifie que «&nbsp;cette variable
est définie mais qu’elle n’a pas de valeur&nbsp;». La différence entre <code>undefined</code>
et <code>null</code> est principalement académique, et la plupart du temps sans intérêt.
Dans la pratique, il est souvent nécessaire de vérifier si quelque chose
possède une valeur. Dans ce cas, l’expression <code>quelqueChose == undefined</code> peut
être utilisée, parce que même si ces deux valeurs ne sont pas strictement
équivalentes, <code>null == undefined</code> retournera <code>true</code>.  </p></div><hr/><div class="block"><p>Ceci nous amène à aborder un autre sujet un peu plus délicat…</p><pre class="code"><span class="variable">show</span>(<span class="atom">false</span> == <span class="atom">0</span>);
<span class="variable">show</span>(<span class="string">&quot;&quot;</span> == <span class="atom">0</span>);
<span class="variable">show</span>(<span class="string">&quot;5&quot;</span> == <span class="atom">5</span>);</pre><p><a name="key81"></a>Toutes ces expressions retournent <code>true</code>. Quand on compare
des valeurs de différents types, JavaScript utilise un ensemble de règles
complexes et déroutantes. Je ne vais pas essayer de les expliquer précisément.
Dans beaucoup de cas, il essayera juste de convertir une des variables dans le
type de l’autre variable. Cependant, quand <code>null</code> ou <code>undefined</code> apparaît, il
produira <code>true</code> seulement si les deux sont <code>null</code> ou <code>undefined</code>.</p><p>Que faire quand vous voulez tester si une variable se réfère à la valeur
<code>false</code>&nbsp;? La règle pour convertir des chaînes et des nombres en valeurs
booléennes est que <code>0</code> et la chaîne vide sont considérés comme <code>false</code>, alors
que toutes les autres valeurs comptent pour <code>true</code>. À cause de ça, l’expression
<code>variable == false</code> est également <code>true</code> quand <code>variable</code> se réfère à <code>0</code> ou à
<code>&quot;&quot;</code>. Pour des cas comme celui-ci, où vous ne voulez <em>aucune</em> conversion
automatique de types, il existe deux nouveaux opérateurs : <a name="key82"></a><code>===</code> et <a name="key83"></a><code>!==</code>.
Le premier teste si une valeur est précisément égale à l’autre. Le deuxième
teste si elles ne sont pas précisément égales.</p><pre class="code"><span class="variable">show</span>(<span class="atom">null</span> === <span class="atom">undefined</span>);
<span class="variable">show</span>(<span class="atom">false</span> === <span class="atom">0</span>);
<span class="variable">show</span>(<span class="string">&quot;&quot;</span> === <span class="atom">0</span>);
<span class="variable">show</span>(<span class="string">&quot;5&quot;</span> === <span class="atom">5</span>);</pre><p>Toutes ces instructions retournent <code>false</code>.</p></div><hr/><div class="block"><p>Les valeurs passées comme conditions à une instruction <code>if</code>, <code>while</code>, ou <code>for</code>
ne sont pas obligatoirement booléennes. Elles sont automatiquement converties
en booléen avant d’être vérifiées. Cela signifie que le nombre <code>0</code>, la chaîne
vide <code>&quot;&quot;</code>, <code>null</code>, <code>undefined</code>, et bien sûr <code>false</code>, seront tous considérés
comme <code>false</code>.</p><p>Le fait que toutes les autres valeurs soient converties en <code>true</code> permet
d’omettre des comparaisons explicites dans beaucoup de situations. Si on sait
qu’une variable contient une chaîne de caractères ou <code>null</code>, elle peut être
utilisée dans une vérification de façon très simple…</p><pre class="code"><span class="keyword">var</span> <span class="variable">peutEtreNull</span> = <span class="atom">null</span>;
<span class="comment">// …code mystérieux qui pourrait affecter une chaîne à peutEtreNull…</span>
<span class="keyword">if</span> (<span class="variable">peutEtreNull</span>)
  <span class="variable">print</span>(<span class="string">&quot;peutEtreNull possède une valeur&quot;</span>);</pre><p>…à l’exception du cas où ce code mystérieux affecte la valeur <code>&quot;&quot;</code> à
<code>peutEtreNull</code>. Une chaîne vide étant dans ce cas équivalente à <code>false</code>, rien
ne sera affiché. Suivant ce que vous essayez de faire, cette méthode peut donc
se révéler <em>mauvaise</em>. C’est donc souvent une bonne idée d’ajouter un <code>===
null</code> ou un <code>=== false</code> explicite dans des cas comme celui-ci, pour éviter des
erreurs subtiles. Cette remarque est aussi valable pour les valeurs numériques
qui peuvent être égales à <code>0</code>.</p></div><hr/><div class="block"><p>La ligne qui parle du «&nbsp;code mystérieux&nbsp;» dans l’exemple précédent peut vous
sembler un peu étrange. C’est souvent utile pour inclure du texte
supplémentaire dans un programme. On l’utilise le plus souvent pour ajouter à
un programme des explications en langage humain.</p><pre class="code"><span class="comment">// La variable compteur, qui va être définie, commencera</span>
<span class="comment">// par la valeur 0, c’est-à-dire par zéro.</span>
<span class="keyword">var</span> <span class="variable">compteur</span> = <span class="atom">0</span>;
<span class="comment">// Maintenant, nous allons créer une boucle.</span>
<span class="keyword">while</span> (<span class="variable">compteur</span> &lt; <span class="atom">100</span> <span class="comment">/* compteur est inférieur à 100 */</span>)
<span class="comment">/* À chaque fois que l’on boucle, on incrémente la valeur du compteur,
   mais oui, on ajoute seulement un. */</span>
  <span class="variable">compteur</span>++;
<span class="comment">// Puis c’est fini.</span></pre><p>Ce type de texte est appelé un <a name="key84"></a>commentaire. Les règles sont les suivantes :
&quot;<code>/*</code>&quot; commence un commentaire qui se termine au prochain &quot;<code>*/</code>&quot;. &quot;<code>//</code>&quot; débute
un autre type de commentaire qui finit à la fin de la ligne.</p><p>Comme vous pouvez le voir, même les programmes les plus simples peuvent être
faits pour avoir l’air gros, laid et compliqué, simplement en ajoutant beaucoup
de commentaires.</p></div><hr/><div class="block"><p>Il existe d’autres situations qui provoquent automatiquement une <a name="key85"></a>conversion de
type. Si vous ajoutez une valeur non-chaîne à une chaîne, cette valeur est
automatiquement convertie en chaîne avant d’être concaténée. Si vous multipliez
un nombre et une chaîne, JavaScript essaie de créer un nombre avec la chaîne.</p><pre class="code"><span class="variable">show</span>(<span class="string">&quot;Apollo&quot;</span> + <span class="atom">5</span>);
<span class="variable">show</span>(<span class="atom">null</span> + <span class="string">&quot;ifier&quot;</span>);
<span class="variable">show</span>(<span class="string">&quot;5&quot;</span> * <span class="atom">5</span>);
<span class="variable">show</span>(<span class="string">&quot;fraises&quot;</span> * <span class="atom">5</span>);</pre><p>La dernière instruction donne pour résultat <a name="key86"></a><code>NaN</code>, qui est une valeur
particulière. Elle signifie «&nbsp;Pas un nombre&nbsp;» («&nbsp;Not a Number&nbsp;») et elle est de
type nombre (ce qui peut sembler légèrement paradoxal). Dans ce cas, cela
signifie qu’une fraise n’est pas un nombre. Toutes les opérations arithmétiques
sur la valeur <code>NaN</code> ont pour résultat <code>NaN</code>, c’est pourquoi en le multipliant
par <code>5</code> comme dans cet exemple, cela donne toujours <code>NaN</code>. De plus, et c’est
parfois assez perturbant, <code>NaN == NaN</code> est égal à <code>false</code>, vérifier si une
valeur est <code>NaN</code> peut être fait avec la fonction <a name="key87"></a><code>isNaN</code>. <code>NaN</code> est encore
(c’est la dernière) une de ces valeurs qui renvoient <code>false</code> quand elles sont
converties en booléens.</p><p>Ces conversions automatiques peuvent être très pratiques, mais elles sont aussi
plutôt bizarres et sujettes à erreur. Même si <code>+</code> et <code>*</code> sont tous deux des
opérateurs arithmétiques, ils se comportent de façon complètement différente
dans cet exemple. Dans mon propre code, j’utilise beaucoup <code>+</code> pour combiner
les chaînes et les non-chaînes, mais notez bien qu’il ne faut pas utiliser <code>*</code>
ni les autres opérateurs numériques sur des valeurs de chaînes. Convertir un
nombre en chaîne est toujours possible et simple, mais convertir une chaîne en
nombre peut très bien ne pas marcher du tout (voir la dernière ligne de
l’exemple). Mais nous pouvons utiliser <code>Number</code> pour convertir explicitement la
chaîne en nombre, ce qui rend plus visible le risque de nous retrouver devant
une valeur <code>NaN</code>.</p><pre class="code"><span class="variable">show</span>(<span class="variable">Number</span>(<span class="string">&quot;5&quot;</span>) * <span class="atom">5</span>);</pre></div><hr/><div class="block"><p>Quand nous parlions des opérateurs booléens <code>&amp;&amp;</code> et <code>||</code>, je vous avais dit
qu’ils produisent des valeurs booléennes. C’est en fait un peu trop simplifié.
Si vous les appliquez sur des valeurs booléennes, ils retournent des booléens.
Mais ils peuvent aussi s’appliquer à d’autres types de valeurs, et dans ces cas
ils retournent un de leurs arguments.</p><p>En fait, ce que <a name="key88"></a><code>||</code> fait réellement est ceci : il regarde la valeur de
gauche en premier. Si la conversion en booléen produit <code>true</code>, il retourne
cette valeur, sinon il retourne le membre de droite. Vérifiez par vous-même que
cela fonctionne correctement avec des arguments booléens. Pourquoi agit-il
comme cela&nbsp;? Cela s’avère très pratique. Considérons l’exemple suivant :</p><pre class="code"><span class="keyword">var</span> <span class="variable">input</span> = <span class="variable">prompt</span>(<span class="string">&quot;Quel est votre nom&nbsp;?&quot;</span>, <span class="string">&quot;Kilgore Trout&quot;</span>);
<span class="variable">print</span>(<span class="string">&quot;Bien le bonjour &quot;</span> + (<span class="variable">input</span> || <span class="string">&quot;cher ami&quot;</span>));</pre><p>Si l’utilisateur presse «&nbsp;Annuler&nbsp;» ou ferme la fenêtre de dialogue sans donner
de nom, la variable <code>input</code> prendra la valeur <code>null</code> ou <code>&quot;&quot;</code>. Ces deux valeurs
donneront <code>false</code> après conversion en booléen. L’expression <code>input || &quot;cher
ami&quot;</code> peut être lue dans ce cas comme «&nbsp;la valeur de la variable <code>input</code>, sinon
la chaîne <code>&quot;cher ami&quot;</code>&nbsp;». C’est une manière simple de fournir une valeur de secours.</p><p>L’opérateur <a name="key89"></a><code>&amp;&amp;</code> fonctionne sur le même principe mais dans l’autre sens.
Quand la valeur à sa gauche est quelque chose qui donnera <code>false</code> en étant
converti en booléen, il retournera cette valeur. Dans l’autre cas, il
retournera la valeur à sa droite.</p><p>Une autre propriété de ces deux opérateurs est que l’expression de droite n’est
évaluée que quand c’est nécessaire. Dans le cas <code>true ||X</code>, peu importe ce
qu’est <code>X</code>, le résultat sera toujours <code>true</code>, donc <code>X</code> n’est jamais évalué, et
s’il a des effets de bord, ils ne se produiront jamais. C’est la même chose
pour <code>false &amp;&amp; X</code>.</p><pre class="code"><span class="atom">false</span> || <span class="variable">alert</span>(<span class="string">&quot;Je suis en train d’apparaître&nbsp;!&quot;</span>);
<span class="atom">true</span> || <span class="variable">alert</span>(<span class="string">&quot;Pas moi.&quot;</span>);</pre></div><ol class="footnotes"><li><a name="footnote1"></a>Les bits sont toutes les choses à deux valeurs possibles, ils sont
habituellement décrits comme des <code>0</code> et des <code>1</code>. Dans l’ordinateur, ils se
concrétisent par une charge électrique élevée ou basse, un signal fort ou
faible, ou encore un point brillant ou terne sur la surface d’un CD.</li><li><a name="footnote2"></a>Si vous attendiez quelque chose comme <code>10010000</code> c’est bien vu, mais
continuez à lire. Les nombres JavaScript ne sont pas stockés comme des entiers.</li><li><a name="footnote3"></a>En fait 53, à cause d’une astuce utilisable pour obtenir un bit librement.
Consultez le format «&nbsp;IEEE 754&nbsp;» si vous êtes intéressé par les détails.</li><li><a name="footnote4"></a>Lorsque vous entrez des chaînes de caractères dans la console, vous pouvez
remarquer qu’elles reviennent avec des guillemets et des anti-slashes de la
même manière que vous les aviez saisies. Pour obtenir un affichage convenable
des caractères spéciaux, vous pouvez faire <code>print(&quot;a\nb&quot;)</code> ―&nbsp;nous verrons
pourquoi cela fonctionne dans quelques instants.</li><li><a name="footnote5"></a>Le récupérateur de bits est l’endroit où sont supposés être stockés les
vieux bits. Sur certains systèmes, les programmeurs doivent le vider
manuellement de temps en temps. Heureusement, JavaScript est fourni avec un
système automatique de recyclage des bits.</li></ol><h1><span class="number">Chapitre 3: </span>Fonctions</h1><div class="block"><p>Un programme doit souvent exécuter la même tâche en différents endroits. Il est
fastidieux de répéter à chaque fois les instructions nécessaires et c’est un
facteur d’erreurs possibles. Il vaudrait mieux réunir ces instructions au même
endroit et demander au programme d’y faire un détour chaque fois que c’est
nécessaire. C’est pour ça qu’on a inventé les <a name="key1"></a>fonctions : ce sont des unités
de code que le programme peut parcourir à volonté. Afficher une chaîne à
l’écran nécessite un certain nombre d’instructions, mais si nous disposons
d’une fonction <code>print</code> il nous suffit d’écrire <code>print(&quot;Aleph&quot;)</code> et le tour est
joué.</p><p>Cependant, si on voit les fonctions simplement comme des boîtes de conserve de
code on ne les considère pas à leur juste valeur. Si nécessaire, elles peuvent
jouer les rôles de fonctions pures, d’algorithmes, de détours, d’abstractions,
de moyens de décision, de modules, de prolongements, de structures de données
et de bien d’autres choses encore. Être capable d’utiliser efficacement des
fonctions est une compétence nécessaire pour qui veut programmer sérieusement.
Ce chapitre propose une introduction au sujet, le <a href="chapter6.html">chapitre 6</a> aborde plus en
profondeur les subtilités des fonctions.</p></div><hr/><div class="block"><p><a name="key2"></a>Pour commencer, les fonctions pures sont ce que l’on appelait «
fonction&nbsp;» en cours de mathématiques, que vous avez, je l’espère, suivi à un
moment de votre vie. Prendre le cosinus ou la valeur absolue d’un nombre est
une fonction pure à un argument. L’addition est une fonction pure à deux
arguments.</p><p>Les propriétés qui définissent les fonctions pures sont qu’elles retournent
toujours la même valeur pour les mêmes arguments et n’ont jamais d’effet de
bord. Elles prennent des arguments, retournent une valeur basée sur ces
arguments, et ne perdent pas leur temps à faire autre chose.</p><p>En JavaScript, l’addition est un opérateur, mais elle peut être encapsulée dans
une fonction comme ceci (et aussi inutile que cela puisse sembler, nous allons
rencontrer des situations dans lesquelles ça sera vraiment utile).  </p><pre class="code"><span class="keyword">function</span> <span class="variable">ajouter</span>(<span class="variabledef">a</span>, <span class="variabledef">b</span>) {
  <span class="keyword">return</span> <span class="localvariable">a</span> + <span class="localvariable">b</span>;
}

<span class="variable">show</span>(<span class="variable">ajouter</span>(<span class="atom">2</span>, <span class="atom">2</span>));</pre><p><code>ajouter</code> est le nom de la fonction. <code>a</code> et <code>b</code> sont les noms des deux
arguments.</p><p>Le mot-clé <a name="key3"></a><code>function</code> est toujours utilisé lorsque l’on crée une fonction.
Lorsqu’il est suivi d’un nom de variable, la fonction créée sera stockée sous
ce nom. À la suite du nom, vient une liste de noms d’<a name="key4"></a>arguments, et enfin,
après celle-ci le <a name="key5"></a>corps de la fonction. Contrairement à ceux autour du corps
d’une boucle <code>while</code> ou d’une instruction <code>if</code>, les accolades autour du corps
d’une fonction sont obligatoires<a class="footref" href="#footnote1">1</a>.</p><p>Le mot-clé <a name="key6"></a><code>return</code>, suivi d’une expression, est utilisé pour déterminer la
valeur qu’une fonction renvoie. Lorsque l’exécution arrive sur une instruction
<code>return</code>, elle saute immédiatement hors de la fonction courante et transmet la
valeur retournée au code qui a appelé la fonction. Une instruction <code>return</code>
sans expression à la suite fait renvoyer <code>undefined</code> à la fonction.</p><p>Un corps peut évidemment avoir plus d’une instruction en son sein. Voici une
fonction pour calculer des puissances (avec des exposants entiers positifs) : </p><pre class="code"><span class="keyword">function</span> <span class="variable">puissance</span>(<span class="variabledef">base</span>, <span class="variabledef">exposant</span>) {
  <span class="keyword">var</span> <span class="variabledef">resultat</span> = <span class="atom">1</span>;
  <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">compteur</span> = <span class="atom">0</span>; <span class="localvariable">compteur</span> &lt; <span class="localvariable">exposant</span>; <span class="localvariable">compteur</span>++)
    <span class="localvariable">resultat</span> *= <span class="localvariable">base</span>;
  <span class="keyword">return</span> <span class="localvariable">resultat</span>;
}

<span class="variable">show</span>(<span class="variable">puissance</span>(<span class="atom">2</span>, <span class="atom">10</span>));</pre><p>Si vous avez résolu l’<a href="chapter2.html#exercise2">exercice 2.2</a>, cette technique utilisée pour calculer une
puissance devrait vous sembler familière.</p><p>Créer une variable (<code>resultat</code>) et la mettre à jour sont des effets de bord.
Est-ce que je ne viens pas de dire que les fonctions pures n’ont pas d’effets
de bord&nbsp;?</p><p>Une variable créée à l’intérieur d’une fonction existe uniquement à l’intérieur
de celle-ci. Heureusement, sinon le programmeur devrait trouver un nom
différent pour chaque variable dont il a besoin dans un programme. Comme
<code>resultat</code> existe uniquement à l’intérieur de <code>puissance</code>, le changement ne
dure que jusqu’à ce que la fonction retourne quelque chose, et du point de vue
du code qui l’appelle, il n’y a pas d’effet de bord.  </p></div><hr/><div class="block"><a name="exercise1"></a><div class="exercisenum">Ex. 3.1</div><div class="exercise"><p>Écrivez une fonction appelée <code>absolu</code> qui retourne la valeur absolue du nombre
qui lui est donné en argument. La valeur absolue d’un nombre négatif est la
version positive du même nombre, et la valeur absolue d’un nombre positif (ou
zéro) est le nombre lui-même.</p></div><div class="solution"><pre class="code"><span class="keyword">function</span> <span class="variable">absolu</span>(<span class="variabledef">nombre</span>) {
  <span class="keyword">if</span> (<span class="localvariable">nombre</span> &lt; <span class="atom">0</span>)
    <span class="keyword">return</span> -<span class="localvariable">nombre</span>;
  <span class="keyword">else</span>
    <span class="keyword">return</span> <span class="localvariable">nombre</span>;
}

<span class="variable">show</span>(<span class="variable">absolu</span>(-<span class="atom">144</span>));</pre></div></div><hr/><div class="block"><p>Les fonctions pures ont deux propriétés très sympathiques. Il est facile de
s’en souvenir et de les réutiliser.</p><p>Si une fonction est pure, un appel à celle-ci peut être considéré comme une
chose indépendante. Si vous n’êtes pas sûr qu’elle fonctionne correctement,
vous pouvez la tester en l’appelant directement depuis la console, ce qui est
facile car elle ne dépend d’aucun contexte<a class="footref" href="#footnote2">2</a>. Il est facile de faire ces tests
automatiquement ―&nbsp;d’écrire un programme qui teste une fonction spécifique. Les
fonctions non pures peuvent renvoyer différentes valeurs basées sur toutes
sortes de facteurs, et avoir des effets de bord qui pourraient être difficiles
à tester et à prévoir.</p><p>Comme les fonctions pures sont auto-suffisantes, elles ont tendance à être
utiles et pertinentes dans un plus grand nombre de situations que les non
pures. Prenez <code>show</code>, par exemple. L’utilité de cette fonction dépend de la
présence d’un espace spécial à l’écran pour afficher sa sortie. Si cet espace
n’existe pas, la fonction est inutile. Nous pouvons imaginer une fonction
analogue, appelons-la <code>format</code>, qui prend une valeur en argument et renvoie une
chaîne de caractères représentant cette valeur. Cette fonction est utile dans
plus de situations que <code>show</code>.  </p><p>Bien sûr, <code>format</code> ne résout pas le même problème que <code>show</code>, et aucune
fonction pure ne sera capable de résoudre ce problème, parce que cela nécessite
des effets de bord. Dans beaucoup de cas, les fonctions non pures sont
exactement ce dont vous avez besoin. Dans d’autres cas, un problème peut être
résolu avec une fonction pure, mais la variante non-pure est beaucoup plus
adaptée ou efficace.</p><p>Par conséquent, lorsque quelque chose peut facilement être exprimé par une
fonction pure, écrivez-le ainsi. Mais ne vous sentez pas coupable d’avoir écrit
des fonctions non pures.</p></div><hr/><div class="block"><p>Les fonctions avec effets de bord ne contiennent pas obligatoirement une
instruction <code>return</code>. Si aucune instruction <code>return</code> n’est trouvée, la fonction
renvoie <code>undefined</code></p><pre class="code"><span class="keyword">function</span> <span class="variable">crier</span>(<span class="variabledef">message</span>) {
  <span class="variable">alert</span>(<span class="localvariable">message</span> + <span class="string">&quot;&nbsp;!!&quot;</span>);
}

<span class="variable">crier</span>(<span class="string">&quot;Youpi&quot;</span>);</pre></div><hr/><div class="block"><p>Les noms des arguments d’une fonction sont disponibles comme variables au sein
de celle-ci. Ils feront référence aux valeurs des arguments avec lesquels est
appelée la fonction, et comme les variables normales créées à l’intérieur d’une
fonction, ils n’existent pas à l’extérieur de celle-ci. En plus de
l’<a name="key7"></a>environnement global, il y a aussi de plus petits <a name="key8"></a>environnements locaux créés par des appels de fonctions. Lorsque l’on
cherche une variable à l’intérieur d’une fonction, l’environnement local est
examiné en premier, et ensuite, seulement si la variable n’existe pas là, on la
cherche dans l’environnement global. Cela permet à une variable à l’intérieur
d’une fonction de <a name="key9"></a>masquer une variable globale du même nom.</p><pre class="code"><span class="keyword">function</span> <span class="variable">alertEstPrint</span>(<span class="variabledef">valeur</span>) {
  <span class="keyword">var</span> <span class="variabledef">alert</span> = <span class="variable">print</span>;
  <span class="localvariable">alert</span>(<span class="localvariable">valeur</span>);
}

<span class="variable">alertEstPrint</span>(<span class="string">&quot;Troglodytes&quot;</span>);</pre><p>Les variables dans cet environnement local sont visibles seulement pour le code
à l’intérieur de la fonction. Si cette fonction appelle une autre fonction, la
fonction nouvellement créée ne voit pas les variables à l’intérieur de la
première fonction.</p><pre class="code"><span class="keyword">var</span> <span class="variable">variable</span> = <span class="string">&quot;globale&quot;</span>;

<span class="keyword">function</span> <span class="variable">afficherVariable</span>() {
  <span class="variable">print</span>(<span class="string">&quot;à l’intérieur de afficherVariable, la variable contient '&quot;</span> +
        <span class="variable">variable</span> + <span class="string">&quot;'.&quot;</span>);
}

<span class="keyword">function</span> <span class="variable">test</span>() {
  <span class="keyword">var</span> <span class="variabledef">variable</span> = <span class="string">&quot;locale&quot;</span>;
  <span class="variable">print</span>(<span class="string">&quot;à l’intérieur de test, la variable contient '&quot;</span> + <span class="localvariable">variable</span> + <span class="string">&quot;'.&quot;</span>);
  <span class="variable">afficherVariable</span>();
}

<span class="variable">test</span>();</pre><p>Cependant, et c’est un phénomène subtil mais extrêmement utile, lorsqu’une
fonction est définie <em>à l’intérieur</em> d’une autre fonction, son environnement
local sera basé sur l’environnement local qui l’entoure plutôt que sur
l’environnement global.</p><pre class="code"><span class="keyword">var</span> <span class="variable">variable</span> = <span class="string">&quot;globale&quot;</span>;
<span class="keyword">function</span> <span class="variable">fonctionParente</span>() {
  <span class="keyword">var</span> <span class="variabledef">variable</span> = <span class="string">&quot;locale&quot;</span>;
  <span class="keyword">function</span> <span class="variabledef">fonctionFille</span>() {
    <span class="variable">print</span>(<span class="localvariable">variable</span>);
  }
  <span class="localvariable">fonctionFille</span>();
}
<span class="variable">fonctionParente</span>();</pre><p>Au final, la visibilité des variables à l’intérieur d’une fonction est
déterminée par la place de cette fonction dans le texte du programme. Toutes
les variables définies «&nbsp;au-dessus&nbsp;» de la définition d’une fonction sont
visibles, qu’elles soient dans les corps des fonctions qui la renferment ou
globales pour tout le programme. Cette approche de la visibilité des variables
est appelée <a name="key10"></a>portée lexicale.</p></div><hr/><div class="block"><p>Les gens qui ont l’expérience d’autres langages de programmation pourraient
s’attendre à ce qu’un <a name="key11"></a>bloc de code (entre accolades) crée également un nouvel
environnement local. Pas en JavaScript. Les fonctions sont les seules qui
délimitent une nouvelle portée. Vous avez le droit d’utiliser
des blocs autonomes comme ceci…</p><pre class="code"><span class="keyword">var</span> <span class="variable">quelqueChose</span> = <span class="atom">1</span>;
{
  <span class="keyword">var</span> <span class="variable">quelqueChose</span> = <span class="atom">2</span>;
  <span class="variable">print</span>(<span class="string">&quot;À l’intérieur : &quot;</span> + <span class="variable">quelqueChose</span>);
}
<span class="variable">print</span>(<span class="string">&quot;À l’extérieur : &quot;</span> + <span class="variable">quelqueChose</span>);</pre><p>… mais le <code>quelqueChose</code> à l’intérieur du bloc fait référence à la même
variable que celui à l’extérieur du bloc. En fait, bien que les blocs comme
celui-ci soient permis, ils sont parfaitement inutiles. La plupart des gens
admettent que c’est une erreur de conception des créateurs de JavaScript, et
ECMAScript Harmony ajoutera certains moyens de définir des variables qui
restent à l’intérieur des blocs (le mot-clé <code>let</code>).</p></div><hr/><div class="block"><p>Voici un cas qui pourrait vous surprendre :</p><pre class="code"><span class="keyword">var</span> <span class="variable">variable</span> = <span class="string">&quot;globale&quot;</span>;
<span class="keyword">function</span> <span class="variable">fonctionParente</span>() {
  <span class="keyword">var</span> <span class="variabledef">variable</span> = <span class="string">&quot;locale&quot;</span>;
  <span class="keyword">function</span> <span class="variabledef">fonctionFille</span>() {
    <span class="variable">print</span>(<span class="localvariable">variable</span>);
  }
  <span class="keyword">return</span> <span class="localvariable">fonctionFille</span>;
}

<span class="keyword">var</span> <span class="variable">fille</span> = <span class="variable">fonctionParente</span>();
<span class="variable">fille</span>();</pre><p><code>fonctionParente</code> <em>renvoie</em> sa fonction interne et le code en bas de appelle
cette fonction. Même si <code>fonctionParente</code> a fini de s’exécuter à ce moment-là,
l’environnement local dans lequel <code>variable</code> a la valeur <code>locale</code> existe
toujours, et <code>fonctionFille</code> continue de l’utiliser. Ce phénomène s’appelle une
fermeture lexicale (ou <a name="key12"></a>closure en anglais).  </p></div><hr/><div class="block"><p>La portée lexicale permet non seulement de rendre très facile et rapide à
discerner dans quelle partie d’un programme une variable sera disponible, mais
aussi de «&nbsp;synthétiser&nbsp;» des fonctions. En utilisant certaines des variables
venant d’une fonction l’englobant, une fonction interne peut être amenée à
faire des choses différentes. Imaginez que nous ayons besoin de plusieurs
fonctions différentes mais similaires, l’une d’entre elles ajoutant 2 à son
argument, l’autre ajoutant 5 et ainsi de suite.  </p><pre class="code"><span class="keyword">function</span> <span class="variable">creerFonctionAjouter</span>(<span class="variabledef">quantite</span>) {
  <span class="keyword">function</span> <span class="variabledef">ajouter</span>(<span class="variabledef">nombre</span>) {
    <span class="keyword">return</span> <span class="localvariable">nombre</span> + <span class="localvariable">quantite</span>;
  }
  <span class="keyword">return</span> <span class="localvariable">ajouter</span>;
}

<span class="keyword">var</span> <span class="variable">ajouterDeux</span> = <span class="variable">creerFonctionAjouter</span>(<span class="atom">2</span>);
<span class="keyword">var</span> <span class="variable">ajouterCinq</span> = <span class="variable">creerFonctionAjouter</span>(<span class="atom">5</span>);
<span class="variable">show</span>(<span class="variable">ajouterDeux</span>(<span class="atom">1</span>) + <span class="variable">ajouterCinq</span>(<span class="atom">1</span>));</pre><p>Pour bien comprendre, vous ne devez pas considérer que les fonctions
empaquettent seulement des calculs, mais aussi un environnement. Les fonctions
globales s’exécutent simplement dans l’environnement global, c’est assez
évident. Mais une fonction définie à l’intérieur d’une autre fonction conserve
l’accès à l’environnement existant dans cette fonction à l’instant où elle a
été définie.</p><p>Par conséquent, la fonction <code>ajouter</code> de l’exemple au-dessus, qui est créée
lorsque <code>creerFonctionAjouter</code> est appelée, capture un environnement dans
lequel <code>quantite</code> a une certaine valeur. Il empaquette cet environnement avec
le calcul <code>return nombre + quantite</code> à l’intérieur d’une valeur qui est alors
retournée depuis la fonction extérieure.</p><p>Lorsque cette fonction renvoyée (<code>ajouterDeux</code> ou <code>ajouterCinq</code>) est appelée,
un nouvel environnement ―&nbsp;dans lequel la variable <code>nombre</code> a une valeur&nbsp;― est
créé comme un sous-environnement de l’environnement capturé (dans lequel
<code>quantite</code> a une valeur). Ces deux valeurs sont ajoutées, et le résultat est
renvoyé.</p></div><hr/><div class="block"><p>Au-delà du fait que différentes fonctions peuvent contenir des variables de
même nom sans qu’elles ne se mélangent, ces règles de portée permettent
également aux fonctions de s’appeler <em>elles-mêmes</em> sans que ça ne pose de
problèmes. Une fonction qui s’appelle elle-même est qualifiée de récursive. La
<a name="key13"></a>récursion permet de donner certaines définitions intéressantes. Jetez un coup
d’œil à cette implémentation de <code>puissance</code> :</p><pre class="code"><span class="keyword">function</span> <span class="variable">puissance</span>(<span class="variabledef">base</span>, <span class="variabledef">exposant</span>) {
  <span class="keyword">if</span> (<span class="localvariable">exposant</span> == <span class="atom">0</span>)
    <span class="keyword">return</span> <span class="atom">1</span>;
  <span class="keyword">else</span>
    <span class="keyword">return</span> <span class="localvariable">base</span> * <span class="variable">puissance</span>(<span class="localvariable">base</span>, <span class="localvariable">exposant</span> - <span class="atom">1</span>);
}</pre><p>C’est très proche de ce que les mathématiciens définissent comme
l’exponentiation et, à mes yeux, c’est du code bien plus propre que dans la
version initiale. C’est pour ainsi dire une boucle, mais sans <code>while</code>, <code>for</code>,
ni même un effet de bord visible en local. En s’appelant elle-même, la fonction
produit le même effet.</p><p>Il reste toutefois un problème important : dans la plupart des navigateurs,
cette deuxième version est à peu près dix fois plus lente que la première. En
JavaScript, faire tourner une boucle est bien plus économique qu’appeler une
fonction à de multiples reprises.</p></div><hr/><div class="block"><p><a name="key14"></a>Le dilemme entre vitesse et <a name="key15"></a>élégance est intéressant. Il
n’apparaît pas seulement quand on décide de faire ou non une récursion. Dans de
nombreuses situations, une solution élégante, intuitive et souvent plus courte
peut être remplacée par une solution plus sophistiquée mais plus rapide.</p><p>Dans le cas de la fonction <code>puissance</code> ci-dessus la version peu élégante est
encore suffisamment simple et facile à lire. Cela n’aurait pas d’intérêt de la
remplacer par une version récursive. Pourtant il arrive souvent que les
concepts que traite un programme deviennent si complexes qu’il s’avère tentant
de renoncer à un peu d’efficacité pour gagner en simplicité.</p><p>La règle de base, qui a été répétée par de nombreux programmeurs et que
j’approuve de toutes mes forces, c’est de ne pas s’inquiéter de l’efficacité
tant que le programme ne devient pas trop lent. Lorsque c’est le cas, trouvez
quelles parties ralentissent l’exécution et commencez à viser l’efficacité
plutôt que l’élégance.</p><p>Bien entendu, la règle ci-dessus ne signifie pas qu’on devrait démarrer en
ignorant complètement le critère de performance. Dans de nombreux cas, comme la
fonction <code>puissance</code>, on ne gagne que très peu de simplicité avec l’approche «
élégante&nbsp;». Dans d’autres cas, un programmeur expérimenté peut voir tout de
suite que la simplicité ne sera jamais assez rapide.</p><p>La raison pour laquelle j’en fais toute une histoire est que bizarrement
beaucoup de programmeurs se concentrent fanatiquement sur l’efficacité, y
compris dans les plus détails les plus insignifiants. Résultat, les programmes
sont plus longs, plus compliqués et souvent moins corrects, ils prennent plus
de temps à écrire que leur équivalent simple et ne s’exécutent plus vite que de
façon marginale.</p></div><hr/><div class="block"><p>Mais revenons à nos récursions. Un concept étroitement lié à la récursion est
une chose qu’on appelle la <a name="key16"></a>pile. Quand on appelle une fonction, on donne le
contrôle au corps de cette fonction. Quand le corps est exécuté, le code qui a
appelé la fonction reprend. Pendant que le corps est exécuté, l’ordinateur doit
se souvenir du contexte à partir duquel on a appelé la fonction pour savoir où
reprendre par la suite. L’endroit où ce contexte est stocké est appelé la pile.</p><p>Le fait qu’on l’appelle une «&nbsp;pile&nbsp;» vient du fait que, comme nous l’avons vu,
un corps de fonction peut appeler à nouveau une fonction. À chaque fois qu’une
fonction est appelée, un autre contexte doit être stocké. On peut se le
représenter comme une pile de contextes. À chaque appel de fonction, le
contexte courant est mis sur le haut de la pile. Quand une fonction se termine,
le contexte du haut de la pile en est retiré pour être restauré.</p><p>Cette pile nécessite un espace de stockage dans la mémoire de l’ordinateur.
Quand la pile prend trop d’ampleur, l’ordinateur abandonne l’exécution en cours
avec un message du genre «&nbsp;plus d’espace disponible dans la pile&nbsp;» ou «&nbsp;trop de
récursions&nbsp;». Mieux vaut s’en souvenir quand on écrit des fonctions récursives.</p><pre class="code invalid"><span class="keyword">function</span> <span class="variable">poule</span>() {
  <span class="keyword">return</span> <span class="variable">oeuf</span>();
}
<span class="keyword">function</span> <span class="variable">oeuf</span>() {
  <span class="keyword">return</span> <span class="variable">poule</span>();
}
<span class="variable">print</span>(<span class="variable">poule</span>() + <span class="string">&quot; était là en premier.&quot;</span>);</pre><p>Non seulement cet exemple nous expose une manière très intéressante d’écrire un
programme qui plante, mais il montre aussi qu’une fonction n’a pas à s’appeler
elle-même directement pour être récursive. Si elle appelle une autre fonction
qui (directement ou non) appelle à nouveau la première, elle est tout de même
récursive.</p></div><hr/><div class="block"><p>La récursion n’est pas toujours seulement une alternative moins efficace à une
boucle. Certains problèmes sont bien plus faciles à résoudre avec une récursion
qu’avec des boucles. Il s’agit le plus souvent de problèmes qui exigent
l’exploration de plusieurs «&nbsp;branches&nbsp;», chacune d’elles pouvant à son tour se
subdiviser en autres branches.</p><p>Réfléchissez à cette énigme : en partant du nombre 1 et en lui ajoutant
toujours 5 ou bien en le multipliant toujours par 3, on peut générer une
quantité infinie de nouveaux nombres. Comment écririez-vous une fonction qui,
étant donné un nombre, essaie de trouver une suite d’additions et de
multiplications qui produise ce nombre&nbsp;?</p><p>Par exemple le nombre 13 peut être obtenu en multipliant d’abord 1 par 3, puis
en ajoutant deux fois 5. En revanche, on ne peut pas obtenir le nombre 15.</p><p>Voici la solution :</p><pre class="code"><span class="keyword">function</span> <span class="variable">trouverSequence</span>(<span class="variabledef">objectif</span>) {
  <span class="keyword">function</span> <span class="variabledef">trouver</span>(<span class="variabledef">debut</span>, <span class="variabledef">historique</span>) {
    <span class="keyword">if</span> (<span class="localvariable">debut</span> == <span class="localvariable">objectif</span>)
      <span class="keyword">return</span> <span class="localvariable">historique</span>;
    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="localvariable">debut</span> &gt; <span class="localvariable">objectif</span>)
      <span class="keyword">return</span> <span class="atom">null</span>;
    <span class="keyword">else</span>
      <span class="keyword">return</span> <span class="localvariable">trouver</span>(<span class="localvariable">debut</span> + <span class="atom">5</span>, <span class="string">&quot;(&quot;</span> + <span class="localvariable">historique</span> + <span class="string">&quot; + 5)&quot;</span>) ||
             <span class="localvariable">trouver</span>(<span class="localvariable">debut</span> * <span class="atom">3</span>, <span class="string">&quot;(&quot;</span> + <span class="localvariable">historique</span> + <span class="string">&quot; * 3)&quot;</span>);
  }
  <span class="keyword">return</span> <span class="localvariable">trouver</span>(<span class="atom">1</span>, <span class="string">&quot;1&quot;</span>);
}

<span class="variable">print</span>(<span class="variable">trouverSequence</span>(<span class="atom">24</span>));</pre><p>Notez que le programme ne trouve pas forcément la plus <em>courte</em> suite
d’opérations, il estime avoir rempli sa mission dès qu’il trouve une
combinaison quelconque d’opérations.</p><p>La fonction interne <code>trouver</code>, en s’appelant elle-même de deux façons
différentes, explore à la fois la possibilité d’ajouter 5 au nombre courant et
celle de le multiplier par 3. Quand le nombre voulu est trouvé, elle renvoie la
chaîne <code>historique</code>, qui est utilisée pour enregistrer tous les opérateurs mis
en œuvre pour parvenir au résultat. Elle vérifie également si le nombre courant
est plus grand que <code>objectif</code> qui est le nombre recherché, puisque si c’est le
cas, nous devons interrompre l’exploration de cette branche car elle ne peut
nous donner le nombre que nous voulons.</p><p>L’utilisation de l’opérateur <code>||</code> dans l’exemple peut être compris comme «
renvoyer la solution trouvée en ajoutant 5 à <code>debut</code> et, si cela échoue,
renvoyer la solution trouvée en multipliant <code>debut</code> par 3&nbsp;». On peut aussi
écrire d’une façon plus verbeuse de la façon suivante :</p><pre class="preformatted">else {
  var trouve = trouver(debut + 5, &quot;(&quot; + historique + &quot; + 5)&quot;);
  if (trouve == null)
    trouve = trouver(debut * 3, historique + &quot; * 3&quot;);
  return trouve;
}</pre></div><hr/><div class="block"><p>Même si les définitions de fonctions interviennent comme des instructions au
milieu du reste du programme, elles ne font pas partie de la même chronologie.</p><pre class="code"><span class="variable">print</span>(<span class="string">&quot;Le futur dit : &quot;</span>, <span class="variable">futur</span>());

<span class="keyword">function</span> <span class="variable">futur</span>() {
  <span class="keyword">return</span> <span class="string">&quot;Nous n’avons TOUJOURS pas de voitures volantes.&quot;</span>;
}</pre><p>Ce qui se passe c’est que l’ordinateur examine toutes les définitions de
fonctions et les stocke dans les fonctions associées, <em>avant</em> de commencer à
exécuter le reste du programme. Il en va de même avec les fonctions qui sont
définies à l’intérieur d’autres fonctions. Quand la fonction externe est
appelée, la première chose qui se passe est que toutes les fonctions internes
sont ajoutées au nouvel environnement.</p></div><hr/><div class="block"><p>Il existe une autre façon de définir des valeurs de type fonction, ressemblant
davantage à la façon dont les autres valeurs sont créées. Quand le mot-clé
<code>function</code> est utilisé dans un endroit où une expression est attendue, il est
considéré comme une expression qui produit une valeur de type fonction. Les
fonctions créées de cette façon n’ont même pas besoin d’être nommées (bien
qu’il soit autorisé de le faire).</p><pre class="code"><span class="keyword">var</span> <span class="variable">ajouter</span> = <span class="keyword">function</span>(<span class="variabledef">a</span>, <span class="variabledef">b</span>) {
  <span class="keyword">return</span> <span class="localvariable">a</span> + <span class="localvariable">b</span>;
};
<span class="variable">show</span>(<span class="variable">ajouter</span>(<span class="atom">5</span>, <span class="atom">5</span>));</pre><p>Notez le point-virgule après la définition de <code>ajouter</code>. Les définitions
normales de fonctions n’en ont pas besoin, mais cette instruction a la
structure générale de <code>var ajouter = 22;</code> et donc nécessite un
point-virgule.</p><p>Ce type de valeur est appelé <a name="key17"></a>fonction anonyme, parce que la fonction définie
n’a alors pas de nom. Parfois il est inutile de donner un nom aux fonctions,
comme dans l’exemple précédent de <code>creerFonctionAjouter</code> :</p><pre class="code"><span class="keyword">function</span> <span class="variable">creerFonctionAjouter</span>(<span class="variabledef">quantite</span>) {
  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="variabledef">nombre</span>) {
    <span class="keyword">return</span> <span class="localvariable">nombre</span> + <span class="localvariable">quantite</span>;
  };
}</pre><p>Puisque dans la première version de <code>creerFonctionAjouter</code>, la fonction
<code>ajouter</code> n’a servi qu’une fois, le nom n’est pas nécessaire et nous pouvons
directement retourner la valeur de la fonction.</p></div><hr/><div class="block"><a name="exercise2"></a><div class="exercisenum">Ex. 3.2</div><div class="exercise"><p>Écrivez une fonction <code>plusGrandQue</code>, qui prend un nombre en argument et
retourne une fonction qui représente un test. Quand cette nouvelle fonction est
appelée avec un simple nombre comme argument, elle retourne un booléen : <code>true</code>
si le nombre donné est plus grand que le nombre utilisé pour créer la fonction,
et <code>false</code> sinon.</p></div><div class="solution"><pre class="code"><span class="keyword">function</span> <span class="variable">plusGrandQue</span>(<span class="variabledef">x</span>) {
  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="variabledef">y</span>) {
    <span class="keyword">return</span> <span class="localvariable">y</span> &gt; <span class="localvariable">x</span>;
  };
}

<span class="keyword">var</span> <span class="variable">plusGrandQueDix</span> = <span class="variable">plusGrandQue</span>(<span class="atom">10</span>);
<span class="variable">show</span>(<span class="variable">plusGrandQueDix</span>(<span class="atom">9</span>));</pre></div></div><hr/><div class="block"><p>Essayez cela :</p><pre class="code"><span class="variable">alert</span>(<span class="string">&quot;Salut&quot;</span>, <span class="string">&quot;Bonsoir&quot;</span>, <span class="string">&quot;Comment allez-vous&nbsp;?&quot;</span>, <span class="string">&quot;Au revoir&quot;</span>);</pre><p>La fonction <code>alert</code> n’accepte officiellement qu’un argument. Cependant, quand
vous l’appelez ainsi, l’ordinateur ne se plaint pas, il ignore juste les autres
arguments.</p><pre class="code"><span class="variable">show</span>();</pre><p>Vous pouvez même, apparemment, vous passer d’arguments. Quand un argument n’est
pas transmis, sa valeur dans la fonction est <code>undefined</code>.</p><p>Dans le chapitre suivant, nous verrons un moyen pour que le corps de la
fonction connaisse la liste exacte des arguments qui lui sont donnés. Cela peut
être utile, par exemple, pour réaliser une fonction qui accepte n’importe quel
nombre d’arguments : <code>print</code> se comporte ainsi.</p><pre class="code"><span class="variable">print</span>(<span class="string">&quot;R&quot;</span>, <span class="atom">2</span>, <span class="string">&quot;D&quot;</span>, <span class="atom">2</span>);</pre><p>Bien sûr, un inconvénient est qu’il est aussi possible de donner un nombre
incorrect d’arguments aux fonctions qui doivent en recevoir un nombre fixe,
comme <code>alert</code>, et de ne pas en être prévenu.</p></div><ol class="footnotes"><li><a name="footnote1"></a>Techniquement, cela ne devrait pas être nécessaire, mais je suppose que les
concepteurs de JavaScript se sont dits que cela clarifierait les choses si le
corps des fonctions était toujours entouré d’accolades.</li><li><a name="footnote2"></a>Techniquement, une fonction pure ne peut utiliser la valeur d’aucune
variable externe. Ces valeurs pourraient changer et cela pourrait faire
renvoyer une valeur différente pour les mêmes arguments. En pratique, le
programmeur peut considérer certaines variables comme «&nbsp;constantes&nbsp;» ―&nbsp;elles
ne sont pas censées changer&nbsp;― et considérer les fonctions qui utilisent
uniquement des variables constantes comme des fonctions pures. Les variables
qui contiennent une fonction sont souvent de bons exemples de variables
constantes.</li></ol><h1><span class="number">Chapitre 4: </span>Structures de données : objets et tableaux</h1><div class="block"><p>Ce chapitre sera consacré à la résolution de quelques problèmes simples. En
chemin, nous allons étudier deux nouveaux types de valeurs, les tableaux et les
objets, et quelques techniques les concernant.</p><p>Considérons la situation suivante : votre tante Émilie l’excentrique, dont la
rumeur dit qu’elle vit avec cinquante chats (en fait personne n’arrive à les
compter), vous envoie régulièrement des courriels pour vous tenir au courant de
ses exploits. Ils sont de la forme suivante :</p><blockquote>Mon cher neveu,
Ta mère m’a dit que tu t’es mis au parachutisme. Est-ce que c’est vrai&nbsp;? Fais
bien attention à toi, jeune homme&nbsp;! Tu te souviens de ce qui est arrivé à mon
mari&nbsp;? Et c’était seulement du deuxième étage&nbsp;!<br/><br/>Quoi qu’il en soit, les choses sont très intéressantes de mon côté. J’ai
passé toute la semaine à essayer d’attirer l’attention de M. Drake, le gentil
monsieur qui a emménagé juste à côté, mais je pense qu’il a peur des chats. À
moins qu’il n’y soit allergique&nbsp;? Je vais essayer de poser Gros Igor sur son
épaule la prochaine fois qu’il vient. Je suis curieuse de voir le résultat.<br/><br/>Par ailleurs, l’arnaque dont je t’ai parlé fonctionne mieux que prévu. J’ai
déjà récupéré cinq «&nbsp;paiements&nbsp;» et seulement une seule réclamation. Je
commence malgré tout à avoir quelques remords. Et puis tu as sans doute
raison, ça doit être illégal d’une manière ou d’une autre.<br/><br/>(etc.)<br/><br/>Grosses bises,
Tante Émilie<br/><br/>Décédé le 27/04/2006 : Black Leclère<br/><br/>Est né le 05/04/2006 (mère, Lady Pénélope) : Lion Rouge, Docteur Hobbles III,
Petit Iroquois</blockquote><p>Pour amuser cette vieille dame, vous voudriez garder une trace de la généalogie
de ses chats, pour pouvoir ajouter des commentaires comme «&nbsp;P.-S. J’espère que
Docteur Hobbles II a bien fêté son anniversaire samedi&nbsp;!&nbsp;», ou bien «&nbsp;Comment
va cette vieille Lady Pénélope&nbsp;? Elle a cinq ans maintenant, n’est-ce pas&nbsp;?&nbsp;»,
en évitant de préférence de demander des nouvelles des chats décédés. Vous avez
une grande quantité de vieux courriels de votre tante et, par chance, elle est
très constante dans sa manière de donner les renseignements sur les naissances
et décès des chats à la fin de ses courriels, toujours dans le même format.</p><p>Vous n’avez pas envie de parcourir à la main tous ces messages. Heureusement,
nous avions justement besoin d’un exemple, nous allons donc écrire un programme
qui va faire le travail pour nous. Pour commencer, nous allons écrire un
programme qui va nous donner la liste des chats qui sont toujours vivants à la
fin du dernier courriel.</p><p>Avant que vous ne posiez la question, au début de cette correspondance, la
tante Émilie n’avait qu’un seul chat : Spot (elle était encore assez
conformiste à cette époque).</p></div><hr/><div class="block"><div class="picture"><img src="img/eyes.png"/></div></div><hr/><div class="block"><p>Il est généralement préférable d’avoir une idée de départ sur ce que va faire
un programme avant de se mettre à l’écrire… Voici le plan :</p><ol><li>Commencer par un ensemble de noms de chats ne comprenant que «&nbsp;Spot&nbsp;».</li><li>Parcourir chaque courriel dans l’archive dans l’ordre chronologique.</li><li>Chercher les paragraphes qui commencent par «&nbsp;Est né le&nbsp;» ou «&nbsp;Décédé le&nbsp;».</li><li>Ajouter les noms trouvés dans les paragraphes qui commencent par «&nbsp;Est né le&nbsp;» à l’ensemble de noms.</li><li>Supprimer les noms de chats trouvés dans les paragraphes qui commencent par «&nbsp;Décédé le&nbsp;» de notre ensemble.</li></ol><p>On extraira les noms d’un paragraphe de la façon suivante :</p><ol><li>Trouver les deux-points (:) dans le paragraphe.</li><li>Prendre la partie après ce signe.</li><li>Dans cette partie, séparer les noms en cherchant les virgules.</li></ol><p>Cet énoncé d’exercice peut rendre nécessaire d’oublier quelques instants les
exceptions possibles et d’accepter aveuglément que tante Émilie utilise
toujours le même format d’écriture, qu’elle n’oublie jamais un nom de chat, ni
ne fait de faute de frappe. Mais votre tante est comme ça et ça tombe bien pour
nous.</p></div><hr/><div class="block"><p>D’abord, je vais vous expliquer les <a name="key1"></a>propriétés. Beaucoup de valeurs en
JavaScript ont d’autres valeurs qui leur sont associées. Ces associations sont
appelées propriétés. Chaque chaîne de caractères a une propriété appelée
<a name="key2"></a><code>length</code>, (longueur), qui correspond à un nombre, la quantité de caractères
dans cette chaîne.</p><p>On peut accéder aux <a name="key3"></a>propriétés de deux manières :</p><pre class="code"><span class="keyword">var</span> <span class="variable">texte</span> = <span class="string">&quot;brume pourpre&quot;</span>;
<span class="variable">show</span>(<span class="variable">texte</span>[<span class="string">&quot;length&quot;</span>]);
<span class="variable">show</span>(<span class="variable">texte</span>.<span class="property">length</span>);</pre><p>La deuxième manière est un raccourci de la première et ne fonctionne que
lorsque le nom de la propriété s’écrit comme un nom de variable ―&nbsp;lorsqu’il
n’y a pas d’espace ou de symbole et lorsqu’elle ne commence pas par un chiffre.</p><p>Les valeurs <code>null</code> et <code>undefined</code> n’ont pas de propriété. Essayez de lire des
propriétés de ces valeurs donnera une erreur. Essayez le code suivant, juste
pour voir le type de message d’erreur que votre navigateur va retourner dans ce
cas de figure (dans certains navigateurs, ce message sera assez mystérieux).</p><pre class="code invalid"><span class="keyword">var</span> <span class="variable">rienDuTout</span> = <span class="atom">null</span>;
<span class="variable">show</span>(<span class="variable">rienDuTout</span>.<span class="property">length</span>);</pre></div><hr/><div class="block"><p>Les propriétés d’une chaîne de caractères ne peuvent pas être changées. Elles
sont plus nombreuses que la seule longueur <code>length</code>, comme nous allons le voir,
mais vous ne pouvez ajouter ni supprimer aucune propriété.</p><p>C’est différent avec les valeurs du type <a name="key4"></a>object. Leur rôle principal
est de conserver d’autres valeurs. Ils ont, en quelque sorte, leur propre jeu
de «&nbsp;tentacules&nbsp;» sous forme de propriétés. Vous pouvez les modifier, les
supprimer ou en ajouter de nouvelles.</p><p><a name="key5"></a>Un objet peut s’écrire de la façon suivante :</p><pre class="code"><span class="keyword">var</span> <span class="variable">chat</span> = {<span class="property">couleur</span>: <span class="string">&quot;gris&quot;</span>, <span class="property">nom</span>: <span class="string">&quot;Spot&quot;</span>, <span class="property">taille</span>: <span class="atom">46</span>};
<span class="variable">chat</span>.<span class="property">taille</span> = <span class="atom">47</span>;
<span class="variable">show</span>(<span class="variable">chat</span>.<span class="property">taille</span>);
<span class="keyword">delete</span> <span class="variable">chat</span>.<span class="property">taille</span>;
<span class="variable">show</span>(<span class="variable">chat</span>.<span class="property">taille</span>);
<span class="variable">show</span>(<span class="variable">chat</span>);</pre><p>Comme les variables, chaque propriété attachée à un objet a un nom sous forme
d’une chaîne de caractères. La première instruction crée un objet dans lequel
la propriété <code>&quot;couleur&quot;</code> contient la chaîne <code>&quot;gris&quot;</code>, la propriété <code>&quot;nom&quot;</code> est
liée à la chaîne <code>&quot;Spot&quot;</code>, et la propriété <code>&quot;taille&quot;</code> fait référence au nombre
<code>46</code>. La deuxième ligne modifie la propriété <code>taille</code> en lui donnant une
nouvelle valeur, ce qui se fait de la même manière que pour la modification
d’une variable.  </p><p>Le mot-clé <a name="key6"></a><code>delete</code> supprime les propriétés. Essayer de lire une propriété
qui n’existe pas donnera la valeur <code>undefined</code>.</p><p>Si une propriété qui n’existe pas encore est affectée avec l’opérateur <a name="key7"></a><code>=</code>,
elle est ajoutée à l’objet.</p><pre class="code"><span class="keyword">var</span> <span class="variable">vide</span> = {};
<span class="variable">vide</span>.<span class="property">plusVraiment</span> = <span class="atom">1000</span>;
<span class="variable">show</span>(<span class="variable">vide</span>.<span class="property">plusVraiment</span>);</pre><p>Les propriétés dont le nom ne pourrait pas être une variable doivent être mises
entre guillemets au moment de la création de l’objet et utilisées avec des
crochets :</p><pre class="code"><span class="keyword">var</span> <span class="variable">truc</span> = {<span class="string">&quot;gabba gabba&quot;</span>: <span class="string">&quot;hey&quot;</span>, <span class="string">&quot;5&quot;</span>: <span class="atom">10</span>};
<span class="variable">show</span>(<span class="variable">truc</span>[<span class="string">&quot;5&quot;</span>]);
<span class="variable">truc</span>[<span class="string">&quot;5&quot;</span>] = <span class="atom">20</span>;
<span class="variable">show</span>(<span class="variable">truc</span>[<span class="atom">2</span> + <span class="atom">3</span>]);
<span class="keyword">delete</span> <span class="variable">truc</span>[<span class="string">&quot;gabba gabba&quot;</span>];</pre><p>Comme vous pouvez le voir, on peut mettre n’importe quelle expression entre les
crochets. Elle sera convertie en une chaîne pour définir le nom de la
propriété. On peut aussi utiliser des variables pour donner un nom à une
propriété :</p><pre class="code"><span class="keyword">var</span> <span class="variable">nomDePropriete</span> = <span class="string">&quot;length&quot;</span>;
<span class="keyword">var</span> <span class="variable">texte</span> = <span class="string">&quot;grandeLigne&quot;</span>;
<span class="variable">show</span>(<span class="variable">texte</span>[<span class="variable">nomDePropriete</span>]);</pre><p>L’opérateur <a name="key8"></a><code>in</code> peut servir à tester si un objet possède une certaine
propriété. Son résultat est un booléen.</p><pre class="code"><span class="keyword">var</span> <span class="variable">poupeeRusse</span> = {};
<span class="variable">poupeeRusse</span>.<span class="property">contenu</span> = <span class="variable">poupeeRusse</span>;
<span class="variable">show</span>(<span class="string">&quot;contenu&quot;</span> in <span class="variable">poupeeRusse</span>);
<span class="variable">show</span>(<span class="string">&quot;contenu&quot;</span> in <span class="variable">poupeeRusse</span>.<span class="property">contenu</span>);</pre></div><hr/><div class="block"><p>Quand les valeurs d’un objet sont affichées sur la console, on peut cliquer à
la souris pour inspecter leurs propriétés. La fenêtre de sortie devient une
fenêtre «&nbsp;inspecteur&nbsp;». Le petit «&nbsp;x&nbsp;» en haut à droite s’utilise pour
retourner à la fenêtre de sortie et la flèche gauche permet de retourner aux
propriétés de l’objet inspecté.  </p><pre class="code"><span class="variable">show</span>(<span class="variable">poupeeRusse</span>);</pre></div><hr/><div class="block"><a name="exercise1"></a><div class="exercisenum">Ex. 4.1</div><div class="exercise"><p>La solution pour le problème des chats passe par un ensemble de noms. Un
ensemble (ou «&nbsp;<a name="key9"></a>set&nbsp;») est un groupe de valeurs dans lequel aucune valeur ne
peut apparaître plus d’une fois. Si les noms de chats sont des chaînes de
caractères, pouvez-vous imaginer une façon pour qu’un objet devienne un
ensemble de noms&nbsp;?</p><p>Écrivez maintenant la façon dont un nom peut être ajouté à cet ensemble,
comment on peut le supprimer et comment on peut vérifier si un certain nom est
bien présent dans l’ensemble.  </p></div><div class="solution"><p>Une solution consiste à mémoriser le contenu de l’ensemble sous la forme de
propriétés d’un objet. Pour ajouter un nom, on crée une propriété avec ce nom
en lui affectant une valeur, n’importe laquelle. Pour supprimer un nom, on
supprimera la propriété de l’objet. L’opérateur <code>in</code> sera utilisé pour savoir
si une certaine propriété fait partie de l’ensemble<a class="footref" href="#footnote1">1</a>.</p><pre class="code"><span class="keyword">var</span> <span class="variable">set</span> = {<span class="string">&quot;Spot&quot;</span>: <span class="atom">true</span>};
<span class="comment">// Ajoute &quot;Croc Blanc&quot; à l’ensemble</span>
<span class="variable">set</span>[<span class="string">&quot;Croc Blanc&quot;</span>] = <span class="atom">true</span>;
<span class="comment">// Supprime &quot;Spot&quot;</span>
<span class="keyword">delete</span> <span class="variable">set</span>[<span class="string">&quot;Spot&quot;</span>];
<span class="comment">// Regarde si &quot;Asoka&quot; est dans l’ensemble</span>
<span class="variable">show</span>(<span class="string">&quot;Asoka&quot;</span> in <span class="variable">set</span>);</pre></div></div><hr/><div class="block"><p>Les valeurs des <a name="key10"></a>objets peuvent apparemment changer. Les types de
valeurs vues dans le <a href="chapter2.html">chapitre 2</a> sont toutes invariables, il n’est pas possible
de changer une valeur existante pour ces types de données. Vous pouvez les
associer ou en tirer de nouvelles valeurs, mais lorsque vous prenez une chaîne
de caractères particulière, le texte à l’intérieur ne peut pas être modifié.
Avec les objets, d’un autre côté, le contenu d’une valeur peut être modifié en
changeant ses propriétés.</p><p>Lorsque nous considérons deux nombres, <code>120</code> et <code>120</code>, il est possible dans
tous les cas pratiques de les considérer comme des nombres identiques. Avec des
objets, il y a une différence importante entre avoir deux «&nbsp;références&nbsp;» du
même objet et avoir deux objets distincts qui possèdent les mêmes propriétés.
Considérons le code suivant :</p><pre class="code"><span class="keyword">var</span> <span class="variable">objet1</span> = {<span class="property">valeur</span>: <span class="atom">10</span>};
<span class="keyword">var</span> <span class="variable">objet2</span> = <span class="variable">objet1</span>;
<span class="keyword">var</span> <span class="variable">objet3</span> = {<span class="property">valeur</span>: <span class="atom">10</span>};

<span class="variable">show</span>(<span class="variable">objet1</span> == <span class="variable">objet2</span>);
<span class="variable">show</span>(<span class="variable">objet1</span> == <span class="variable">objet3</span>);

<span class="variable">objet1</span>.<span class="property">valeur</span> = <span class="atom">15</span>;
<span class="variable">show</span>(<span class="variable">objet2</span>.<span class="property">valeur</span>);
<span class="variable">show</span>(<span class="variable">objet3</span>.<span class="property">valeur</span>);</pre><p><code>objet1</code> et <code>objet2</code> sont deux variables attachées à la <em>même</em> valeur. Il n’y a
en fait qu’un seul objet, c’est pourquoi en changeant <code>objet1</code> on change
également la valeur de <code>objet2</code>. La variable <code>objet3</code> pointe vers un autre
objet qui contient au départ la même propriété que <code>objet1</code> mais elle a une
existence distincte.</p><p>L’opérateur JavaScript <a name="key11"></a><code>==</code>, lorsqu’il compare des objets, ne retournera la
valeur booléenne <code>true</code> que si chacune des valeurs qu’on lui donne à comparer
sont exactement les mêmes. Comparer des objets différents ayant des contenus
identiques donnera le résultat <code>false</code>. C’est utile dans certaines situations,
mais peu adapté à d’autres.</p></div><hr/><div class="block"><p>Les valeurs d’un objet peuvent jouer de nombreux rôles. Se comporter comme un
ensemble n’est que l’un d’entre eux. Nous allons voir d’autres utilisations
dans ce chapitre et le <a href="chapter8.html">chapitre 8</a> montrera d’autres façons importantes d’utiliser
les objets.</p><p>Dans le plan d’action pour le problème des chats ―&nbsp;en fait, appelons-le un
<em>algorithme</em> au lieu d’un plan, cela nous donne l’impression qu’on sait de quoi
on parle&nbsp;― dans l’algorithme, on parle de parcourir chaque courriel contenu
dans une archive. Mais comment se présente cette archive&nbsp;? Et d’où vient-elle&nbsp;?</p><p>Ne vous inquiétez pas de la deuxième question pour le moment. Le <a href="chapter14.html">chapitre 14</a>
explique quelques-unes des possibilités pour importer des données dans vos
programmes. Pour l’instant, on dira que les courriels sont déjà là, comme par
magie. La magie est parfois très facile, avec les ordinateurs.</p></div><hr/><div class="block"><p>La façon dont l’archive est enregistrée reste une question pertinente. Elle
contient quantité de courriels. Un courriel peut être vu comme une chaîne de
caractères, c’est évident. Toute l’archive pourrait être mise dans une énorme
chaîne de caractères mais ce ne serait pas pratique. Ce qu’il nous faut, c’est
une structure de chaînes de caractères distinctes.</p><p>Les objets sont justement utilisés pour structurer des choses. On pourrait très
bien créer un objet comme celui-ci :</p><pre class="code"><span class="keyword">var</span> <span class="variable">archiveDeMessages</span> = {<span class="string">&quot;le premier courriel&quot;</span>: <span class="string">&quot;Mon cher neveu, …&quot;</span>,
                   <span class="string">&quot;le deuxième courriel&quot;</span>: <span class="string">&quot;…&quot;</span>
                   <span class="comment">/* et ainsi de suite… */</span>};</pre><p>Mais parcourir les courriels du début à la fin serait difficile ―&nbsp;comment le
programme peut-il deviner le nom de ces propriétés&nbsp;? La solution est d’utiliser
des noms de propriétés plus prévisibles :</p><pre class="code"><span class="keyword">var</span> <span class="variable">archiveDeMessages</span> = {<span class="atom">0</span>: <span class="string">&quot;Mon cher neveu, … (courriel numéro 1)&quot;</span>,
                   <span class="atom">1</span>: <span class="string">&quot;(courriel numéro 2)&quot;</span>,
                   <span class="atom">2</span>: <span class="string">&quot;(courriel numéro 3)&quot;</span>};

<span class="keyword">for</span> (<span class="keyword">var</span> <span class="variable">courant</span> = <span class="atom">0</span>; <span class="variable">courant</span> in <span class="variable">archiveDeMessages</span>; <span class="variable">courant</span>++)
  <span class="variable">print</span>(<span class="string">&quot;Traitement du courriel #&quot;</span>, <span class="variable">courant</span>, <span class="string">&quot;: &quot;</span>, <span class="variable">archiveDeMessages</span>[<span class="variable">courant</span>]);</pre><p>La chance veut qu’il existe un type d’objet particulier qui corresponde
exactement à ce type de besoin. Ce sont les <a name="key12"></a>tableaux et ils fournissent des
commodités très utiles, comme <a name="key13"></a><code>length</code> (longueur), une propriété qui contient
le nombre d’éléments dans le tableau et bien d’autres fonctions utiles pour ce
type de structure.</p><p><a name="key14"></a>Pour créer de nouveaux tableaux on utilise des crochets (<code>[</code> et <code>]</code>):</p><pre class="code"><span class="keyword">var</span> <span class="variable">archiveDeMessages</span> = [<span class="string">&quot;courriel un&quot;</span>, <span class="string">&quot;courriel deux&quot;</span>, <span class="string">&quot;courriel trois&quot;</span>];

<span class="keyword">for</span> (<span class="keyword">var</span> <span class="variable">courant</span> = <span class="atom">0</span>; <span class="variable">courant</span> &lt; <span class="variable">archiveDeMessages</span>.<span class="property">length</span>; <span class="variable">courant</span>++)
  <span class="variable">print</span>(<span class="string">&quot;Traitement du courriel #&quot;</span>, <span class="variable">courant</span>, <span class="string">&quot;: &quot;</span>, <span class="variable">archiveDeMessages</span>[<span class="variable">courant</span>]);</pre><p>Dans cet exemple, le nombre d’éléments n’est plus spécifié explicitement. Le
premier a automatiquement le numéro 0, le deuxième le numéro 1 et ainsi de
suite.</p><p>Pourquoi commencer à 0&nbsp;? Dans la vie courante on compte d’habitude à partir de
1. Aussi étrange que cela paraisse, la numérotation à partir de 0 est souvent
plus pratique pour programmer. Faites avec pour l’instant, vous allez vous y
faire.</p><p>Commencer par l’élément 0 veut aussi dire que dans une structure qui a <code>X</code>
éléments, le dernier élément sera trouvé à la position <code>X - 1</code>. C’est pourquoi
la boucle <code>for</code> dans notre exemple teste la valeur <code>courant &lt;
archiveDeMessages.length</code>. Il n’y a pas d’élément à la position
<code>archiveDeMessages.length</code>, donc dès que <code>courant</code> atteint cette valeur, on
arrête la boucle.</p></div><hr/><div class="block"><a name="exercise2"></a><div class="exercisenum">Ex. 4.2</div><div class="exercise"><p>Écrivez une fonction nommée <code>serie</code> qui prend un argument, un nombre positif et
retourne un tableau contenant chaque nombre de 0 jusqu’au nombre donné en
paramètre inclus.</p><p>Un tableau vide peut être créé en tapant simplement <code>[]</code>. Souvenez-vous que
pour ajouter une propriété à un tableau ou à un objet, il suffit d’affecter une
valeur à cette propriété avec l’opérateur <code>=</code>. La propriété <code>length</code> est mise à
jour automatiquement quand des éléments sont ajoutés.</p></div><div class="solution"><pre class="code"><span class="keyword">function</span> <span class="variable">serie</span>(<span class="variabledef">max</span>) {
  <span class="keyword">var</span> <span class="variabledef">resultat</span> = [];
  <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">i</span> = <span class="atom">0</span>; <span class="localvariable">i</span> &lt;= <span class="localvariable">max</span>; <span class="localvariable">i</span>++)
    <span class="localvariable">resultat</span>[<span class="localvariable">i</span>] = <span class="localvariable">i</span>;
  <span class="keyword">return</span> <span class="localvariable">resultat</span>;
}
<span class="variable">show</span>(<span class="variable">serie</span>(<span class="atom">4</span>));</pre><p>Au lieu de nommer la variable de boucle <code>compteur</code> ou <code>courant</code>, comme je l’ai
fait jusqu’à présent, elle s’appelle désormais simplement <code>i</code>. L’utilisation
d’une seule lettre, habituellement <code>i</code>, <code>j</code> ou <code>k</code> pour les variables de boucle
est une habitude très répandue en programmation. Son origine tient presque à de
la paresse : on préfère taper un caractère que sept et des noms comme
<code>compteur</code> et <code>courant</code> ne donnent pas forcément plus d’informations sur la
variable.</p><p>Si un programme utilise trop souvent des variables à un seul caractère, sans
explication, il peut devenir très difficile à comprendre. Dans mes propres
programmes, j’essaie de me limiter à quelques cas de figures seulement. Les
petites boucles font partie de ces cas. Si la boucle contient une autre boucle
et que celle-ci utilise aussi une variable appelée <code>i</code>, la boucle intérieure va
modifier la variable dont se sert la première boucle, et rien ne va
fonctionner. Ou pourrait utiliser <code>j</code> pour la boucle intérieure, mais en
général, lorsque le corps d’une boucle est grand, vous devriez utiliser un nom
de variable ayant une signification utile pour la compréhension.</p></div></div><hr/><div class="block"><p>Les objets chaînes de caractères et tableaux contiennent tous deux, outre la
propriété <code>length</code>, un certain nombre d’autres propriétés qui font référence à
des fonctions.</p><pre class="code"><span class="keyword">var</span> <span class="variable">doh</span> = <span class="string">&quot;Doh&quot;</span>;
<span class="variable">print</span>(typeof <span class="variable">doh</span>.<span class="property">toUpperCase</span>);
<span class="variable">print</span>(<span class="variable">doh</span>.<span class="property">toUpperCase</span>());</pre><p>Chaque chaîne de caractères a une propriété <a name="key15"></a><code>toUpperCase</code>. Lorsqu’elle est
appelée, elle retourne une copie de la chaîne, transformée avec chaque lettre
en majuscule. Il y a aussi l’équivalent <a name="key16"></a><code>toLowerCase</code>. Devinez le résultat…</p><p>Remarquez que même si l’appel de <code>toUpperCase</code> se fait sans arguments, la
fonction a malgré tout accès au contenu de la chaîne de caractères <code>&quot;Doh&quot;</code>, la
valeur dont elle est une propriété. La façon dont cela fonctionne est décrite
dans le <a href="chapter8.html">chapitre 8</a>.</p><p>Les propriétés qui se comportent comme des fonctions sont généralement appelées
<a name="key17"></a>méthodes, ainsi, <code>toUpperCase</code> est une méthode des objets chaînes de
caractères.</p><pre class="code"><span class="keyword">var</span> <span class="variable">flipper</span> = [];
<span class="variable">flipper</span>.<span class="property">push</span>(<span class="string">&quot;Flipper&quot;</span>);
<span class="variable">flipper</span>.<span class="property">push</span>(<span class="string">&quot;le&quot;</span>);
<span class="variable">flipper</span>.<span class="property">push</span>(<span class="string">&quot;dauphin&quot;</span>);
<span class="variable">show</span>(<span class="variable">flipper</span>.<span class="property">join</span>(<span class="string">&quot; &quot;</span>));
<span class="variable">show</span>(<span class="variable">flipper</span>.<span class="property">pop</span>());
<span class="variable">show</span>(<span class="variable">flipper</span>);</pre><p>La méthode <a name="key18"></a><code>push</code>, associée aux tableaux, peut être utilisée pour ajouter des
valeurs à ceux-ci. Nous aurions pu l’utiliser dans l’exercice précédent, à la
place de <code>resultat[i] = i</code>. Il y a aussi la méthode <a name="key19"></a><code>pop</code>, complémentaire de
<code>push</code> : elle supprime le dernier élément d’un tableau et retourne sa valeur.
<a name="key20"></a><code>join</code> construit une seule chaîne de caractères à partir d’un tableau de
chaînes de caractères. Le paramètre utilisé avec cette méthode sera inséré
entre chaque valeur du tableau, avant l’assemblage de la chaîne de caractères
finale.</p></div><hr/><div class="block"><p>Revenons à nos chats : nous savons maintenant qu’utiliser un tableau serait une
bonne idée pour ranger les archives des courriels. Sur cette page, la fonction
<code>recupererLesMessages</code> sera utilisée pour récupérer (magiquement) ce tableau.
Parcourir les courriels qu’il contient pour les traiter un par un devient
simple comme un jeu d’enfant :</p><pre class="code"><span class="keyword">var</span> <span class="variable">archiveDeMessages</span> = <span class="variable">recupererLesMessages</span>();

<span class="keyword">for</span> (<span class="keyword">var</span> <span class="variable">i</span> = <span class="atom">0</span>; <span class="variable">i</span> &lt; <span class="variable">archiveDeMessages</span>.<span class="property">length</span>; <span class="variable">i</span>++) {
  <span class="keyword">var</span> <span class="variable">message</span> = <span class="variable">archiveDeMessages</span>[<span class="variable">i</span>];
  <span class="variable">print</span>(<span class="string">&quot;Traitement du courriel #&quot;</span>, <span class="variable">i</span>);
  <span class="comment">// Faire plus de choses…</span>
}</pre><p>Nous avons également décidé d’une manière de représenter un ensemble de chats
vivants. Le problème qui reste à traiter, cependant, est celui de détecter des
paragraphes d’un courriel qui contiennent <code>&quot;Est né le&quot;</code> ou <code>&quot;Décédé le&quot;</code>.</p></div><hr/><div class="block"><p>La première question qui vient à l’esprit est de savoir ce qu’est un paragraphe
au juste. Dans ce cas, la valeur de la chaîne elle-même n’est pas d’une grande
utilité : le concept du texte en JavaScript ne va guère plus loin que l’idée de
«&nbsp;suite de caractères&nbsp;», si bien que nous devons définir les paragraphes de
cette façon.</p><p>Nous avons vu plus haut qu’il existe une chose qui s’appelle un caractère de
fin de ligne. C’est ce que la plupart des gens utilisent pour séparer les
paragraphes. Nous considérons donc un paragraphe comme une partie du courriel
qui commence par un caractère saut de ligne ou au début du contenu du message
et se termine au caractère saut de ligne suivant ou bien à la fin du contenu.</p><p>Et nous n’avons même pas à écrire nous-mêmes l’algorithme pour scinder une
chaîne en paragraphes. Les chaînes ont déjà une méthode appelée <a name="key21"></a><code>split</code>, qui
est (pratiquement) l’inverse de la méthode <code>join</code> pour les tableaux. Elle
découpe une chaîne en un tableau en utilisant la chaîne fournie comme argument
pour déterminer à quel endroit opérer les divisions en paragraphes.</p><pre class="code"><span class="keyword">var</span> <span class="variable">mots</span> = <span class="string">&quot;Les villes de l’arrière-pays&quot;</span>;
<span class="variable">show</span>(<span class="variable">mots</span>.<span class="property">split</span>(<span class="string">&quot; &quot;</span>));</pre><p>Ainsi, découper avec des caractères saut de ligne (<code>&quot;\n&quot;</code>) est une méthode
utilisable pour diviser un courriel en paragraphes.</p></div><hr/><div class="block"><a name="exercise3"></a><div class="exercisenum">Ex. 4.3</div><div class="exercise"><p><code>split</code> et <code>join</code> ne sont pas exactement l’inverse l’une de l’autre.
<code>string.split(x).join(x)</code> produit toujours la valeur originale, mais pas
<code>array.join(x).split(x)</code>. Pouvez-vous donner un exemple de tableau dans lequel
<code>.join(&quot; &quot;).split(&quot; &quot;)</code> produit une valeur différente&nbsp;?</p></div><div class="solution"><pre class="code"><span class="keyword">var</span> <span class="variable">tableau</span> = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c d&quot;</span>];
<span class="variable">show</span>(<span class="variable">tableau</span>.<span class="property">join</span>(<span class="string">&quot; &quot;</span>).<span class="property">split</span>(<span class="string">&quot; &quot;</span>));</pre></div></div><hr/><div class="block"><p>Les paragraphes qui ne commencent ni par «&nbsp;Né&nbsp;le&nbsp;» ni par «&nbsp;Décédé le&nbsp;» peuvent
être ignorés par le programme. Comment peut-on tester si une chaîne commence
par un mot particulier&nbsp;? On peut utiliser la méthode <a name="key22"></a><code>charAt</code> pour obtenir un
caractère particulier dans une chaîne.  <code>x.charAt(0)</code> donne le premier
caractère, <code>1</code> est le deuxième et ainsi de suite. Voici une façon de vérifier
si une chaîne commence par «&nbsp;Né le&nbsp;» :</p><pre class="code"><span class="keyword">var</span> <span class="variable">paragraphe</span> = <span class="string">&quot;Est né le 15/11/2003 (mère, Spot) : Croc Blanc&quot;</span>;
<span class="variable">show</span>(<span class="variable">paragraphe</span>.<span class="property">charAt</span>(<span class="atom">0</span>) == <span class="string">&quot;E&quot;</span> &amp;&amp; <span class="variable">paragraphe</span>.<span class="property">charAt</span>(<span class="atom">1</span>) == <span class="string">&quot;s&quot;</span> &amp;&amp;
     <span class="variable">paragraphe</span>.<span class="property">charAt</span>(<span class="atom">2</span>) == <span class="string">&quot;t&quot;</span> &amp;&amp; <span class="variable">paragraphe</span>.<span class="property">charAt</span>(<span class="atom">3</span>) == <span class="string">&quot; &quot;</span> &amp;&amp;
     <span class="variable">paragraphe</span>.<span class="property">charAt</span>(<span class="atom">4</span>) == <span class="string">&quot;n&quot;</span> &amp;&amp; <span class="variable">paragraphe</span>.<span class="property">charAt</span>(<span class="atom">5</span>) == <span class="string">&quot;é&quot;</span> &amp;&amp;
     <span class="variable">paragraphe</span>.<span class="property">charAt</span>(<span class="atom">6</span>) == <span class="string">&quot; &quot;</span> &amp;&amp; <span class="variable">paragraphe</span>.<span class="property">charAt</span>(<span class="atom">7</span>) == <span class="string">&quot;l&quot;</span> &amp;&amp;
     <span class="variable">paragraphe</span>.<span class="property">charAt</span>(<span class="atom">8</span>) == <span class="string">&quot;e&quot;</span>);</pre><p>Mais cela devient un peu pénible ―&nbsp;imaginez que vous devez vérifier la
présence d’un mot de 10 caractères. On peut cependant en tirer une leçon utile
: si une instruction est démesurément longue, on peut l’étendre sur plusieurs
lignes. Le résultat peut être plus facile à lire en alignant le début de la
nouvelle ligne avec le premier élément similaire de la première ligne.</p><p>Les chaînes possèdent également une méthode nommée <a name="key23"></a><code>slice</code>. Elle permet de
copier un morceau de la chaîne de caractères, en commençant par le caractère à
la position donnée par le premier argument, et se terminant avant le caractère
(non inclus) à la position donnée par le second argument. Cela permet de
vérifier une chaîne de caractères en peu de lignes.</p><pre class="code"><span class="variable">show</span>(<span class="variable">paragraphe</span>.<span class="property">slice</span>(<span class="atom">0</span>, <span class="atom">9</span>) == <span class="string">&quot;Est né le&quot;</span>);</pre></div><hr/><div class="block"><a name="exercise4"></a><div class="exercisenum">Ex. 4.4</div><div class="exercise"><p>Écrivez une fonction nommée <code>chaineCommencePar</code> qui prend deux arguments, tous
les deux des chaînes de caractères. Elle renvoie <code>true</code> quand le premier
argument commence par les caractères du second argument, sinon elle renvoie
<code>false</code>.</p></div><div class="solution"><pre class="code"><span class="keyword">function</span> <span class="variable">chaineCommencePar</span>(<span class="variabledef">chaine</span>, <span class="variabledef">motif</span>) {
  <span class="keyword">return</span> <span class="localvariable">chaine</span>.<span class="property">slice</span>(<span class="atom">0</span>, <span class="localvariable">motif</span>.<span class="property">length</span>) == <span class="localvariable">motif</span>;
}

<span class="variable">show</span>(<span class="variable">chaineCommencePar</span>(<span class="string">&quot;rotation&quot;</span>, <span class="string">&quot;rot&quot;</span>));</pre></div></div><hr/><div class="block"><p>Que se passe-t-il quand <code>charAt</code> ou <code>slice</code> sont utilisés pour prendre un
fragment de chaîne qui n’existe pas&nbsp;? Est-ce que la fonction
<code>chaineCommencePar</code> que j’ai montrée va encore fonctionner si la chaîne
recherchée est plus longue que celle dans laquelle on cherche&nbsp;?</p><pre class="code"><span class="variable">show</span>(<span class="string">&quot;Ouai&quot;</span>.<span class="property">charAt</span>(<span class="atom">250</span>));
<span class="variable">show</span>(<span class="string">&quot;Nan&quot;</span>.<span class="property">slice</span>(<span class="atom">1</span>, <span class="atom">10</span>));</pre><p><code>charAt</code> va renvoyer <code>&quot;&quot;</code> s’il n’existe pas de caractère à la position donnée
et <code>slice</code> va tout simplement laisser tomber la partie de la nouvelle chaîne
qui n’existe pas.</p><p>Cela confirme que cette version de <code>chaineCommencePar</code> fonctionne. Quand la
fonction <code>chaineCommencePar(&quot;Idiots&quot;,&quot;Mes très chers collègues&quot;)</code> est appelée,
l’appel à <code>slice</code> renverra toujours une chaîne plus courte que <code>motif</code>, parce
que le premier argument, <code>chaine</code>, ne comporte pas assez de caractères. C’est
pour cette raison que la comparaison avec <code>==</code> renverra <code>false</code>, ce qui est
correct.</p><p>C’est une bonne idée de toujours consacrer un moment pour prendre en
considération les entrées aberrantes (mais valides) dans un programme. On les
appelle en général des cas imprévus et il est très fréquent qu’un programme qui
tourne à merveille avec toutes les entrées «&nbsp;normales&nbsp;» se plante complètement
avec des cas imprévus.</p></div><hr/><div class="block"><p>La seule partie de notre problème de chats qui ne soit pas encore résolue est
l’extraction des noms d’un paragraphe. L’algorithme était le suivant :</p><ol><li>Trouver le deux-points (:) dans le paragraphe.</li><li>Prendre la partie après ce signe.</li><li>Dans cette partie, séparer les noms en cherchant les virgules.</li></ol><p>Il faut reproduire cela à la fois pour les paragraphes qui commencent par
<code>Décès le</code> et ceux qui commencent par <code>Est né le</code>. Ce serait une bonne idée de
le mettre dans une fonction, de sorte que les deux parties de code qui gèrent
les différentes sortes de paragraphes puissent l’utiliser.</p></div><hr/><div class="block"><a name="exercise5"></a><div class="exercisenum">Ex. 4.5</div><div class="exercise"><p>Savez-vous écrire une fonction <code>nomDesChats</code> qui prenne un paragraphe comme
argument et renvoie un tableau de noms&nbsp;?</p><p>Les chaînes ont une méthode <a name="key24"></a><code>indexOf</code> que l’on peut utiliser pour trouver la
(première) position d’un caractère ou une sous-chaîne à l’intérieur d’une
chaîne. De même si on ne donne qu’un seul argument à <code>slice</code>, elle renverra la
partie de la chaîne depuis la première position jusqu’à son extrémité.</p><p>Il peut être pratique d’utiliser la console pour «&nbsp;explorer&nbsp;» les fonctions.
Par exemple, tapez <code>&quot;foo: bar&quot;.indexOf(&quot;:&quot;)</code><a class="footref" href="#footnote2">2</a> et voyez ce qui se passe.</p></div><div class="solution"><pre class="code"><span class="keyword">function</span> <span class="variable">nomDesChats</span>(<span class="variabledef">paragraphe</span>) {
  <span class="keyword">var</span> <span class="variabledef">deuxPoints</span> = <span class="localvariable">paragraphe</span>.<span class="property">indexOf</span>(<span class="string">&quot;:&quot;</span>);
  <span class="keyword">return</span> <span class="localvariable">paragraphe</span>.<span class="property">slice</span>(<span class="localvariable">deuxPoints</span> + <span class="atom">2</span>).<span class="property">split</span>(<span class="string">&quot;, &quot;</span>);
}

<span class="variable">show</span>(<span class="variable">nomDesChats</span>(<span class="string">&quot;Est né le 20/09/2004 (mère, Bess la Jaune): &quot;</span> +
              <span class="string">&quot;Docteur Hobbles II, Kaïra&quot;</span>));</pre><p>La partie la plus délicate, qui n’a pas été mentionnée lors la description
originale de l’algorithme, est le traitement des espaces après les deux-points
et les virgules. Le <code>+2</code>, utilisé pour le découpage de chaînes, est nécessaire
pour laisser de côté le deux-points lui-même et l’espace qui le suit.
L’argument pour <code>split</code> contient à la fois une virgule et une espace, parce que
ce sont les séparateurs de noms, plutôt que par une simple virgule.</p><p>Cette fonction n’effectue aucune vérification de problèmes éventuels. Nous
faisons comme si, dans ce cas précis, l’entrée était toujours correcte.</p></div></div><hr/><div class="block"><p>Tout ce qui nous reste à faire maintenant, c’est de rassembler les pièces du
puzzle. Voici une façon de s’y prendre :</p><pre class="code"><span class="keyword">var</span> <span class="variable">archiveDeMessages</span> = <span class="variable">recupererLesMessages</span>();
<span class="keyword">var</span> <span class="variable">chatsVivants</span> = {<span class="string">&quot;Spot&quot;</span>: <span class="atom">true</span>};

<span class="keyword">for</span> (<span class="keyword">var</span> <span class="variable">message</span> = <span class="atom">0</span>; <span class="variable">message</span> &lt; <span class="variable">archiveDeMessages</span>.<span class="property">length</span>; <span class="variable">message</span>++) {
  <span class="keyword">var</span> <span class="variable">paragraphes</span> = <span class="variable">archiveDeMessages</span>[<span class="variable">message</span>].<span class="property">split</span>(<span class="string">&quot;\n&quot;</span>);
  <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variable">paragraphe</span> = <span class="atom">0</span>;
       <span class="variable">paragraphe</span> &lt; <span class="variable">paragraphes</span>.<span class="property">length</span>;
       <span class="variable">paragraphe</span>++) {
    <span class="keyword">if</span> (<span class="variable">chaineCommencePar</span>(<span class="variable">paragraphes</span>[<span class="variable">paragraphe</span>], <span class="string">&quot;Est né le&quot;</span>)) {
      <span class="keyword">var</span> <span class="variable">noms</span> = <span class="variable">nomDesChats</span>(<span class="variable">paragraphes</span>[<span class="variable">paragraphe</span>]);
      <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variable">nom</span> = <span class="atom">0</span>; <span class="variable">nom</span> &lt; <span class="variable">noms</span>.<span class="property">length</span>; <span class="variable">nom</span>++)
        <span class="variable">chatsVivants</span>[<span class="variable">noms</span>[<span class="variable">nom</span>]] = <span class="atom">true</span>;
    }
    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">chaineCommencePar</span>(<span class="variable">paragraphes</span>[<span class="variable">paragraphe</span>], <span class="string">&quot;Décédé le&quot;</span>)) {
      <span class="keyword">var</span> <span class="variable">noms</span> = <span class="variable">nomDesChats</span>(<span class="variable">paragraphes</span>[<span class="variable">paragraphe</span>]);
      <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variable">nom</span> = <span class="atom">0</span>; <span class="variable">nom</span> &lt; <span class="variable">noms</span>.<span class="property">length</span>; <span class="variable">noms</span>++)
        <span class="keyword">delete</span> <span class="variable">chatsVivants</span>[<span class="variable">noms</span>[<span class="variable">nom</span>]];
    }
  }
}

<span class="variable">show</span>(<span class="variable">chatsVivants</span>);</pre><p>Voilà un bloc de code assez copieux et dense. Nous allons voir tout de suite
comment l’alléger un peu. Mais d’abord jetons un coup d’œil aux résultats. Nous
savons comment vérifier si un chat particulier a survécu :</p><pre class="code"><span class="keyword">if</span> (<span class="string">&quot;Spot&quot;</span> in <span class="variable">chatsVivants</span>)
  <span class="variable">print</span>(<span class="string">&quot;Spot est vivant&nbsp;!&quot;</span>);
<span class="keyword">else</span>
  <span class="variable">print</span>(<span class="string">&quot;Ce bon vieux Spot, qu’il repose en paix.&quot;</span>);</pre><p>Mais comment allons-nous faire pour dresser la liste de tous les chats vivants
? Le mot-clé <a name="key25"></a><code>in</code> a une signification légèrement différente lorsqu’il est
utilisé avec <code>for</code> :</p><pre class="code"><span class="keyword">for</span> (<span class="keyword">var</span> <span class="variable">chat</span> <span class="keyword">in</span> <span class="variable">chatsVivants</span>)
  <span class="variable">print</span>(<span class="variable">chat</span>);</pre><p>Une boucle comme celle-là va parcourir les noms des propriétés d’un objet, ce
qui nous permettra d’énumérer tous les noms de notre ensemble.</p></div><hr/><div class="block"><p>Certaines parties de code ressemblent à une jungle impénétrable. L’exemple de
solution pour le problème des chats souffre de ce défaut. Une façon de ménager
des clairières consiste tout simplement à ajouter des lignes vides. Cela
améliore la lisibilité, mais ne résout pas véritablement le problème.</p><p>Ce qu’il nous faut ici, c’est casser le code. Nous avons déjà écrit deux
fonctions d’aide, <code>chaineCommencePar</code> et <code>nomDesChats</code>, qui toutes deux
résolvent une petite partie du problème de façon compréhensible. Continuons sur
cette lancée.</p><pre class="code"><span class="keyword">function</span> <span class="variable">ajouterAuSet</span>(<span class="variabledef">set</span>, <span class="variabledef">valeurs</span>) {
  <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">i</span> = <span class="atom">0</span>; <span class="localvariable">i</span> &lt; <span class="localvariable">valeurs</span>.<span class="property">length</span>; <span class="localvariable">i</span>++)
    <span class="localvariable">set</span>[<span class="localvariable">valeurs</span>[<span class="localvariable">i</span>]] = <span class="atom">true</span>;
}

<span class="keyword">function</span> <span class="variable">enleverDuSet</span>(<span class="variabledef">set</span>, <span class="variabledef">valeurs</span>) {
  <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">i</span> = <span class="atom">0</span>; <span class="localvariable">i</span> &lt; <span class="localvariable">valeurs</span>.<span class="property">length</span>; <span class="localvariable">i</span>++)
    <span class="keyword">delete</span> <span class="localvariable">set</span>[<span class="localvariable">valeurs</span>[<span class="localvariable">i</span>]];
}</pre><p>Ces deux fonctions traitent de l’ajout et de la suppression des noms dans
l’ensemble. Ce qui supprime déjà les deux plus importantes boucles internes de
la solution :</p><pre class="code"><span class="keyword">var</span> <span class="variable">chatsVivants</span> = {<span class="property">Spot</span>: <span class="atom">true</span>};

<span class="keyword">for</span> (<span class="keyword">var</span> <span class="variable">message</span> = <span class="atom">0</span>; <span class="variable">message</span> &lt; <span class="variable">archiveDeMessages</span>.<span class="property">length</span>; <span class="variable">message</span>++) {
  <span class="keyword">var</span> <span class="variable">paragraphes</span> = <span class="variable">archiveDeMessages</span>[<span class="variable">message</span>].<span class="property">split</span>(<span class="string">&quot;\n&quot;</span>);
  <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variable">paragraphe</span> = <span class="atom">0</span>;
       <span class="variable">paragraphe</span> &lt; <span class="variable">paragraphes</span>.<span class="property">length</span>;
       <span class="variable">paragraphe</span>++) {
    <span class="keyword">if</span> (<span class="variable">chaineCommencePar</span>(<span class="variable">paragraphes</span>[<span class="variable">paragraphe</span>], <span class="string">&quot;Est né le&quot;</span>))
      <span class="variable">ajouterAuSet</span>(<span class="variable">chatsVivants</span>, <span class="variable">nomDesChats</span>(<span class="variable">paragraphes</span>[<span class="variable">paragraphe</span>]));
    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">chaineCommencePar</span>(<span class="variable">paragraphes</span>[<span class="variable">paragraphe</span>], <span class="string">&quot;Décédé le&quot;</span>))
      <span class="variable">enleverDuSet</span>(<span class="variable">chatsVivants</span>, <span class="variable">nomDesChats</span>(<span class="variable">paragraphes</span>[<span class="variable">paragraphe</span>]));
  }
}</pre><p>C’est un sacré progrès, si je peux me permettre. Pourquoi <code>ajouterAuSet</code> et
<code>enleverDuSet</code> prennent-ils l’ensemble comme argument&nbsp;? Ils pourraient utiliser
la variable <code>chatsVivants</code> directement, s’ils le voulaient. La raison, c’est
que de cette façon elles ne sont pas totalement liées à notre problème. Si
<code>ajouterAuSet</code> changeait directement <code>chatsVivants</code>, il faudrait l’appeler
<code>ajouterChatsDansEnsembleDeChats</code> ou quelque chose comme ça. Tel que nous
l’utilisons, c’est un outil utile pour des cas plus généraux.</p><p>Même si nous ne devions jamais utiliser ces fonctions pour quoi que ce soit
d’autre, ce qui est très probable, il est utile de les décrire de cette façon.
Car elles se «&nbsp;suffisent à elles-même&nbsp;», on peut les lire et les comprendre,
sans avoir besoin de connaître une variable externe nommée <code>chatsVivants</code>.</p><p>Ces fonctions ne sont pas pures : elles modifient l’objet <code>set</code> qui a été passé
en premier argument. Cela rend les choses un peu plus délicates qu’avec des
fonctions pures mais c’est déjà beaucoup moins perturbant que des fonctions qui
perdent les pédales et modifient les valeurs de variables comme ça leur chante.</p></div><hr/><div class="block"><p>Nous continuons à découper l’algorithme en petites unités :</p><pre class="code"><span class="keyword">function</span> <span class="variable">trouverChatsVivants</span>() {
  <span class="keyword">var</span> <span class="variabledef">archiveDeMessages</span> = <span class="variable">recupererLesMessages</span>();
  <span class="keyword">var</span> <span class="variabledef">chatsVivants</span> = {<span class="string">&quot;Spot&quot;</span>: <span class="atom">true</span>};

  <span class="keyword">function</span> <span class="variabledef">traiterParagraphe</span>(<span class="variabledef">paragraphe</span>) {
    <span class="keyword">if</span> (<span class="variable">chaineCommencePar</span>(<span class="localvariable">paragraphe</span>, <span class="string">&quot;Est né le&quot;</span>))
      <span class="variable">ajouterAuSet</span>(<span class="localvariable">chatsVivants</span>, <span class="variable">nomDesChats</span>(<span class="localvariable">paragraphe</span>));
    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">chaineCommencePar</span>(<span class="localvariable">paragraphe</span>, <span class="string">&quot;Décédé le&quot;</span>))
      <span class="variable">enleverDuSet</span>(<span class="localvariable">chatsVivants</span>, <span class="variable">nomDesChats</span>(<span class="localvariable">paragraphe</span>));
  }

  <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">message</span> = <span class="atom">0</span>; <span class="localvariable">message</span> &lt; <span class="localvariable">archiveDeMessages</span>.<span class="property">length</span>; <span class="localvariable">message</span>++) {
    <span class="keyword">var</span> <span class="variabledef">paragraphes</span> = <span class="localvariable">archiveDeMessages</span>[<span class="localvariable">message</span>].<span class="property">split</span>(<span class="string">&quot;\n&quot;</span>);
    <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">i</span> = <span class="atom">0</span>; <span class="localvariable">i</span> &lt; <span class="localvariable">paragraphes</span>.<span class="property">length</span>; <span class="localvariable">i</span>++)
      <span class="localvariable">traiterParagraphe</span>(<span class="localvariable">paragraphes</span>[<span class="localvariable">i</span>]);
  }
  <span class="keyword">return</span> <span class="localvariable">chatsVivants</span>;
}

<span class="keyword">var</span> <span class="variable">combien</span> = <span class="atom">0</span>;
<span class="keyword">for</span> (<span class="keyword">var</span> <span class="variable">chat</span> <span class="keyword">in</span> <span class="variable">trouverChatsVivants</span>())
  <span class="variable">combien</span>++;
<span class="variable">print</span>(<span class="string">&quot;Il y a &quot;</span>, <span class="variable">combien</span>, <span class="string">&quot; chats.&quot;</span>);</pre><p>La totalité de l’algorithme est encapsulée dans une fonction. Cela signifie
qu’elle ne laisse rien traîner en vrac derrière elle après exécution :
<code>chatsVivants</code> est maintenant une variable locale dans la fonction et non plus
une variable globale, si bien qu’elle n’existe que pendant que la fonction
s’exécute. Le code qui a besoin de cet ensemble peut appeler
<code>trouverChatsVivants</code> et utiliser la valeur qu’il renvoie.</p><p>Il me semble que faire de <code>traiterParagraphe</code> une fonction distincte peut aussi
clarifier les choses. Mais celle-ci est si étroitement liée à l’algorithme des
chats qu’elle n’aurait aucun sens dans une autre situation. De plus, elle a
besoin d’accéder à la variable <code>chatsVivants</code>. C’est donc une candidate
parfaite pour devenir une fonction à l’intérieur d’une fonction. Quand elle
existe à l’intérieur de <code>trouverChatsVivants</code>, il est clair qu’elle n’est
pertinente que là et qu’elle a accès aux variables de sa fonction parente.</p><p>Cette solution est en fait plus <em>grande</em> que la précédente. Mais elle est plus
propre et j’espère que vous reconnaîtrez qu’elle est plus lisible.</p></div><hr/><div class="block"><p>Le programme ignore encore un grand nombre d’informations qui sont incluses
dans les courriels. Il s’agit des dates de naissance, de mort et des noms des
mères.</p><p>Commençons par les dates : quelle pourrait être la meilleure façon de stocker
une date&nbsp;? Nous pourrions créer un objet avec ces trois propriétés,  <code>year</code>
(année), <code>month</code> (mois), et <code>day</code> (jour) et stocker ensuite des nombres à
l’intérieur.</p><pre class="code"><span class="keyword">var</span> <span class="variable">quand</span> = {<span class="property">year</span>: <span class="atom">1980</span>, <span class="property">month</span>: <span class="atom">2</span>, <span class="property">day</span>: <span class="atom">1</span>};</pre><p>Mais JavaScript fournit déjà une sorte d’objet pour cela. Un tel objet peut
être créé en utilisant le mot-clé <a name="key26"></a><code>new</code> :</p><pre class="code"><span class="keyword">var</span> <span class="variable">quand</span> = <span class="keyword">new</span> <span class="variable">Date</span>(<span class="atom">1980</span>, <span class="atom">1</span>, <span class="atom">1</span>);
<span class="variable">show</span>(<span class="variable">quand</span>);</pre><p>Tout comme la notation avec les accolades et les deux-points que nous avons
déjà vue, <code>new</code> est une façon de créer des valeurs d’un objet. Au lieu de
préciser tous les noms de propriétés et les valeurs, une fonction est utilisée
pour créer l’objet. Cela rend possible de définir une sorte de procédure
standard pour créer des objets. Les fonctions comme celle-là s’appellent
<a name="key27"></a>constructeurs et nous verrons comment les écrire dans <a href="chapter8.html">chapitre 8</a>.</p><p>Le constructeur <a name="key28"></a><code>Date</code> peut être utilisé de différentes manières</p><pre class="code"><span class="variable">show</span>(<span class="keyword">new</span> <span class="variable">Date</span>());
<span class="variable">show</span>(<span class="keyword">new</span> <span class="variable">Date</span>(<span class="atom">1980</span>, <span class="atom">1</span>, <span class="atom">1</span>));
<span class="variable">show</span>(<span class="keyword">new</span> <span class="variable">Date</span>(<span class="atom">2007</span>, <span class="atom">2</span>, <span class="atom">30</span>, <span class="atom">8</span>, <span class="atom">20</span>, <span class="atom">30</span>));</pre><p>Comme vous pouvez le voir, ces objets peuvent enregistrer l’heure d’un jour
aussi bien qu’une date. Quand aucun argument n’est précisé, un objet
représentant l’heure et la date actuelles est créé. Des arguments peuvent être
précisés pour stocker une heure et une date précises. L’ordre des arguments est
l’année, le mois, le jour, l’heure, la minute, la seconde puis la milliseconde.
Les quatre derniers arguments sont optionnels et définis à 0 s’ils ne sont pas
précisés.</p><p>Pour décrire les mois, on utilise la numérotation de 0 à 11, qui peut provoquer
une confusion. Surtout que les nombres définissant les jours commencent eux à
1.</p></div><hr/><div class="block"><p>Le contenu de l’objet <code>Date</code> peut être inspecté avec un nombre de méthodes
<code>get…</code>.</p><pre class="code"><span class="keyword">var</span> <span class="variable">aujourdHui</span> = <span class="keyword">new</span> <span class="variable">Date</span>();
<span class="variable">print</span>(<span class="string">&quot;Année : &quot;</span>, <span class="variable">aujourdHui</span>.<span class="property">getFullYear</span>(), <span class="string">&quot;, mois : &quot;</span>,
      <span class="variable">aujourdHui</span>.<span class="property">getMonth</span>(), <span class="string">&quot;, jour : &quot;</span>, <span class="variable">aujourdHui</span>.<span class="property">getDate</span>());
<span class="variable">print</span>(<span class="string">&quot;Heure : &quot;</span>, <span class="variable">aujourdHui</span>.<span class="property">getHours</span>(), <span class="string">&quot;, minutes : &quot;</span>,
      <span class="variable">aujourdHui</span>.<span class="property">getMinutes</span>(), <span class="string">&quot;, secondes: &quot;</span>, <span class="variable">aujourdHui</span>.<span class="property">getSeconds</span>());
<span class="variable">print</span>(<span class="string">&quot;Jour de la semaine : &quot;</span>, <span class="variable">aujourdHui</span>.<span class="property">getDay</span>());</pre><p>Tous ces éléments, excepté la méthode <code>getDay</code>, ont une variable <code>set…</code> qui
peut être utilisée pour modifier la valeur de l’objet date.</p><p>Dans l’objet, une date est représentée par la somme de millisecondes cumulées
depuis le 1er Janvier 1970. Vous pouvez imaginer que c’est un nombre assez
impressionnant.</p><pre class="code"><span class="keyword">var</span> <span class="variable">aujourdHui</span> = <span class="keyword">new</span> <span class="variable">Date</span>();
<span class="variable">show</span>(<span class="variable">aujourdHui</span>.<span class="property">getTime</span>());</pre><p>Une chose très utile à faire avec les dates, c’est de les comparer.</p><pre class="code"><span class="keyword">var</span> <span class="variable">chuteDuMur</span> = <span class="keyword">new</span> <span class="variable">Date</span>(<span class="atom">1989</span>, <span class="atom">10</span>, <span class="atom">9</span>);
<span class="keyword">var</span> <span class="variable">premiereGuerreDuGolf</span> = <span class="keyword">new</span> <span class="variable">Date</span> (<span class="atom">1990</span>, <span class="atom">6</span>, <span class="atom">2</span>);
<span class="variable">show</span>(<span class="variable">chuteDuMur</span> &lt; <span class="variable">premiereGuerreDuGolf</span>);
<span class="variable">show</span>(<span class="variable">chuteDuMur</span> == <span class="variable">chuteDuMur</span>);
<span class="comment">// mais</span>
<span class="variable">show</span>(<span class="variable">chuteDuMur</span> == <span class="keyword">new</span> <span class="variable">Date</span>(<span class="atom">1989</span>, <span class="atom">10</span>, <span class="atom">9</span>));</pre><p>Comparer les dates avec <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> et <code>&gt;=</code> remplit exactement l’office que
nous voulons en faire. Quand un objet date est comparé avec lui-même, le
résultat est <code>true</code>, ce qui est bien également. Mais quand <a name="key29"></a><code>==</code> est utilisé
pour comparer un objet date à un autre objet date distinct mais de même valeur,
on obtient <code>false</code>. Étrange, non&nbsp;?</p><p>Comme précisé plus tôt, <code>==</code> retournera la valeur <a href="lors de la
comparaison de deux éléments différents, même si ces deux éléments contiennent
les mêmes propriétés. Ceci est un peu maladroit et sujet à erreur, puisqu’on
s’attendrait à ce que |&gt;=| et |==| aient le même comportement. Tester si deux
dates sont égales peut être fait de cette manière :">false</a></p><pre class="code"><span class="keyword">var</span> <span class="variable">chuteDuMur1</span> = <span class="keyword">new</span> <span class="variable">Date</span>(<span class="atom">1989</span>, <span class="atom">10</span>, <span class="atom">9</span>),
<span class="variable">chuteDuMur2</span> = <span class="keyword">new</span> <span class="variable">Date</span>(<span class="atom">1989</span>, <span class="atom">10</span> ,<span class="atom">9</span>);
<span class="variable">show</span>(<span class="variable">chuteDuMur1</span>.<span class="property">getTime</span>() == <span class="variable">chuteDuMur2</span>.<span class="property">getTime</span>());</pre></div><hr/><div class="block"><p>Au-delà de la date et l’heure, l’objet <code>Date</code> contient aussi des informations
sur le <a name="key30"></a>fuseau horaire. Quand il est une heure à Amsterdam, en fonction de la
période de l’année il peut être midi à Londres et sept heures du matin à New
York. De telles heures ne peuvent être rapprochées que si vous prenez les
fuseaux horaires en compte. La fonction <a name="key31"></a><code>getTimezoneOffset</code> d’une <code>Date</code> peut
être utilisée pour trouver de combien de minutes elle s’éloigne du GMT (Heure
du méridien de Greenwich)</p><pre class="code"><span class="keyword">var</span> <span class="variable">maintenant</span> = <span class="keyword">new</span> <span class="variable">Date</span>();
<span class="variable">print</span>(<span class="variable">maintenant</span>.<span class="property">getTimezoneOffset</span>());</pre></div><hr/><div class="block"><a name="exercise6"></a><div class="exercisenum">Ex. 4.6</div><div class="exercise"><pre class="preformatted">&quot;Décédé le 27/04/2006 : Black Leclère&quot;</pre><p>La partie date est toujours exactement à la même place du paragraphe. Comme
c’est pratique. Écrivez une fonction <code>extraireDate</code> qui prend un tel paragraphe
pour argument, extrait la date et la renvoie sous la forme d’un objet date.</p></div><div class="solution"><pre class="code"><span class="keyword">function</span> <span class="variable">extraireDate</span>(<span class="variabledef">paragraphe</span>) {
  <span class="keyword">function</span> <span class="variabledef">nombreEnPosition</span>(<span class="variabledef">position</span>, <span class="variabledef">longueur</span>) {
    <span class="keyword">return</span> <span class="variable">Number</span>(<span class="localvariable">paragraphe</span>.<span class="property">slice</span>(<span class="localvariable">position</span>, <span class="localvariable">position</span> + <span class="localvariable">longueur</span>));
  }
  <span class="keyword">return</span> <span class="keyword">new</span> <span class="variable">Date</span>(<span class="localvariable">nombreEnPosition</span>(<span class="atom">16</span>, <span class="atom">4</span>), <span class="localvariable">nombreEnPosition</span>(<span class="atom">13</span>, <span class="atom">2</span>) - <span class="atom">1</span>,
                  <span class="localvariable">nombreEnPosition</span>(<span class="atom">10</span>, <span class="atom">2</span>));
}

<span class="variable">show</span>(<span class="variable">extraireDate</span>(<span class="string">&quot;Décédé le 27-04-2006 : Black Leclère&quot;</span>));</pre><p>Cela marcherait sans les appels à <code>Number</code>, mais comme je l’ai expliqué plus
haut, je préfère ne pas utiliser de chaînes comme si elles étaient des nombres.
La fonction interne a été introduite pour éviter d’avoir à répéter trois fois
les parties <code>Number</code> et <code>slice</code>.</p><p>Notez le <code>-1</code> pour le numéro du mois. Comme la plupart des gens, tante Émilie
compte les mois à partir de 1, nous devons donc ajuster cette valeur avant de
la donner au constructeur <code>Date</code> (le numéro du jour ne relève pas du même
problème, puisque les objets <code>Date</code> comptent les jours de la façon humaine
habituelle).</p><p>Dans le <a href="chapter10.html">chapitre 10</a>, nous verrons une façon plus pratique et plus sûre d’extraire
des parties de chaînes qui ont une structure déterminée.</p></div></div><hr/><div class="block"><p>Stocker des chats est une opération qui va se dérouler différemment à partir de
maintenant. Au lieu de simplement mettre la valeur <code>true</code> sur l’ensemble, nous
stockons un objet avec les informations sur le chat. Lorsqu’un chat meurt, nous
ne le supprimons pas de l’ensemble, nous ajoutons simplement la propriété
<code>deces</code> à l’objet pour stocker la date à laquelle le pauvre animal a trépassé.</p><p>Cela signifie que nos fonctions <code>ajouterAuSet</code> et <code>enleverDuSet</code> sont devenues
inutiles. Quelque chose de comparable est nécessaire, mais il s’agit de stocker
aussi les dates de naissance et par la suite, les noms des mères.</p><pre class="code"><span class="keyword">function</span> <span class="variable">enregistrementChat</span>(<span class="variabledef">nom</span>, <span class="variabledef">dateNaissance</span>, <span class="variabledef">mere</span>) {
  <span class="keyword">return</span> {<span class="property">nom</span>: <span class="localvariable">nom</span>, <span class="property">naissance</span>: <span class="localvariable">dateNaissance</span>, <span class="property">mere</span>: <span class="localvariable">mere</span>};
}

<span class="keyword">function</span> <span class="variable">ajouterChats</span>(<span class="variabledef">set</span>, <span class="variabledef">noms</span>, <span class="variabledef">dateNaissance</span>, <span class="variabledef">mere</span>) {
  <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">i</span> = <span class="atom">0</span>; <span class="localvariable">i</span> &lt; <span class="localvariable">noms</span>.<span class="property">length</span>; <span class="localvariable">i</span>++)
    <span class="localvariable">set</span>[<span class="localvariable">noms</span>[<span class="localvariable">i</span>]] = <span class="variable">enregistrementChat</span>(<span class="localvariable">noms</span>[<span class="localvariable">i</span>], <span class="localvariable">dateNaissance</span>, <span class="localvariable">mere</span>);
}
<span class="keyword">function</span> <span class="variable">chatsDecedes</span>(<span class="variabledef">set</span>, <span class="variabledef">noms</span>, <span class="variabledef">dateDeces</span>) {
  <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">i</span> = <span class="atom">0</span>; <span class="localvariable">i</span> &lt; <span class="localvariable">noms</span>.<span class="property">length</span>; <span class="localvariable">i</span>++)
    <span class="localvariable">set</span>[<span class="localvariable">noms</span>[<span class="localvariable">i</span>]].<span class="property">deces</span> = <span class="localvariable">dateDeces</span>;
}</pre><p><code>enregistrementChat</code> est une fonction distincte pour créer ces objets de
stockage. Elle pourrait être utile dans d’autres situations, telles que la
création d’un objet pour Spot. «&nbsp;Record&nbsp;» («&nbsp;enregistrement&nbsp;» en français) est
le terme qu’on emploie couramment pour des objets de ce type, qui sont utilisés
pour regrouper un nombre limité de valeurs.</p></div><hr/><div class="block"><p>Essayons donc maintenant d’extraire les noms des mamans chats qui se trouvent
dans des paragraphes.</p><pre class="preformatted">&quot;Est né le 15/11/2003 (mère, Spot): Croc Blanc&quot;</pre><p>Voici un moyen d’obtenir cela…</p><pre class="code"><span class="keyword">function</span> <span class="variable">extraireNomMere</span>(<span class="variabledef">paragraphe</span>) {
  <span class="keyword">var</span> <span class="variabledef">start</span> = <span class="localvariable">paragraphe</span>.<span class="property">indexOf</span>(<span class="string">&quot;(mère, &quot;</span>) + <span class="string">&quot;(mère, &quot;</span>.<span class="property">length</span>;
  <span class="keyword">var</span> <span class="variabledef">end</span> = <span class="localvariable">paragraphe</span>.<span class="property">indexOf</span>(<span class="string">&quot;)&quot;</span>);
  <span class="keyword">return</span> <span class="localvariable">paragraphe</span>.<span class="property">slice</span>(<span class="localvariable">start</span>, <span class="localvariable">end</span>);
}

<span class="variable">show</span>(<span class="variable">extraireNomMere</span>(<span class="string">&quot;Est né le 15/11/2003 (mère, Spot): Croc Blanc&quot;</span>));</pre><p>Notez comment la position de départ a dû être ajustée à la longueur de <code>&quot;(mère,
&quot;</code>, parce que <code>indexOf</code> renvoie la position initiale de la chaîne et non la
finale.</p></div><hr/><div class="block"><a name="exercise7"></a><div class="exercisenum">Ex. 4.7</div><div class="exercise"><p>Ce que fait <code>extraireNomMere</code> peut être exprimé d’une façon plus générale.
Écrivez une fonction <code>extraireChaineEntre</code> qui prend trois arguments, qui
seront tous des chaînes. Elle renverra la partie du premier argument qui
apparaît entre les chaînes fournies par le deuxième et le troisième argument.</p><p>Ainsi, <code>extraireChaineEntre(&quot;Est né le 15/11/2003 (mère, Spot): Croc Blanc&quot;,
&quot;(mère, &quot;, &quot;)&quot;)</code> donne <code>&quot;Spot&quot;</code>.</p><p><code>extraireChaineEntre(&quot;bu ] boo [ bah ] gzz&quot;, &quot;[ &quot;, &quot; ]&quot;)</code> renvoie <code>&quot;bah&quot;</code>.</p><p>Pour faire marcher ce deuxième exemple, il peut être utile de savoir qu’on peut
attribuer à <code>indexOf</code> un second paramètre facultatif qui précise à partir de
quel point doit commencer la recherche.</p></div><div class="solution"><pre class="code"><span class="keyword">function</span> <span class="variable">extraireChaineEntre</span>(<span class="variabledef">chaine</span>, <span class="variabledef">debut</span>, <span class="variabledef">fin</span>) {
  <span class="keyword">var</span> <span class="variabledef">indexDebut</span> = <span class="localvariable">chaine</span>.<span class="property">indexOf</span>(<span class="localvariable">debut</span>) + <span class="localvariable">debut</span>.<span class="property">length</span>;
  <span class="keyword">var</span> <span class="variabledef">indexFin</span> = <span class="localvariable">chaine</span>.<span class="property">indexOf</span>(<span class="localvariable">fin</span>, <span class="localvariable">indexDebut</span>);
  <span class="keyword">return</span> <span class="localvariable">chaine</span>.<span class="property">slice</span>(<span class="localvariable">indexDebut</span>, <span class="localvariable">indexFin</span>);
}
<span class="variable">show</span>(<span class="variable">extraireChaineEntre</span>(<span class="string">&quot;bu ] boo [ bah ] gzz&quot;</span>, <span class="string">&quot;[ &quot;</span>, <span class="string">&quot; ]&quot;</span>));</pre></div></div><hr/><div class="block"><p>Avoir la fonction <code>extraireChaineEntre</code> rend possible l’expression de
extraireNomMere de façon plus simple :</p><pre class="code"><span class="keyword">function</span> <span class="variable">extraireNomMere</span>(<span class="variabledef">paragraphe</span>) {
  <span class="keyword">return</span> <span class="variable">extraireChaineEntre</span>(<span class="localvariable">paragraphe</span>, <span class="string">&quot;(mère, &quot;</span>, <span class="string">&quot;)&quot;</span>);
}</pre></div><hr/><div class="block"><p>Le nouvel algorithme à chats amélioré ressemble maintenant à ça :</p><pre class="code"><span class="keyword">function</span> <span class="variable">trouverChats</span>() {
  <span class="keyword">var</span> <span class="variabledef">archiveDeMessages</span> = <span class="variable">recupererLesMessages</span>();
  <span class="keyword">var</span> <span class="variabledef">chats</span> = {<span class="string">&quot;Spot&quot;</span>: <span class="variable">enregistrementChat</span>(<span class="string">&quot;Spot&quot;</span>, <span class="keyword">new</span> <span class="variable">Date</span>(<span class="atom">1997</span>, <span class="atom">2</span>, <span class="atom">5</span>),
              <span class="string">&quot;inconnue&quot;</span>)};

  <span class="keyword">function</span> <span class="variabledef">traiterParagraphe</span>(<span class="variabledef">paragraphe</span>) {
    <span class="keyword">if</span> (<span class="variable">chaineCommencePar</span>(<span class="localvariable">paragraphe</span>, <span class="string">&quot;Est né le&quot;</span>))
      <span class="variable">ajouterChats</span>(<span class="localvariable">chats</span>, <span class="variable">nomDesChats</span>(<span class="localvariable">paragraphe</span>), <span class="variable">extraireDate</span>(<span class="localvariable">paragraphe</span>),
              <span class="variable">extraireNomMere</span>(<span class="localvariable">paragraphe</span>));
    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">chaineCommencePar</span>(<span class="localvariable">paragraphe</span>, <span class="string">&quot;Décédé le&quot;</span>))
      <span class="variable">chatsDecedes</span>(<span class="localvariable">chats</span>, <span class="variable">nomDesChats</span>(<span class="localvariable">paragraphe</span>), <span class="variable">extraireDate</span>(<span class="localvariable">paragraphe</span>));
  }

  <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">message</span> = <span class="atom">0</span>; <span class="localvariable">message</span> &lt; <span class="localvariable">archiveDeMessages</span>.<span class="property">length</span>; <span class="localvariable">message</span>++) {
    <span class="keyword">var</span> <span class="variabledef">paragraphes</span> = <span class="localvariable">archiveDeMessages</span>[<span class="localvariable">message</span>].<span class="property">split</span>(<span class="string">&quot;\n&quot;</span>);
    <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">i</span> = <span class="atom">0</span>; <span class="localvariable">i</span> &lt; <span class="localvariable">paragraphes</span>.<span class="property">length</span>; <span class="localvariable">i</span>++)
      <span class="localvariable">traiterParagraphe</span>(<span class="localvariable">paragraphes</span>[<span class="localvariable">i</span>]);
  }
  <span class="keyword">return</span> <span class="localvariable">chats</span>;
}

<span class="keyword">var</span> <span class="variable">tousLesChats</span> = <span class="variable">trouverChats</span>();</pre><p>Obtenir ces données supplémentaires nous permet d’avoir finalement une idée
plus précise des chats dont parle tante Émilie. Une fonction comme celle-ci
pourrait être utile :</p><pre class="code"><span class="keyword">function</span> <span class="variable">formatDate</span>(<span class="variabledef">date</span>) {
  <span class="keyword">return</span> <span class="localvariable">date</span>.<span class="property">getDate</span>() + <span class="string">&quot;/&quot;</span> + (<span class="localvariable">date</span>.<span class="property">getMonth</span>() + <span class="atom">1</span>) +
         <span class="string">&quot;/&quot;</span> + <span class="localvariable">date</span>.<span class="property">getFullYear</span>();
}

<span class="keyword">function</span> <span class="variable">renseignementSurChat</span>(<span class="variabledef">data</span>, <span class="variabledef">nom</span>) {
  <span class="keyword">if</span> (!(<span class="localvariable">nom</span> in <span class="localvariable">data</span>))
    <span class="keyword">return</span> <span class="string">&quot;Aucun chat s’appelant &quot;</span> + <span class="localvariable">nom</span> + <span class="string">&quot; n’a été trouvé.&quot;</span>;

  <span class="keyword">var</span> <span class="variabledef">chat</span> = <span class="localvariable">data</span>[<span class="localvariable">nom</span>];
  <span class="keyword">var</span> <span class="variabledef">message</span> = <span class="localvariable">nom</span> + <span class="string">&quot;, est né le &quot;</span> + <span class="variable">formatDate</span>(<span class="localvariable">chat</span>.<span class="property">naissance</span>) +
                <span class="string">&quot; de la mère &quot;</span> + <span class="localvariable">chat</span>.<span class="property">mere</span>;
  <span class="keyword">if</span> (<span class="string">&quot;deces&quot;</span> in <span class="localvariable">chat</span>)
    <span class="localvariable">message</span> += <span class="string">&quot;, décédé le &quot;</span> + <span class="variable">formatDate</span>(<span class="localvariable">chat</span>.<span class="property">deces</span>);
  <span class="keyword">return</span> <span class="localvariable">message</span> + <span class="string">&quot;.&quot;</span>;
}

<span class="variable">print</span>(<span class="variable">renseignementSurChat</span>(<span class="variable">tousLesChats</span>, <span class="string">&quot;Gros Igor&quot;</span>));</pre><p>La première instruction <code>return</code> dans <code>renseignementSurChat</code> est utilisée comme
issue de secours. Si aucune donnée n’est fournie sur un chat particulier, le
reste de la fonction est dépourvu de sens, nous renvoyons donc immédiatement
une valeur qui empêche le reste du code de s’exécuter.</p><p>Dans le passé, certains groupes de programmeurs considéraient comme malsaines
les fonctions contenant de multiples instructions <code>return</code>. Selon eux, cela
rendait difficile de voir quel code était exécuté et quel code ne l’était pas.
D’autres techniques, qui seront abordées dans le <a href="chapter5.html">chapitre 5</a>, ont rendu cet
argument plus ou moins obsolète, mais vous pouvez toujours tomber à l’occasion
sur quelqu’un qui critiquera l’utilisation de raccourcis avec l’instruction
<code>return</code>.</p></div><hr/><div class="block"><a name="exercise8"></a><div class="exercisenum">Ex. 4.8</div><div class="exercise"><p>La fonction <code>formatDate</code> utilisée par <code>renseignementSurChat</code> n’ajoute pas de
zéro avant la partie mois et jour quand ce sont des nombres à un seul chiffre.
Écrivez une nouvelle version qui fera cela.</p></div><div class="solution"><pre class="code"><span class="keyword">function</span> <span class="variable">formatDate</span>(<span class="variabledef">date</span>) {
  <span class="keyword">function</span> <span class="variabledef">pad</span>(<span class="variabledef">nombre</span>) {
    <span class="keyword">if</span> (<span class="localvariable">nombre</span> &lt; <span class="atom">10</span>)
      <span class="keyword">return</span> <span class="string">&quot;0&quot;</span> + <span class="localvariable">nombre</span>;
    <span class="keyword">else</span>
      <span class="keyword">return</span> <span class="localvariable">nombre</span>;
  }
  <span class="keyword">return</span> <span class="localvariable">pad</span>(<span class="localvariable">date</span>.<span class="property">getDate</span>()) + <span class="string">&quot;/&quot;</span> + <span class="localvariable">pad</span>(<span class="localvariable">date</span>.<span class="property">getMonth</span>() + <span class="atom">1</span>) +
             <span class="string">&quot;/&quot;</span> + <span class="localvariable">date</span>.<span class="property">getFullYear</span>();
}
<span class="variable">print</span>(<span class="variable">formatDate</span>(<span class="keyword">new</span> <span class="variable">Date</span>(<span class="atom">2000</span>, <span class="atom">0</span>, <span class="atom">1</span>)));</pre></div></div><hr/><div class="block"><a name="exercise9"></a><div class="exercisenum">Ex. 4.9</div><div class="exercise"><p>Écrivez une fonction <code>lePlusVieuxChat</code> qui, étant donné un objet ayant des
chats comme arguments, renvoie le nom du plus vieux chat vivant.</p></div><div class="solution"><pre class="code"><span class="keyword">function</span> <span class="variable">lePlusVieuxChat</span>(<span class="variabledef">data</span>) {
  <span class="keyword">var</span> <span class="variabledef">lePlusVieux</span> = <span class="atom">null</span>;

  <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">nom</span> <span class="keyword">in</span> <span class="localvariable">data</span>) {
    <span class="keyword">var</span> <span class="variabledef">chat</span> = <span class="localvariable">data</span>[<span class="localvariable">nom</span>];
    <span class="keyword">if</span> (!(<span class="string">&quot;deces&quot;</span> in <span class="localvariable">chat</span>) &amp;&amp;
        (<span class="localvariable">lePlusVieux</span> == <span class="atom">null</span> || <span class="localvariable">lePlusVieux</span>.<span class="property">naissance</span> &gt; <span class="localvariable">chat</span>.<span class="property">naissance</span>))
      <span class="localvariable">lePlusVieux</span> = <span class="localvariable">chat</span>;
  }

  <span class="keyword">if</span> (<span class="localvariable">lePlusVieux</span> == <span class="atom">null</span>)
    <span class="keyword">return</span> <span class="atom">null</span>;
  <span class="keyword">else</span>
    <span class="keyword">return</span> <span class="localvariable">lePlusVieux</span>.<span class="property">nom</span>;
}

<span class="variable">print</span>(<span class="variable">lePlusVieuxChat</span>(<span class="variable">tousLesChats</span>));</pre><p>La condition donnée avec la commande <code>if</code> pourrait paraître un peu intimidante.
On peut la lire comme : «&nbsp;ne stocker le chat en cours dans la variable
<code>lePlusVieux</code> que s’il n’est pas mort, et si <code>lePlusVieux</code> est soit <code>null</code> soit
un chat qui est né après le chat en cours&nbsp;».</p><p>Notez que cette fonction renvoie <code>null</code> quand il n’existe aucun chat vivant
dans <code>data</code>. Que fait votre solution à l’exercice dans ce cas&nbsp;?</p></div></div><hr/><div class="block"><p>Maintenant que vous êtes familiarisé avec les tableaux, je peux vous montrer
quelque chose de lié. Quel que soit le nom d’une fonction, une variable
spéciale nommée <a name="key32"></a><code>arguments</code> est ajoutée à l’environnement dans lequel le
corps de la fonction tourne. Cette variable se réfère à un objet qui ressemble
à un tableau. Il a la propriété <code>0</code> pour le premier argument, <code>1</code> pour le
second, et ainsi de suite pour chaque argument donné par la fonction. Il
possède également une propriété <a name="key33"></a><code>length</code>.</p><p>Cependant, cet objet n’est pas véritablement un tableau, il ne possède pas de
méthodes telles que <code>push</code> et il ne met pas à jour automatiquement sa propriété
<code>length</code> quand vous lui ajoutez quelque chose. Pourquoi n’est-ce pas le cas&nbsp;?
Je n’ai jamais vraiment compris l’utilité de tout cela, mais c’est quelque
chose dont vous devez avoir connaissance.</p><pre class="code"><span class="keyword">function</span> <span class="variable">compteurArgument</span>() {
  <span class="variable">print</span>(<span class="string">&quot;Vous m’avez donné &quot;</span>, <span class="localvariable">arguments</span>.<span class="property">length</span>, <span class="string">&quot; arguments.&quot;</span>);
}
<span class="variable">compteurArgument</span>(<span class="string">&quot;Mort&quot;</span>, <span class="string">&quot;Famine&quot;</span>, <span class="string">&quot;Fléau&quot;</span>);</pre><p>Certaines fonctions peuvent prendre nombre quelconque d’arguments, comme par
exemple la fonction <code>print</code>. Cette fonction particulière opère une boucle sur
les valeurs des <code>arguments</code> d’un objet pour en faire quelque chose. D’autres
peuvent prendre des arguments de manière optionnelle qui sont initialisés à une
valeur par défaut sensée si l’utilisateur ne fournit pas de valeur.</p><pre class="code"><span class="keyword">function</span> <span class="variable">ajouter</span>(<span class="variabledef">nombre</span>, <span class="variabledef">combien</span>) {
   <span class="keyword">if</span> (<span class="localvariable">arguments</span>.<span class="property">length</span> &lt; <span class="atom">2</span>)
     <span class="localvariable">combien</span> = <span class="atom">1</span>;
   <span class="keyword">return</span> <span class="localvariable">nombre</span> + <span class="localvariable">combien</span>;
}

<span class="variable">show</span>(<span class="variable">ajouter</span>(<span class="atom">6</span>));
<span class="variable">show</span>(<span class="variable">ajouter</span>(<span class="atom">6</span>, <span class="atom">4</span>));</pre></div><hr/><div class="block"><a name="exercise10"></a><div class="exercisenum">Ex. 4.10</div><div class="exercise"><p>Étendez la fonction <code>serie</code> de l’<a href="chapter4.html#exercise2">exercice 4.2</a> pour prendre un second argument,
optionnel. Si un seul argument est donné à la fonction, elle se comporte comme
précédemment et produit une série commençant à 0 jusqu’au nombre donné. Si deux
arguments sont donnés, le premier indique le début de la série, le second la
fin.</p></div><div class="solution"><pre class="code"><span class="keyword">function</span> <span class="variable">serie</span>(<span class="variabledef">debut</span>, <span class="variabledef">fin</span>) {
  <span class="keyword">if</span> (<span class="localvariable">arguments</span>.<span class="property">length</span> &lt; <span class="atom">2</span>) {
    <span class="localvariable">fin</span> = <span class="localvariable">debut</span>;
    <span class="localvariable">debut</span> = <span class="atom">0</span>;
  }
  <span class="keyword">var</span> <span class="variabledef">resultat</span> = [];
  <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">i</span> = <span class="localvariable">debut</span>; <span class="localvariable">i</span> &lt;= <span class="localvariable">fin</span>; <span class="localvariable">i</span>++)
    <span class="localvariable">resultat</span>.<span class="property">push</span>(<span class="localvariable">i</span>);
  <span class="keyword">return</span> <span class="localvariable">resultat</span>;
}

<span class="variable">show</span>(<span class="variable">serie</span>(<span class="atom">4</span>));
<span class="variable">show</span>(<span class="variable">serie</span>(<span class="atom">2</span>, <span class="atom">4</span>));</pre><p>L’argument optionnel ne fonctionne pas exactement comme celui de l’exemple
<code>ajouter</code> ci-dessus. Quand il n’est pas précisé, le premier argument prend le
rôle de <code>fin</code> et <code>debut</code> devient <code>0</code>.  </p></div></div><hr/><div class="block"><a name="exercise11"></a><div class="exercisenum">Ex. 4.11</div><div class="exercise"><p>Vous devez vous rappeler la ligne de code citée en introduction :</p><pre class="code invalid"><span class="variable">print</span>(<span class="variable">somme</span>(<span class="variable">serie</span>(<span class="atom">1</span>, <span class="atom">10</span>)));</pre><p>Nous avons la fonction <code>serie</code> maintenant. Tout ce dont nous avons besoin pour
faire fonctionner cette ligne est une fonction <code>somme</code>. Cette fonction prend un
tableau de nombre en arguments et retourne leur somme. Écrivez-la, ce devrait
être simple.</p></div><div class="solution"><pre class="code"><span class="keyword">function</span> <span class="variable">somme</span>(<span class="variabledef">nombres</span>) {
  <span class="keyword">var</span> <span class="variabledef">total</span> = <span class="atom">0</span>;
  <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">i</span> = <span class="atom">0</span>; <span class="localvariable">i</span> &lt; <span class="localvariable">nombres</span>.<span class="property">length</span>; <span class="localvariable">i</span>++)
    <span class="localvariable">total</span> += <span class="localvariable">nombres</span>[<span class="localvariable">i</span>];
  <span class="keyword">return</span> <span class="localvariable">total</span>;
}

<span class="variable">print</span>(<span class="variable">somme</span>(<span class="variable">serie</span>(<span class="atom">1</span>, <span class="atom">10</span>)));</pre></div></div><hr/><div class="block"><p>Le <a href="chapter2.html">chapitre 2</a> nous a permis d’étudier les fonctions <code>Math.max</code> et <code>Math.min</code>.
Avec ce que vous connaissez maintenant, vous pourrez noter que <code>max</code> et <code>min</code>
sont déjà les propriétés d’un objet enregistré sous le nom de <code>Math</code>. Voici un
autre rôle que les objets peuvent jouer : celui d’entrepôt pour un grand nombre
de valeurs liées.  </p><p>Il y a beaucoup de valeurs dans <code>Math</code>, si elles avaient été placées
directement dans l’environnement global, elles l’auraient, comme on dit,
pollué. Plus il y a de noms utilisés, plus il est probable d’écraser par
accident la valeur d’une variable. Par exemple, il n’est pas incongru de
vouloir nommer une variable <code>max</code>.</p><p>La plupart des langages vous arrêteront, ou du moins vous alerteront, quand
vous définirez une variable avec un nom déjà utilisé par l’environnement. Pas
JavaScript.</p><p>De toute façon, on peut trouver tout un ensemble de fonctions mathématiques et
de constantes dans <code>Math</code>. Toutes les fonctions trigonométriques sont présentes
: <code>cos</code>, <code>sin</code>, <code>tan</code>, <code>acos</code>, <code>asin</code> et <code>atan</code>. π et e, qui sont écrits en
capitales (<code>PI</code> et <code>E</code>), ce qui était à une époque une façon très à la mode
d’indiquer que quelque chose est une constante. <code>pow</code> est un bon moyen de
substitution des fonctions <code>puissance</code> que nous avons écrites, il accepte les
exposants négatifs et fractionnels. <code>sqrt</code> extrait la racine carrée d’un
nombre. <code>max</code> et <code>min</code> peuvent donner le maximum ou le minimum de deux valeurs.
<a name="key34"></a><a name="key35"></a><a name="key36"></a><code>round</code>, <code>floor</code>, et <code>ceil</code> vont
respectivement arrondir un nombre à l’entier le plus proche, à l’entier
inférieur et supérieur le plus proche.</p><p>Il existe un grand nombre d’autres valeurs dans <code>Math</code>, mais ce texte est une
introduction, pas une <a name="key37"></a>référence. Les références sont ce que vous consultez
lorsque vous soupçonnez qu’il existe quelque chose dans un langage, mais avez
besoin de savoir comment ça s’appelle ou comment ça marche au juste.
Malheureusement, il n’existe aucune référence totalement exhaustive pour le
JavaScript. C’est essentiellement parce que sa forme courante est la résultante
d’un processus chaotique pendant lequel différents navigateurs lui ont ajouté
diverses extensions à différentes périodes. Le document standard ECMA,
mentionné dans l’introduction, fournit une solide documentation du langage de
base, mais il est plus ou moins lisible. Pour la plupart de vos questions, vous
pouvez compter sur le <a href="https://developer.mozilla.org/fr/JavaScript/">Mozilla Developer Network</a>.</p></div><hr/><div class="block"><p>Vous avez peut-être déjà pensé à un moyen de découvrir ce qui est disponible
avec l’objet <code>Math</code> :</p><pre class="code"><span class="keyword">for</span> (<span class="keyword">var</span> <span class="variable">nom</span> <span class="keyword">in</span> <span class="variable">Math</span>)
  <span class="variable">print</span>(<span class="variable">nom</span>);</pre><p>Mais hélas, rien n’apparaît. De même, quand vous faites ceci :</p><pre class="code"><span class="keyword">for</span> (<span class="keyword">var</span> <span class="variable">nom</span> <span class="keyword">in</span> [<span class="string">&quot;Huey&quot;</span>, <span class="string">&quot;Dewey&quot;</span>, <span class="string">&quot;Loui&quot;</span>])
  <span class="variable">print</span>(<span class="variable">nom</span>);</pre><p>Vous ne voyez que <code>0</code>, <code>1</code>, et <code>2</code>, pas <code>length</code>, ni <code>push</code>, ou <code>join</code>, qui s’y
trouvent pourtant bel et bien. Apparemment, certaines propriétés des objets
sont cachées<a name="key38"></a>. Il y a une bonne raison à ça : tous les objets
ont quelques méthodes, par exemple <a name="key39"></a><code>toString</code> qui convertit l’objet en une
sorte de chaîne pertinente, mais vous ne souhaiterez sûrement pas les voir
quand vous êtes par exemple, à la recherche des chats que vous avez stockés
dans l’objet.</p><p>Pourquoi les propriétés de <code>Math</code> sont-elles cachées&nbsp;? Ce n’est pas très clair
pour moi. Il y a sûrement quelqu’un qui a voulu en faire un type d’objet
mystérieux.</p><p>Toutes les propriétés que vos programmes ajoutent aux objets sont visibles. Il
n’y a pas moyen de les cacher, ce qui est regrettable parce que, comme vous le
verrez dans le <a href="chapter8.html">chapitre 8</a>, il serait sympa d’ajouter des méthodes aux objets sans
avoir à les rendre visibles dans des boucles <code>for</code>/<code>in</code>.</p></div><hr/><div class="block"><p><a name="key40"></a>Certaines propriétés sont en lecture seule, vous
pouvez récupérer leur valeur mais pas la modifier. Par exemple, les propriétés
d’une valeur de chaîne sont toutes en lecture seule.</p><p>D’autres propriétés sont &quot;actives&quot;. Modifier leur valeur a des conséquences.
Par exemple, le fait de diminuer la longueur d’un tableau provoque la
disparition des éléments en trop:</p><pre class="code"><span class="keyword">var</span> <span class="variable">tableau</span> = [<span class="string">&quot;Ciel&quot;</span>, <span class="string">&quot;Terre&quot;</span>, <span class="string">&quot;Homme&quot;</span>];
<span class="variable">tableau</span>.<span class="property">length</span> = <span class="atom">2</span>;
<span class="variable">show</span>(<span class="variable">tableau</span>);</pre></div><ol class="footnotes"><li><a name="footnote1"></a>Il y a quelques problèmes subtils avec cette approche dont nous parlerons et
que nous résoudrons dans le <a href="chapter8.html">chapitre 8</a>. On ne s’en occupera pas pour ce chapitre.</li><li><a name="footnote2"></a>NdT: les mots <code>foo</code> et <code>bar</code> n’ont pas de signification précise, et
illustrent parfois des exemples de code.</li></ol><h1><span class="number">Chapitre 5: </span>Gestion des erreurs</h1><div class="block"><p>Écrire des programmes qui fonctionnent quand tout se passe comme prévu, c’est
un bon point de départ. Mais vous arranger pour que vos programmes se
comportent de façon acceptable dans des circonstances inattendues, cela devient
un véritable défi.</p><p>Les situations problématiques qu’un programme peut rencontrer se classent en
deux catégories : les erreurs du développeur et les réels problèmes. Si
quelqu’un oublie de passer un argument requis à une fonction, c’est un exemple
de la première catégorie. En revanche, si un programme demande à l’utilisateur
de saisir un nom et qu’il obtient en retour une chaîne vide, il s’agit d’un
problème que le développeur ne peut pas empêcher.</p><p>En général, on traite les erreurs du développeur en les cherchant et en les
corrigeant, et pour les erreurs réelles, en faisant en sorte que le code les
vérifie et effectue l’action appropriée pour y remédier (par exemple en
redemandant le nom de l’utilisateur), ou au moins en échouant de façon bien
définie et propre.</p></div><hr/><div class="block"><p>Il est important de décider de quelle catégorie un certain problème peut
relever. Par exemple, reprenons notre ancienne fonction <code>puissance</code> :</p><pre class="code"><span class="keyword">function</span> <span class="variable">puissance</span>(<span class="variabledef">base</span>, <span class="variabledef">exposant</span>) {
  <span class="keyword">var</span> <span class="variabledef">resultat</span> = <span class="atom">1</span>;
  <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">compteur</span> = <span class="atom">0</span>; <span class="localvariable">compteur</span> &lt; <span class="localvariable">exposant</span>; <span class="localvariable">compteur</span>++)
    <span class="localvariable">resultat</span> *= <span class="localvariable">base</span>;
  <span class="keyword">return</span> <span class="localvariable">resultat</span>;
}</pre><p>Quand un geek essaie d’appeler <code>puissance(&quot;Lapin&quot;, 4)</code>, c’est de toute évidence
une erreur du développeur, mais qu’en est-il de <code>power(9, 0.5)</code>&nbsp;? La fonction
ne sait pas manipuler des exposants sous forme de fraction, mais
mathématiquement parlant, élever un nombre à la puissance 1/2 est parfaitement
raisonnable (<a name="key1"></a><code>Math.pow</code> sait le faire). Dans des situations où le type de
saisie que peut accepter une fonction n’est pas totalement clair, il est
préférable de préciser explicitement le type d’arguments acceptables dans un
commentaire.</p></div><hr/><div class="block"><p>Si une fonction rencontre un problème qu’elle ne peut résoudre par elle-même,
que doit-elle faire&nbsp;? Dans le <a href="chapter4.html">chapitre 4</a>, nous avons écrit la fonction
<code>extraireChaineEntre</code> :</p><pre class="code"><span class="keyword">function</span> <span class="variable">extraireChaineEntre</span>(<span class="variabledef">chaine</span>, <span class="variabledef">debut</span>, <span class="variabledef">fin</span>) {
  <span class="keyword">var</span> <span class="variabledef">indexDebut</span> = <span class="localvariable">chaine</span>.<span class="property">indexOf</span>(<span class="localvariable">debut</span>) + <span class="localvariable">debut</span>.<span class="property">length</span>;
  <span class="keyword">var</span> <span class="variabledef">indexFin</span> = <span class="localvariable">chaine</span>.<span class="property">indexOf</span>(<span class="localvariable">fin</span>, <span class="localvariable">indexDebut</span>);
  <span class="keyword">return</span> <span class="localvariable">chaine</span>.<span class="property">slice</span>(<span class="localvariable">indexDebut</span>, <span class="localvariable">indexFin</span>);
}</pre><p>Si <code>debut</code> et <code>fin</code> donnés en argument n’apparaissent pas dans la chaîne,
<code>indexOf</code> renverra <code>-1</code> et cette version de <code>extraireChaineEntre</code> retournera
des absurdités : <code>extraireChaineEntre(&quot;Île déserte&quot;, &quot;{-&quot;, &quot;-}&quot;)</code> renvoie <code>&quot;le
désert&quot;</code>.</p><p>Quand le programme s’exécute et que la fonction est appelée ainsi, le code qui
l’a appelé obtiendra une chaîne, comme prévu, et continuera joyeusement à la
manipuler. Mais la valeur est erronée, donc quel que soit le résultat obtenu,
il sera faux. Et si vous êtes malchanceux, cette erreur ne provoquera de
problème qu’après avoir été passée à une vingtaine d’autres fonctions. Dans des
cas comme celui-ci, il est extrêmement difficile de trouver où le problème a
débuté.</p><p>Dans certains cas, vous ne serez absolument pas concerné par ce genre de
problème et vous n’aurez que faire du mauvais comportement de la fonction
lorsqu’elle reçoit un mauvais type d’argument. Par exemple, si vous êtes sûr
qu’une fonction ne sera appelée qu’à quelques endroits et que vous pouvez
prouver que ces endroits ne fournissent que le bon type d’argument, ça ne vaut
alors généralement pas le coup de faire grossir la fonction et de la rendre
plus moche pour qu’elle puisse traiter des cas problématiques.</p><p>Mais la plupart du temps, les fonctions qui échouent «&nbsp;silencieusement&nbsp;» sont
difficiles à utiliser, et même dangereuses. Que se passe-t-il si le code
appelant <code>extraireChaineEntre</code> veut savoir si tout s’est bien passé&nbsp;? Sur le
moment, il ne peut le dire, sauf à refaire tout le travail qu’a effectué
<code>extraireChaineEntre</code> et à vérifier le résultat de <code>extraireChaineEntre</code> par
rapport au sien. Ce qui n’est pas terrible. Une solution serait de faire
renvoyer par <code>extraireChaineEntre</code> une valeur spéciale telle que <code>false</code> ou
<code>undefined</code> quand elle échoue.</p><pre class="code"><span class="keyword">function</span> <span class="variable">extraireChaineEntre</span>(<span class="variabledef">chaine</span>, <span class="variabledef">debut</span>, <span class="variabledef">fin</span>) {
  <span class="keyword">var</span> <span class="variabledef">indexDebut</span> = <span class="localvariable">chaine</span>.<span class="property">indexOf</span>(<span class="localvariable">debut</span>);
  <span class="keyword">if</span> (<span class="localvariable">indexDebut</span> == -<span class="atom">1</span>)
    <span class="keyword">return</span> <span class="atom">undefined</span>;
  <span class="localvariable">indexDebut</span> += <span class="localvariable">debut</span>.<span class="property">length</span>;
  <span class="keyword">var</span> <span class="variabledef">indexFin</span> = <span class="localvariable">chaine</span>.<span class="property">indexOf</span>(<span class="localvariable">fin</span>, <span class="localvariable">indexDebut</span>);
  <span class="keyword">if</span> (<span class="localvariable">indexFin</span> == -<span class="atom">1</span>)
    <span class="keyword">return</span> <span class="atom">undefined</span>;

  <span class="keyword">return</span> <span class="localvariable">chaine</span>.<span class="property">slice</span>(<span class="localvariable">indexDebut</span>, <span class="localvariable">indexFin</span>);
}</pre><p>Vous pouvez voir que les vérifications d’erreurs ne rendent généralement pas
les fonctions plus jolies. Mais maintenant, le code qui appelle
<code>extraireChaineEntre</code> peut faire quelque chose comme :</p><pre class="code"><span class="keyword">var</span> <span class="variable">saisie</span> = <span class="variable">prompt</span>(<span class="string">&quot;Dites-moi quelque chose&quot;</span>, <span class="string">&quot;&quot;</span>);
<span class="keyword">var</span> <span class="variable">entreParentheses</span> = <span class="variable">extraireChaineEntre</span>(<span class="variable">saisie</span>, <span class="string">&quot;(&quot;</span>, <span class="string">&quot;)&quot;</span>);
<span class="keyword">if</span> (<span class="variable">entreParentheses</span> != <span class="atom">undefined</span>)
  <span class="variable">print</span>(<span class="string">&quot;Vous avez mis entre parenthèses '&quot;</span>, <span class="variable">entreParentheses</span>, <span class="string">&quot;'.&quot;</span>);</pre></div><hr/><div class="block"><p>Dans beaucoup de cas, renvoyer une valeur spéciale est une façon tout à fait
appropriée pour indiquer une erreur. Il y a malheureusement un revers à la
médaille. D’abord, que se passe-t-il si la fonction peut déjà renvoyer toutes
sortes de valeurs possibles&nbsp;? Par exemple, prenons cette fonction qui récupère
le dernier élément d’un tableau :</p><pre class="code"><span class="keyword">function</span> <span class="variable">dernierElement</span>(<span class="variabledef">tableau</span>) {
  <span class="keyword">if</span> (<span class="localvariable">tableau</span>.<span class="property">length</span> &gt; <span class="atom">0</span>)
    <span class="keyword">return</span> <span class="localvariable">tableau</span>[<span class="localvariable">tableau</span>.<span class="property">length</span> - <span class="atom">1</span>];
  <span class="keyword">else</span>
    <span class="keyword">return</span> <span class="atom">undefined</span>;
}

<span class="variable">show</span>(<span class="variable">dernierElement</span>([<span class="atom">1</span>, <span class="atom">2</span>, <span class="atom">undefined</span>]));</pre><p>Le tableau avait-il un dernier élément&nbsp;? En regardant la valeur que renvoie
<code>dernierElement</code>, c’est impossible à dire. Le second problème quand on renvoie
des valeurs spéciales, c’est que cela peut conduire à créer pas mal de bazar.
Si une partie de code appelle <code>extraireChaineEntre</code> dix fois, elle doit
vérifier dix fois si <code>undefined</code> a été retourné. De même, si une fonction
appelle <code>extraireChaineEntre</code>, mais n’a pas de stratégie pour gérer un éventuel
échec, elle devra vérifier la valeur renvoyée par <code>extraireChaineEntre</code>, et si
c’est <code>undefined</code>, cette fonction peut alors renvoyer <code>undefined</code> ou une autre
valeur spéciale à sa fonction appelante, qui à son tour vérifiera cette valeur.</p><p>Parfois, quand quelque chose de bizarre se passe, il serait pratique d’arrêter
ce que l’on est en train de faire, et de revenir immédiatement à un endroit où
le problème peut être réglé.</p><p>Nous avons de la chance. Beaucoup de langages de programmation fournissent de
tels mécanismes. C’est ce qu’on appelle généralement la <a name="key2"></a>gestion des
exceptions.</p></div><hr/><div class="block"><p>La théorie derrière la gestion des exceptions fonctionne ainsi : il est
possible pour le code de <a name="key3"></a>lever (ou <a name="key4"></a>lancer) une <a name="key5"></a>exception, qui est une
valeur. Quand on lève une exception, cela ressemble parfois à un retour de
fonction boosté aux stéroïdes : on ne sort pas simplement de la fonction en
cours, mais aussi des fonctions appelantes, en retournant jusqu’au niveau qui a
démarré l’exécution actuelle. Cela s’appelle <a name="key6"></a>dépiler. Vous vous rappelez
peut-être la <a name="key7"></a>pile des appels de fonction qui avait été abordée au
<a href="chapter3.html">chapitre 3</a>. Une exception descend dans cette pile, en renvoyant tous les
contextes des appels qu’elle rencontre.</p><p>Si elles descendaient sans s’arrêter jusqu’au bas de la pile, les exceptions ne
seraient pas d’un grand intérêt, elles fourniraient juste un moyen original de
détruire le programme. Heureusement, il est possible de dresser des obstacles
aux exceptions le long de la pile. Ceux-ci «&nbsp;<a name="key8"></a>interceptent&nbsp;»
l’exception quand elle descend, et ils peuvent la prendre en charge, après quoi
le programme continue de fonctionner normalement à partir du point où
l’exception a été attrapée.</p><p>Un exemple :</p><pre class="code"><span class="keyword">function</span> <span class="variable">dernierElement</span>(<span class="variabledef">tableau</span>) {
  <span class="keyword">if</span> (<span class="localvariable">tableau</span>.<span class="property">length</span> &gt; <span class="atom">0</span>)
    <span class="keyword">return</span> <span class="localvariable">tableau</span>[<span class="localvariable">tableau</span>.<span class="property">length</span> - <span class="atom">1</span>];
  <span class="keyword">else</span>
    <span class="keyword">throw</span> <span class="string">&quot;Impossible de prendre le dernier élément d’un tableau vide.&quot;</span>;
}

<span class="keyword">function</span> <span class="variable">dernierElementPlusDix</span>(<span class="variabledef">tableau</span>) {
  <span class="keyword">return</span> <span class="variable">dernierElement</span>(<span class="localvariable">tableau</span>) + <span class="atom">10</span>;
}

<span class="keyword">try</span> {
  <span class="variable">print</span>(<span class="variable">dernierElementPlusDix</span>([]));
}
<span class="keyword">catch</span> (<span class="variabledef">erreur</span>) {
  <span class="variable">print</span>(<span class="string">&quot;Une erreur est survenue : &quot;</span>, <span class="localvariable">erreur</span>);
}</pre><p><a name="key9"></a><code>throw</code> est le mot-clé qui est utilisé pour lever l’exception. Le mot-clé
<a name="key10"></a><code>try</code> pose un obstacle pour les exceptions : quand une exception est levée
dans le code du bloc suivant ce <a name="key11"></a><code>try</code>, le bloc <a name="key12"></a><code>catch</code> sera exécuté. La
variable nommée entre parenthèses après le mot <code>catch</code> est le nom donné à la
valeur d’exception à l’intérieur du bloc.</p><p>On remarque que la fonction <code>dernierElementPlusDix</code> ignore complètement la
possibilité que <code>dernierElement</code> ne fonctionne pas. C’est là le grand avantage
des exceptions, un code pour s’occuper de l’erreur n’est nécessaire qu’au
moment où l’erreur survient, et à l’endroit où on s’en occupe. Les fonctions
sur le chemin peuvent tout ignorer à ce sujet.</p><p>Enfin, presque.</p></div><hr/><div class="block"><p>Réfléchissez un instant à ceci : une fonction <code>faireDesTrucs</code> veut déclarer une
variable globale <code>trucEnCours</code> pour pointer vers quelque chose de spécifique
pendant que son corps exécute, de manière à ce que d’autres fonctions puissent
également y avoir accès. Normalement, vous passeriez simplement cette chose
comme un argument, mais imaginons l’espace d’un instant que ce n’est pas
possible en pratique. Quand la fonction se termine, <code>trucEnCours</code> devrait être
redéfinie avec une valeur <code>null</code>.</p><pre class="code"><span class="keyword">var</span> <span class="variable">trucEnCours</span> = <span class="atom">null</span>;

<span class="keyword">function</span> <span class="variable">faireDesTrucs</span>(<span class="variabledef">unTruc</span>) {
  <span class="keyword">if</span> (<span class="variable">trucEnCours</span> != <span class="atom">null</span>)
    <span class="keyword">throw</span> <span class="string">&quot;Oh non&nbsp;! Nous sommes déjà en train d’exécuter quelque chose&nbsp;!&quot;</span>;

  <span class="variable">trucEnCours</span> = <span class="localvariable">unTruc</span>;
  <span class="comment">/* faire des choses compliqués… */</span>
  <span class="variable">trucEnCours</span> = <span class="atom">null</span>;
}</pre><p>Mais que ce se passerait-il si cette opération compliquée lève une exception&nbsp;?
Dans ce cas, l’appel à <code>faireDesTrucs</code> sera rejeté en dehors de la pile par
l’exception, et <code>trucEnCours</code> n’aura pas de valeur redéfinie comme <code>null</code>.</p><p>Les instructions <code>try</code> peuvent aussi être suivies par un mot-clé <a name="key13"></a><code>finally</code>,
ce qui veut dire «&nbsp;quoi qu’il arrive, exécutez ce code après avoir essayé
d’exécuter ce code dans un bloc <code>try</code>&nbsp;». Si une fonction doit nettoyer quelque
chose, le code qui effectue ce nettoyage doit en général être inséré dans un
bloc <code>finally</code> :</p><pre class="code"><span class="keyword">function</span> <span class="variable">faireDesTrucs</span>(<span class="variabledef">unTruc</span>) {
  <span class="keyword">if</span> (<span class="variable">trucEnCours</span> != <span class="atom">null</span>)
    <span class="keyword">throw</span> <span class="string">&quot;Oh non&nbsp;! Nous sommes déjà en train d’exécuter quelque chose&nbsp;!&quot;</span>;

  <span class="variable">trucEnCours</span> = <span class="localvariable">unTruc</span>;
  <span class="keyword">try</span> {
    <span class="comment">/* faire des choses compliqués… */</span>
  }
  <span class="keyword">finally</span> {
    <span class="variable">trucEnCours</span> = <span class="atom">null</span>;
  }
}</pre></div><hr/><div class="block"><p>Beaucoup d’erreurs de programmation obligent l’environnement JavaScript à lever
des exceptions. Par exemple :</p><pre class="code"><span class="keyword">try</span> {
  <span class="variable">print</span>(<span class="variable">Yeti</span>);
}
<span class="keyword">catch</span> (<span class="variabledef">erreur</span>) {
  <span class="variable">print</span>(<span class="string">&quot;Intercepté : &quot;</span> + <span class="localvariable">erreur</span>.<span class="property">message</span>);
}</pre><p>Dans des cas comme celui-là, des objets spéciaux de type erreur sont levés. Ils
ont toujours une propriété <code>message</code> contenant une description du problème.
Vous pouvez lever des objets similaires en utilisant le mot-clé <code>new</code> et le
constructeur <a name="key14"></a><code>error</code> :</p><pre class="code"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="variable">Error</span>(<span class="string">&quot;Au feu&nbsp;!&quot;</span>);</pre></div><hr/><div class="block"><p>Quand une exception descend tout en bas de la pile sans être traitée, elle est
prise en charge par l’environnement. Ce que cela signifie diffère selon les
différents navigateurs, quelquefois une description de l’erreur est écrite sous
la forme d’une entrée de journal, d’autres fois une fenêtre décrivant l’erreur
apparaît.</p><p>Les erreurs générées par le code entré dans la console sur cette page sont
toujours attrapées par la console, et sont affichées avec les autres sorties de
la console.</p></div><hr/><div class="block"><p>La plupart des programmeurs considèrent les exceptions uniquement comme un
mécanisme de gestion des erreurs. Par essence, pourtant, elles représentent
seulement une autre manière d’influer sur le contrôle du flux d’un programme.
Par exemple, elles peuvent être utilisées comme une sorte d’instruction <code>break</code>
dans une fonction récursive. Voici une fonction un peu bizarre qui détermine si
un objet, ainsi que les autres objets stockés à l’intérieur, contiennent au
moins sept valeurs <code>true</code> :</p><pre class="code"><span class="keyword">var</span> <span class="variable">SeptValeursTrue</span> = {};

<span class="keyword">function</span> <span class="variable">contientSeptValeursTrue</span>(<span class="variabledef">objet</span>) {
  <span class="keyword">var</span> <span class="variabledef">compte</span> = <span class="atom">0</span>;

  <span class="keyword">function</span> <span class="variabledef">compter</span>(<span class="variabledef">objet</span>) {
    <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">nom</span> <span class="keyword">in</span> <span class="localvariable">objet</span>) {
      <span class="keyword">if</span> (<span class="localvariable">objet</span>[<span class="localvariable">nom</span>] === <span class="atom">true</span>) {
        <span class="localvariable">compte</span>++;
        <span class="keyword">if</span> (<span class="localvariable">compte</span> == <span class="atom">7</span>)
          <span class="keyword">throw</span> <span class="variable">SeptValeursTrue</span>;
      }
      <span class="keyword">else</span> <span class="keyword">if</span> (typeof <span class="localvariable">objet</span>[<span class="localvariable">nom</span>] == <span class="string">&quot;object&quot;</span>) {
        <span class="localvariable">compter</span>(<span class="localvariable">objet</span>[<span class="localvariable">nom</span>]);
      }
    }
  }

  <span class="keyword">try</span> {
    <span class="localvariable">compter</span>(<span class="localvariable">objet</span>);
    <span class="keyword">return</span> <span class="atom">false</span>;
  }
  <span class="keyword">catch</span> (<span class="variabledef">exception</span>) {
    <span class="keyword">if</span> (<span class="localvariable">exception</span> != <span class="variable">SeptValeursTrue</span>)
      <span class="keyword">throw</span> <span class="localvariable">exception</span>;
    <span class="keyword">return</span> <span class="atom">true</span>;
  }
}</pre><p>La fonction interne <code>compter</code> est appelée récursivement pour chaque objet qui
fait partie d’un argument. Quand la variable <code>compte</code> atteint sept, il n’y a
aucun intérêt à continuer de compter, mais se contenter de remonter de l’appel
courant à <code>compter</code> ne va pas nécessairement arrêter l’énumération, car il
pourrait y avoir plusieurs appels derrière. Donc ce que l’on fait c’est juste
lever une exception, ce qui obligera le contrôleur à rejeter tout appel, et à
se rendre au bloc <code>catch</code>.</p><p>Mais se contenter de retourner <code>true</code> dans le cas d’une exception n’est pas
correct. Quelque chose peut mal se passer, donc on vérifie d’abord si
l’exception est l’objet <code>SeptValeursTrue</code>, créé spécifiquement dans ce but. Si
ce n’est pas le cas, ce bloc <code>catch</code> ne sait pas comment s’en occuper, donc il
la lève encore.</p><p>On a ici un modèle qui est également habituel lorsqu’on s’occupe de conditions
d’erreur : vous devez vous assurez que votre bloc <code>catch</code> s’occupe seulement
des exceptions qu’il sait traiter. Lever des exceptions de type chaîne de
caractères, comme certains exemples de ce chapitre le font, est rarement une
bonne idée, car cela rend difficile de reconnaître le type de l’exception. Une
meilleure idée consiste à utiliser des valeurs uniques, comme l’objet
<code>SeptValeursTrue</code>, ou d’introduire un nouveau type d’objets, comme décrit dans
le <a href="chapter8.html">chapitre 8</a>.</p></div><h1><span class="number">Chapitre 6: </span>Programmation fonctionnelle</h1><div class="block"><p>Au fur et à mesure que les programmes prennent de l’ampleur, ils deviennent
plus complexes et plus durs à comprendre. Nous nous considérons tous comme
étant plutôt intelligents, bien sûr, mais nous ne sommes que des êtres humains
et même une petite dose de chaos peut nous laisser perplexes. Et ensuite cela
devient infernal. Travailler sur quelque chose que vous ne maîtrisez pas
vraiment, c’est un peu comme couper des fils au hasard sur une de ces bombes à
retardement que vous voyez dans les films. Si vous avez de la chance, vous
couperez le bon, particulièrement si vous êtes le héros du film et que vous
prenez une attitude héroïque, mais il y a toujours une possibilité de tout
faire sauter.</p><p>Je vous le concède, la plupart du temps, casser un programme ne va pas causer
une grosse explosion. Mais quand un programme qui a été trifouillé par
quelqu’un d’ignorant dégénère en un ramassis d’erreurs, remettre de l’ordre
dans le code est un travail de longue haleine, parfois il est aussi simple de
recommencer depuis le début.</p><p><a name="key1"></a>Ainsi, le développeur recherche toujours les moyens de faire un
code aussi simple que possible. Une manière importante d’y arriver c’est de
rendre le code plus abstrait. Quand on fait du code pour un programme, on se
perd très facilement dans des petits détails. Vous butez sur un petit problème,
vous vous penchez dessus et puis vous vous occupez du problème d’après et ainsi
de suite. Au final, on lit le code à la façon d’une recette de grand-mère.</p><blockquote>Oui, mon cher, pour faire de la soupe aux pois, vous aurez besoin de petits
pois, de type sec. Et vous devez les laisser tremper pour au moins une nuit,
ou vous devrez les faire cuire pendant des heures. Je me souviens une fois
quand mon idiot de fils a essayé de faire de la soupe de pois. Me
croirez-vous si je vous dis qu’il n’a pas fait tremper ses pois&nbsp;? Nous nous y
sommes tous presque cassé les dents. Bref, quand vous aurez trempé les pois,
il vous en faut à peu près une tasse par personne, faites attention car ils
prendront un peu de volume quand ils seront trempés, donc si vous ne prenez
pas garde, ils déborderont du contenant que vous avez choisi pour ce faire,
faites attention également d’utiliser beaucoup d’eau. Mais comme je vous l’ai
dit, il en faut à peu près une tasse et quand ils sont trempés, vous les
faites cuire avec 4 tasses d’eau pour une tasse de pois. Laissez-les mijoter
pendant deux heures, ce qui sous-entend que vous mettiez un couvercle et que
vous chauffiez à peine, et ensuite ajoutez des oignons coupés en dés, des
tiges de céleri, peut-être une ou deux carottes et un peu de jambon. Laissez
encore cuire pendant quelques minutes et après c’est prêt à être servi.</blockquote><p>Une autre façon de décrire la recette :</p><blockquote>Ingrédients par personne : une tasse de petits pois, un oignon coupé en
morceaux, une demi carotte, une tige de céleri et éventuellement du jambon.<br/><br/>Faites tremper les pois une nuit, faites-les mijoter pendant deux heures dans
4 tasses d’eau (par personne), ajoutez les légumes et le jambon, faites cuire
pendant dix minutes supplémentaires.</blockquote><p>C’est plus court, mais si vous ne savez pas comment faire tremper les pois,
vous raterez sûrement et les ferez tremper dans trop peu d’eau. Mais on peut
rechercher comment tremper les pois, et c’est ça la clé. Si vous partez du
principe que vos lecteurs ont des connaissances de base, vous pouvez recourir à
un langage pour mentionner des concepts plus larges et vous exprimer d’une
manière plus concise et plus claire. C’est plus ou moins ce que l’on veut dire
quand on parle d’abstraction.</p><p>En quoi est-ce que cette recette tirée par les cheveux a un lien avec la
programmation&nbsp;? Eh bien, évidemment, la recette est un programme. De surcroît,
la connaissance minimale que le cuisinier est supposé avoir correspond aux
fonctions et autres concepts qui sont accessibles aux codeurs. Si vous vous
rappelez de l’introduction à ce livre, des choses telles que <code>while</code> rendent la
construction de boucles plus faciles. Dans le <a href="chapter4.html">chapitre 4</a>, nous avons écrit des
fonctions simples afin de pouvoir écrire d’autres fonctions plus courtes et
plus directes. De tels outils, dont certains sont fournis par le langage
lui-même et d’autres conçus par le programmeur, sont utilisés de manière à
réduire le nombre de détails inutiles dans le reste du programme. Ce qui rend
le programme plus abordable pour travailler dessus.  </p></div><hr/><div class="block"><p>La <a name="key2"></a>programmation fonctionnelle, qui est le sujet qui nous intéresse dans ce
chapitre, produit des abstractions en combinant des fonctions de manière
astucieuse. Un codeur équipé d’un répertoire de fonctions fondamentales et,
plus important, maîtrisant les manières de les utiliser, est bien plus efficace
que quelqu’un qui commence à partir de zéro. Malheureusement, un environnement
JavaScript de base ne fournit que peu de fonctions essentielles, donc nous
devons les écrire nous-mêmes, ou, ce qui est souvent préférable, utiliser le
code de quelqu’un d’autre (plus de détails dans le <a href="chapter9.html">chapitre 9</a>).</p><p>Il y a d’autres approches plus populaires de l’abstraction, particulièrement la
programmation orientée objet, qui est le sujet du <a href="chapter8.html">chapitre 8</a>.</p><p>Il y a un détail fâcheux, si vous avez un peu de goût, qui doit commencer à
vous embêter, c’est la répétition incessante de boucles <code>for</code> dans certaines
matrices : <code>for (var i = 0; i &lt; quelqueChose.length; i++) …</code>. Est-ce qu’on peut
en faire une abstraction&nbsp;?</p><p>Le problème, c’est que si beaucoup de fonctions prennent seulement des valeurs,
les combinent et donnent un résultat, une telle boucle contient un bout de code
qu’elle doit exécuter. Il est facile d’écrire une fonction qui s’occupe d’une
matrice et affiche chaque élément :</p><pre class="code"><span class="keyword">function</span> <span class="variable">printArray</span>(<span class="variabledef">tableau</span>) {
  <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">i</span> = <span class="atom">0</span>; <span class="localvariable">i</span> &lt; <span class="localvariable">tableau</span>.<span class="property">length</span>; <span class="localvariable">i</span>++)
    <span class="variable">print</span>(<span class="localvariable">tableau</span>[<span class="localvariable">i</span>]);
}</pre><p>Mais qu’est-ce qu’on fait si on veut faire autre chose qu’afficher&nbsp;? Puisque «
faire quelque chose&nbsp;» peut être représenté par une fonction, et que les
fonctions sont aussi des valeurs, on peut fournir notre action comme une valeur
de type fonction :</p><pre class="code"><span class="keyword">function</span> <span class="variable">forEach</span>(<span class="variabledef">tableau</span>, <span class="variabledef">action</span>) {
  <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">i</span> = <span class="atom">0</span>; <span class="localvariable">i</span> &lt; <span class="localvariable">tableau</span>.<span class="property">length</span>; <span class="localvariable">i</span>++)
    <span class="localvariable">action</span>(<span class="localvariable">tableau</span>[<span class="localvariable">i</span>]);
}

<span class="variable">forEach</span>([<span class="string">&quot;Wampeter&quot;</span>, <span class="string">&quot;Foma&quot;</span>, <span class="string">&quot;Granfalloon&quot;</span>], <span class="variable">print</span>);</pre><p>Et en utilisant une fonction anonyme, quelque chose comme une boucle <code>for</code> peut
être écrite avec moins de détails inutiles.</p><pre class="code"><span class="keyword">function</span> <span class="variable">somme</span>(<span class="variabledef">nombres</span>) {
  <span class="keyword">var</span> <span class="variabledef">total</span> = <span class="atom">0</span>;
  <span class="variable">forEach</span>(<span class="localvariable">nombres</span>, <span class="keyword">function</span> (<span class="variabledef">nombre</span>) {
     <span class="localvariable">total</span> += <span class="localvariable">nombre</span>;
  });
  <span class="keyword">return</span> <span class="localvariable">total</span>;
}
<span class="variable">show</span>(<span class="variable">somme</span>([<span class="atom">1</span>, <span class="atom">10</span>, <span class="atom">100</span>]));</pre><p>Remarquez que la variable <code>total</code> est visible à l’intérieur de la fonction
anonyme, à cause des règles de portée des variables. Remarquez également que
cette version n’est pas vraiment plus courte que celle avec une boucle <code>for</code> et
nécessite l’écriture peu commode <code>});</code> à sa fin : l’accolade ferme le corps de
la fonction anonyme, la parenthèse ferme l’appel à la fonction <a name="key3"></a><code>forEach</code> et
le point virgule est nécessaire car cet appel est une instruction.</p><p>Vous obtenez une variable liée à l’élément en cours dans le tableau, <code>nombre</code>,
aussi vous n’avez plus besoin d’utiliser <code>nombres[i]</code>. Et quand ce tableau est
créé par l’évaluation d’une expression quelconque, il n’y a pas besoin de le
stocker dans une variable car cette expression peut être passée à <code>forEach</code>
directement.  </p><p>Le programme sur les chats dans le <a href="chapter4.html">chapitre 4</a> contient le morceau de code suivant:</p><pre class="preformatted">var paragraphes = archiveDeMessages[message].split(&quot;\n&quot;);
for (var i = 0; i &lt; paragraphes.length; i++)
  traiterParagraphe(paragraphes[i]);</pre><p>Il peut maintenant être écrit de la façon suivante :</p><pre class="preformatted">forEach(archiveDeMessages[message].split(&quot;\n&quot;), traiterParagraphe);</pre><p>Au final, une construction plus abstraite (ou «&nbsp;de plus haut niveau&nbsp;»)
correspond à plus d’informations et à moins de bruits parasites : Le code dans
la fonction <code>somme</code> se lit «&nbsp;<em>pour chaque nombre dans la liste des nombres,
ajouter ce nombre au total</em>&nbsp;», plutôt que : «&nbsp;<em>il y a une variable qui commence
à 0, et elle compte un par un jusqu’à atteindre le nombre d’élément d’un
tableau de nombres et à chaque valeur de cette variable, nous examinons
l’élément correspondant dans ce tableau et l’ajoutons au total</em>&nbsp;».</p></div><hr/><div class="block"><p><code>forEach</code> prend un algorithme, ici «&nbsp;parcourir un tableau&nbsp;» et de rendre
celui-ci abstrait. Les «&nbsp;trous&nbsp;» dans cet algorithme (ici : que faire pour
chacun des éléments du tableau), sont comblés par des fonctions passées à la
fonction algorithme.</p><p>Les fonctions qui opèrent sur d’autres fonctions sont appelées <a name="key4"></a>fonctions d’ordre supérieur. En opérant sur d’autres
fonctions, elles peuvent décrire des actions à un niveau supérieur. La fonction
<code>creerFonctionAjouter</code> dans le <a href="chapter3.html">chapitre 3</a> est aussi une fonction d’ordre
supérieur. Au lieu de prendre une valeur de fonction comme argument, elle
construit une nouvelle fonction.</p><p>Les fonctions d’ordre supérieur peuvent être utilisées pour généraliser de
nombreux algorithmes que des fonctions classiques ne peuvent pas facilement
décrire. Quand vous avez à votre disposition de telles fonctions, elles peuvent
vous aider à concevoir votre code avec une plus grande clarté : au lieu d’une
combinaison complexe de variables et de boucles, vous pouvez décomposer les
algorithmes en algorithmes plus fondamentaux, qui sont appelés par leur nom et
ne doivent pas être réécrits sans cesse.</p><p>Être en mesure d’écrire <em>ce que</em> nous voulons faire au lieu de <em>comment</em> nous
le faisons, c’est travailler à un niveau d’abstraction supérieur. En pratique,
cela implique un code plus concis, plus clair et plus agréable à lire.</p></div><hr/><div class="block"><p>Une autre catégorie utile de fonctions d’ordre supérieur <em>modifie</em> la fonction
qui lui est fournie :</p><pre class="code"><span class="keyword">function</span> <span class="variable">negate</span>(<span class="variabledef">func</span>) {
  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="variabledef">x</span>) {
    <span class="keyword">return</span> !<span class="localvariable">func</span>(<span class="localvariable">x</span>);
  };
}
<span class="keyword">var</span> <span class="variable">isNotNaN</span> = <span class="variable">negate</span>(<span class="variable">isNaN</span>);
<span class="variable">show</span>(<span class="variable">isNotNaN</span>(<span class="atom">NaN</span>));</pre><p>La fonction renvoyée par la fonction <code>negate</code> reçoit un argument qu’elle
fournit à la fonction initiale <code>func</code> et inverse son résultat. Mais si la
fonction que vous voulez inverser reçoit plus d’un argument&nbsp;? Vous pouvez
accéder à n’importe quels arguments passés à une fonction à l’aide du tableau
<code>arguments</code>, mais comment appeler une fonction quand vous ne savez pas combien
d’arguments vous avez&nbsp;?</p><p>Les fonctions ont une méthode nommée <a name="key5"></a><code>apply</code>, utilisée dans les situations de
ce type. Elle prend deux arguments. Le rôle du premier argument sera détaillé
dans le <a href="chapter8.html">chapitre 8</a>, pour le moment nous utiliserons <code>null</code> pour cet argument. Le
second argument est un tableau qui contient tous les arguments devant
s’appliquer à la fonction.</p><pre class="code"><span class="variable">show</span>(<span class="variable">Math</span>.<span class="property">min</span>.<span class="property">apply</span>(<span class="atom">null</span>, [<span class="atom">5</span>, <span class="atom">6</span>]));

<span class="keyword">function</span> <span class="variable">negate</span>(<span class="variabledef">func</span>) {
  <span class="keyword">return</span> <span class="keyword">function</span>() {
    <span class="keyword">return</span> !<span class="localvariable">func</span>.<span class="property">apply</span>(<span class="atom">null</span>, <span class="localvariable">arguments</span>);
  };
}</pre><p>Malheureusement, dans le navigateur Internet Explorer, différentes fonctions
prédéfinies comme <code>alert</code>, ne sont pas <em>vraiment</em> des fonctions… ni quoi que ce
soit. Elles indiquent un type <code>&quot;object&quot;</code> quand s’applique sur elles l’opérateur
<code>typeof</code> et n’ont pas de méthode <code>apply</code>. Vos propres fonctions n’ont pas cet
inconvénient, ce sont toujours de vraies fonctions.  </p></div><hr/><div class="block"><p>Jetons un œil maintenant à quelques algorithmes plus simples qui sont reliés
aux tableaux. La fonction <code>somme</code> est en fait une variante d’un algorithme qui
est habituellement appelé <a name="key6"></a><code>reduce</code> ou <code>fold</code> :</p><pre class="code"><span class="keyword">function</span> <span class="variable">reduce</span>(<span class="variabledef">combiner</span>, <span class="variabledef">base</span>, <span class="variabledef">tableau</span>) {
  <span class="variable">forEach</span>(<span class="localvariable">tableau</span>, <span class="keyword">function</span> (<span class="variabledef">element</span>) {
    <span class="localvariable">base</span> = <span class="localvariable">combiner</span>(<span class="localvariable">base</span>, <span class="localvariable">element</span>);
  });
  <span class="keyword">return</span> <span class="localvariable">base</span>;
}

<span class="keyword">function</span> <span class="variable">ajouter</span>(<span class="variabledef">a</span>, <span class="variabledef">b</span>) {
  <span class="keyword">return</span> <span class="localvariable">a</span> + <span class="localvariable">b</span>;
}

<span class="keyword">function</span> <span class="variable">somme</span>(<span class="variabledef">nombres</span>) {
  <span class="keyword">return</span> <span class="variable">reduce</span>(<span class="variable">ajouter</span>, <span class="atom">0</span>, <span class="localvariable">nombres</span>);
}</pre><p><code>reduce</code> convertit un tableau en une seule valeur en ayant recours de manière
répétée à une fonction qui combine un élément du tableau avec une valeur de
base. C’est exactement ce que fait la fonction <code>somme</code>, donc elle peut être
raccourcie par l’utilisation de <code>reduce</code>… sauf que l’addition est un opérateur
et non une fonction dans JavaScript, donc on doit d’abord la mettre dans une
fonction.</p><p>Il y a plusieurs raisons pour lesquelles <code>reduce</code> accepte cette fonction comme
premier argument et non comme dernier (contrairement à <code>forEach</code>). C'est d’une
part par tradition (d’autres langages ont ce fonctionnement) et d’autre part
pour permettre une astuce particulière, dont nous discuterons à la fin de ce
chapitre. Cela veut dire que lorsque l’on appelle <code>reduce</code>, écrire la fonction
de réduction comme une fonction anonyme semble un peu bizarre. Car maintenant
les arguments viennent après la fonction et on perd totalement la ressemblance
avec un bloc <code>for</code> normal.</p></div><hr/><div class="block"><a name="exercise1"></a><div class="exercisenum">Ex. 6.1</div><div class="exercise"><p>Écrivez une fonction <code>compterLesZeros</code> qui prend un tableau de nombres en
argument et qui renvoie le nombre de zéros qui sont rencontrés. Utilisez
<code>reduce</code>.</p><p>Puis, écrivez une fonction <code>count</code> de plus haut niveau qui accepte un tableau
et une fonction de test en tant qu’arguments, et qui donne en retour le nombre
d’éléments dans le tableau pour lesquels la fonction de test a renvoyé <code>true</code>. 
Écrivez de nouveau <code>compterLesZeros</code> en utilisant cette fonction.</p></div><div class="solution"><pre class="code"><span class="keyword">function</span> <span class="variable">compterLesZeros</span>(<span class="variabledef">tableau</span>) {
  <span class="keyword">function</span> <span class="variabledef">compteur</span>(<span class="variabledef">total</span>, <span class="variabledef">element</span>) {
    <span class="keyword">return</span> <span class="localvariable">total</span> + (<span class="localvariable">element</span> === <span class="atom">0</span> ? <span class="atom">1</span> : <span class="atom">0</span>);
  }
  <span class="keyword">return</span> <span class="variable">reduce</span>(<span class="localvariable">compteur</span>, <span class="atom">0</span>, <span class="localvariable">tableau</span>);
}</pre><p><a name="key7"></a> La partie bizarre, celle avec le point d’interrogation et les deux
points, utilise un nouvel opérateur. Dans le <a href="chapter2.html">chapitre 2</a>, nous avons vu les
opérateurs unaires et binaires. Celui-ci est ternaire : il agit sur trois
valeurs. Son fonctionnement ressemble à celui de <code>if</code>/<code>else</code>, sauf que là où
<code>if</code> exécute de manière conditionnelle des instructions, celui-ci choisit ses
expressions en fonction d’une condition. La première partie avant le point
d’interrogation est la condition. Si cette condition est <code>true</code>, l’expression
après le point d’interrogation est choisie, ici <code>1</code>. Si c’est <code>false</code>, la
partie après la virgule, ici <code>0</code>, est choisie.</p><p>L’utilisation de cet opérateur peut raccourcir efficacement des portions de
code. Quand les expressions à l’intérieur deviennent vraiment énormes, ou que
vous devez prendre plus de décisions à l’intérieur des portions pour les
conditions, la simple utilisation de <code>if</code> et <code>else</code> est habituellement plus
lisible.</p><p>Voici la solution qui utilise une fonction <code>count</code>, avec une fonction qui
inclut des tests d’égalité afin d’avoir au final une fonction <code>compterLesZeros</code>
encore plus courte.</p><pre class="code"><span class="keyword">function</span> <span class="variable">count</span>(<span class="variabledef">test</span>, <span class="variabledef">tableau</span>) {
  <span class="keyword">return</span> <span class="variable">reduce</span>(<span class="keyword">function</span>(<span class="variabledef">total</span>, <span class="variabledef">element</span>) {
    <span class="keyword">return</span> <span class="localvariable">total</span> + (<span class="localvariable">test</span>(<span class="localvariable">element</span>) ? <span class="atom">1</span> : <span class="atom">0</span>);
  }, <span class="atom">0</span>, <span class="localvariable">tableau</span>);
}

<span class="keyword">function</span> <span class="variable">equals</span>(<span class="variabledef">x</span>) {
  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="variabledef">element</span>) {<span class="keyword">return</span> <span class="localvariable">x</span> === <span class="localvariable">element</span>;};
}

<span class="keyword">function</span> <span class="variable">compterLesZeros</span>(<span class="variabledef">tableau</span>) {
  <span class="keyword">return</span> <span class="variable">count</span>(<span class="variable">equals</span>(<span class="atom">0</span>), <span class="localvariable">tableau</span>);
}</pre></div></div><hr/><div class="block"><p>Un autre «&nbsp;algorithme fondamental&nbsp;» généralement utile en lien avec les
tableaux porte le nom de <a name="key8"></a><code>map</code>. Il balaye un tableau, en exécutant une
fonction sur chaque élément, tout comme <code>forEach</code>. Mais au lieu d’ignorer les
valeurs de retour de la fonction, il construit un nouveau tableau contenant
chacune de ces valeurs.</p><pre class="code"><span class="keyword">function</span> <span class="variable">map</span>(<span class="variabledef">func</span>, <span class="variabledef">tableau</span>) {
  <span class="keyword">var</span> <span class="variabledef">resultat</span> = [];
  <span class="variable">forEach</span>(<span class="localvariable">tableau</span>, <span class="keyword">function</span> (<span class="variabledef">element</span>) {
    <span class="localvariable">resultat</span>.<span class="property">push</span>(<span class="localvariable">func</span>(<span class="localvariable">element</span>));
  });
  <span class="keyword">return</span> <span class="localvariable">resultat</span>;
}

<span class="variable">show</span>(<span class="variable">map</span>(<span class="variable">Math</span>.<span class="property">round</span>, [<span class="atom">0.01</span>, <span class="atom">2</span>, <span class="atom">9.89</span>, <span class="variable">Math</span>.<span class="property">PI</span>]));</pre><p>On remarque que le premier argument est appelé <code>func</code>, pas <code>function</code>. En
effet, <code>function</code> est un mot-clé et n’est par conséquent pas un nom de variable
recevable.</p></div><hr/><div class="block"><p>Il était une fois un ermite vivant dans les forêts reculées des montagnes de
Transylvanie. La plupart du temps, il ne faisait que se promener autour de sa
montagne pour parler aux arbres et rigoler avec les oiseaux. Mais de temps en
temps, quand la pluie torrentielle s’abattait sur sa petite hutte et que le
vent rugissant le faisait se sentir intolérablement trop petit, l’ermite
ressentait le besoin pressant d’écrire quelque chose, il voulait coucher ses
pensées sur du papier, là où elles pourraient peut-être devenir beaucoup plus
grandes que lui.</p><p>Après avoir échoué misérablement dans ses tentatives d’écrire de la poésie, de
la fiction, de la philosophie, l’ermite décida finalement d’écrire un livre
technique. Dans sa jeunesse, il avait fait de la programmation et il pensa que
s’il pouvait juste écrire un bon livre sur ce sujet, la célébrité et la
reconnaissance arriveraient sans doute après.</p><p>Donc il écrivit. D’abord il utilisa des morceaux d’écorce d’arbre, mais il
s’avéra que ce n’était pas pratique. Il descendit au village le plus proche, et
s’acheta un ordinateur portable. Après quelques chapitres, il réalisa qu’il
voulait convertir son livre au format HTML, afin de le télécharger vers sa page
personnelle en ligne…</p></div><hr/><div class="block"><p>Est-ce que vous connaissez le HTML&nbsp;? C’est la méthode utilisée pour ajouter du
formatage sur les pages des sites web et on l’utilisera de temps en temps dans
ce livre, donc ce serait bien si vous saviez comment cela fonctionne, au moins
de manière générale. Si vous êtes un bon étudiant, vous pourriez rechercher sur
Internet une introduction au HTML maintenant et revenir quand vous l’aurez lue.
La plupart d’entre vous sont sans doute des étudiants médiocres, donc je vais
juste donner une petite explication et j’espère que ce sera suffisant.</p><p><a name="key9"></a>HTML veut dire «&nbsp;HyperText Markup Language&nbsp;» (Langage à Balise Hyper Texte).
Un document HTML est entièrement en texte. Quelques caractères ont un sens
spécial pour pouvoir exprimer la structure de ce texte et spécifier quelle
donnée du texte est un titre, quelle partie du texte est en violet et ainsi de
suite, un peu comme les antislash (\) dans les chaînes JavaScript. Les signes «
inférieur&nbsp;» et «&nbsp;supérieur&nbsp;» sont utilisés pour créer des «&nbsp;<a name="key10"></a>balises&nbsp;». Une
balise apporte de l’information supplémentaire sur le document. Elle peut
fonctionner de manière autonome par exemple pour indiquer où doit apparaître
une image sur la page, ou elle peut contenir du texte et d’autres balises, par
exemple pour marquer le début et la fin des paragraphes.</p><p>Certaines balises sont obligatoires, un document HTML intégral doit toujours
tenir entre deux balises <code>html</code>. Voici un exemple d’un document HTML :</p><pre class="preformatted">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Une citation&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Une citation&lt;/h1&gt;
    &lt;blockquote&gt;
      &lt;p&gt;La connexion entre le langage dans lequel nous
pensons/programmons et les problèmes et solutions que nous pouvons
imaginer est très proche. Pour cette raison, restreindre les
capacités du langage dans l’intention d’éliminer les erreurs des
programmeurs est au mieux dangereuse.&lt;/p&gt;
      &lt;p&gt;-- Bjarne Stroustrup&lt;/p&gt;
    &lt;/blockquote&gt;
    &lt;p&gt;M. Stroustrup est l’inventeur du langage de programmation
C++, mais il est malgré tout une personne des plus perspicaces.&lt;/p&gt;
    &lt;p&gt;Aussi, voici une photo d’une autruche :&lt;/p&gt;
    &lt;img src=&quot;img/autruche.png&quot;/&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre><p>Des éléments qui contiennent du texte ou d’autres balises sont d’abord ouverts
avec <code>&lt;nomdebalise&gt;</code>, puis fermés par <code>&lt;/nomdebalise&gt;</code>. L’élément <code>html</code>
contient toujours deux enfants : <code>head</code> et <code>body</code>. Le premier contient des
informations <em>sur</em> le document, le second contient le document en lui-même.</p><p>La plupart des noms de balise sont des abréviations cryptiques. <code>h1</code> veut dire
«&nbsp;heading 1&nbsp;» (titre 1), le plus gros titre qu’il y ait. Il y a aussi <code>h2</code>
jusqu’à <code>h6</code> pour des titres de plus en plus petits. <code>p</code> veut dire «&nbsp;paragraphe
», et <code>img</code> veut dire «&nbsp;image&nbsp;». L’élément <code>img</code> ne contient pas de texte ou de
balise, mais il contient une information supplémentaire
(<code>src=&quot;img/autruche.png&quot;</code>) qui est appelée un «&nbsp;<a name="key11"></a>attribut&nbsp;». Dans ce cas, il
contient une information sur le fichier de l’image qui devrait être affichée ici.</p><p>Parce que <code>&lt;</code> et <code>&gt;</code> ont un sens spécial dans les documents HTML, ils ne
peuvent être écrits directement dans le texte du document. Si vous voulez dire
«&nbsp;5 &lt; 10&nbsp;» dans un document HTML, vous devez écrire «&nbsp;<code>5 &amp;lt;&nbsp;10</code>&nbsp;», où «&nbsp;<code>&amp;lt</code>
» veut dire «&nbsp;moins que&nbsp;». «&nbsp;<code>&amp;gt;</code>&nbsp;» est utilisé pour «&nbsp;<code>&gt;</code>&nbsp;» et parce que ces
codes donnent aussi à l’esperluette un sens spécial, un simple «&nbsp;<code>&amp;</code>&nbsp;» est
écrit «&nbsp;<code>&amp;amp;</code>&nbsp;».</p><p>Maintenant, ce ne sont que les bases de l’HTML, mais elles devraient être
suffisantes pour pouvoir suivre les explications dans ce chapitre, ainsi que
les chapitres suivants qui traitent des documents HTML, sans trop se perdre en
chemin.</p></div><hr/><div class="block"><p>La console JavaScript a une fonction <code>viewHTML</code> qui peut être utilisée pour
voir des documents HTML. J’ai stocké le document de l’exemple ci-dessus dans
<code>citationDeBjarneStroustrup</code>, on peut donc le voir en exécutant ce code :</p><pre class="code"><span class="variable">viewHTML</span>(<span class="variable">citationDeBjarneStroustrup</span>);</pre><p>Si vous avez un genre de bloqueur de fenêtres pop-up installé ou intégré dans
votre navigateur, il interférera probablement avec <code>viewHTML</code>, qui essayera de
montrer le document HTML dans une nouvelle fenêtre ou un nouvel onglet. Essayez
de configurer votre bloqueur pour autoriser les pop-ups de ce site.</p></div><hr/><div class="block"><p>Donc, pour en revenir à notre histoire, l’ermite voulait avoir son livre au
format HTML. D’abord il a juste écrit toutes les balises directement dans le
manuscrit, mais taper tous ces signes inférieur et supérieur lui a donné mal
aux doigts à la fin et il oubliait sans arrêt d’écrire <code>&amp;amp;</code> quand il avait
besoin d’un <code>&amp;</code>. Celui lui donna mal à la tête. Ensuite il essaya d’écrire son
livre dans Microsoft Word et de le sauver en HTML. Mais le HTML qui était
produit était quinze fois plus gros et plus compliqué que ce qu’il devait être.
Et en plus Microsoft Word lui donnait mal au crâne.</p><p>La solution sur laquelle il s’arrêta était finalement celle-ci : il écrirait ce
livre en texte simple, en suivant quelques règles simples pour la façon dont
les paragraphes devraient être séparés et l’aspect que devraient avoir les
titres. Puis il écrirait un programme pour convertir le texte en HTML
précisément comme il le souhaitait.</p><p>Les règles sont celles-ci :</p><ol><li>Les paragraphes sont séparés par des lignes vides.</li><li>Un paragraphe qui commence par le symbole «&nbsp;%&nbsp;» est un titre. Plus il y a de symboles «&nbsp;%&nbsp;», plus le titre est petit.</li><li>À l’intérieur des paragraphes, des morceaux de texte peuvent être mis en emphase en les encadrant par des astérisques.</li><li>Les notes de bas de page sont entre accolades.</li></ol></div><hr/><div class="block"><p>Après qu’il eut lutté durement avec son livre pendant six mois, l’ermite
n’avait fini que quelques paragraphes. À ce moment-là, sa cabane fut frappée
par un éclair, le tuant et mettant fin à jamais à ses ambitions d’écrivain.
Dans les débris carbonisés de son ordinateur portable, j’ai pu récupérer le
fichier suivant :</p><pre class="preformatted">% Le livre de la programmation

%% Les deux points de vue

Sous la surface de la machine, le programme évolue. Sans effort, il prend de
l’ampleur et se contracte. Avec beaucoup d’harmonie, les électrons se
dispersent et se regroupent. Les formes sur le moniteur ne sont que l’écume
de la vague.

Quand les créateurs ont construit la machine, ils y ont mis un processeur et
de la mémoire. À partir de là surgissent les deux points de vue sur le
programme.

Du côté du processeur, l’élément actif est appelé Contrôle. Du côté de la
mémoire, l’élément passif est appelé Données.

Les données sont faites de simples bits, et pourtant elles prennent des
formes complexes. Le contrôle consiste en de simples instructions et pourtant
il exécute des tâches difficiles, de la plus petite et la plus triviale, à la
plus grande et la plus compliquée.

Le programme source est la donnée. Le Contrôle y naît. Le Contrôle va ensuite
s’employer à créer de nouvelles données. L’un naît de l’autre, l’un ne sert à
rien sans l’existence de l’autre. C’est le cycle harmonieux des Données et du
Contrôle.

Par nature, les Données et le Contrôle sont sans structure. Les programmeurs
de la vieille école mijotaient leurs programmes à partir de cette soupe
primitive. Le temps passant, les Données amorphes se sont cristallisées en de
nouveaux types de données et le Contrôle chaotique a été restreint aux
structures de contrôle et aux fonctions.

%% Petits proverbes

Quand un étudiant a questionné Fu-Tzu sur la nature du cycle des Données et
du Contrôle, Fu-Tzu répondit «&nbsp;Pensez à un compilateur en train d’essayer de
se compiler.&nbsp;»

Un étudiant demanda : «&nbsp;Les programmeurs de la vieille école utilisaient des
machines simples et pas de langages de programmation et pourtant ils
concevaient de beaux programmes. Pourquoi utilisons-nous des machines
compliquées et des langages de programmation&nbsp;?&nbsp;» Fu-Tzu répondit : «&nbsp;Les
bâtisseurs d’autrefois utilisaient seulement des bâtons et de l’argile et
pourtant ils faisaient des cabanes magnifiques.&nbsp;»

Un ermite passa dix ans à écrire un programme. «&nbsp;Mon programme peut calculer
le mouvement des étoiles sur un ordinateur 286 qui fait tourner MS-DOS&nbsp;»
annonça-t-il fièrement. «&nbsp;Personne ne possède un ordinateur 286 ou ne
l’utilise aujourd’hui&nbsp;» répondit-il.

Fu-Tzu avait écrit un petit programme qui était plein de variables globales
et de raccourcis douteux. En le lisant, un étudiant demanda «&nbsp;Vous nous avez
mis en garde contre ces techniques, et pourtant je les ai trouvées dans ce
programme. Comment cela se fait-il&nbsp;?&nbsp;» Fu-Tzu répondit : «&nbsp;Il n’y a pas
besoin d’aller chercher un tuyau d’arrosage quand la maison n’est pas en
feu.&nbsp;» {Cela ne doit pas se lire comme un encouragement à faire du code de
mauvaise qualité, mais comme un avertissement contre une adhésion servile à
la règle d’or.}

%% Sagesse

Un étudiant se plaignait des valeurs numériques. «&nbsp;Quand je prends la racine
de deux et que je veux de nouveau son carré, le résultat est inexact&nbsp;!&nbsp;».] En
entendant cela, Fu-Tzu rit. «&nbsp;Voici une feuille de papier.] Écrivez-moi la
valeur précise de la racine de deux.&nbsp;»

Fu-Tzu dit : «&nbsp;Quand vous sciez du bois contre le fil, beaucoup d’huile de
coude est nécessaire. Quand vous programmez contre le sens, beaucoup de code
est nécessaire.&nbsp;»

Tzu-li et Tzu-ssu se vantaient de la taille de leurs programmes.] «&nbsp;Deux cent
mille lignes&nbsp;», dit Tzu-li, «&nbsp;sans compter les commentaires&nbsp;!&nbsp;». «&nbsp;Psah&nbsp;»,
dit Tzu-ssu, «&nbsp;le mien fait presque un *million* de lignes déjà.&nbsp;» Fu-tzu dit
«&nbsp;Mon meilleur programme fait cinq cents lignes.&nbsp;» En entendant cela, Tzu-li
et Tzu-ssu furent éclairés.

Un étudiant était resté assis immobile derrière son ordinateur pendant des
heures, en ruminant furieusement. Il était en train d’essayer de concevoir
une solution élégante en réponse à un problème difficile, mais il ne pouvait
pas trouver le bon moyen de le faire. Fu-tzu le frappa sur l’arrière de la
tête, et cria «&nbsp;tape quelque chose&nbsp;!&nbsp;» L’étudiant se mit à écrire un code
dégueulasse. Quand il eut terminé, il comprit tout à coup quelle était la
solution simple.

%% Progression

Un programmeur débutant écrit un programme à la manière d’une fourmi qui
construit sa fourmilière, sans même penser à la structure finale. Ses
programmes seront comme des grains de sable fin. Ils peuvent tenir un moment,
mais en devenant plus gros ils tombent {en référence aux dangers d’une
incompatibilité interne et aux structures dupliquées dans un code en
désordre.}.

En prenant conscience de ce problème, le codeur commencera à passer plus de
temps à réfléchir à la structure. Ses programmes seront structurés
rigidement, à la manière de sculptures de pierre. Ils sont solides, mais
quand ils doivent changer, on doit leur faire violence {en référence au fait
que la structure a tendance à brider l’évolution du programme}.

Le programmeur expérimenté sait quand la structure est importante, et quand
il doit laisser les choses telles quelles.] Ses programmes sont comme de
l’argile, à la fois solide et malléable.

%% Langage

Quand un langage de programmation est créé, on lui donne une syntaxe et des
règles sémantiques. La syntaxe décrit la forme du programme, la sémantique
décrit la fonction. Si la syntaxe est belle et que les règles sont claires,
le programme sera un arbre majestueux. Si la syntaxe est maladroite et que
les règles sont confuses, le programme sera comme un tas de ronces.

On demanda à Tzu-ssu d’écrire un programme dans un langage appelé Java qui
adopte une approche vraiment primitive avec les fonctions. Tous les matins,
au moment où il s’asseyait en face de son ordinateur, il commençait à se
plaindre. Toute la journée il jurait, accusant le langage pour tout ce qui se
passait mal. Fu-tzu écouta pendant un moment, puis lui fit des reproches en
lui disant «&nbsp;Chaque langage a sa philosophie. Suis son dessein, n’essaye pas
de coder comme si tu utilisais un autre langage de programmation.»</pre></div><hr/><div class="block"><p>Afin d’honorer la mémoire de notre vénérable ermite, j’aimerais finir son
programme de génération HTML pour lui. Une bonne approche à ce problème
ressemble à ce qui suit :</p><ol><li>Découper le fichier en créant un nouveau paragraphe à chaque fin de ligne.</li><li>Supprimer les caractères «&nbsp;%&nbsp;» des paragraphes d’en-tête et marquer ceux-ci comme en-têtes.</li><li>Traiter le texte des paragraphes proprement dits, les découper en corps de texte, textes en emphase et notes de bas de page.</li><li>Déplacer les notes de bas de page en fin de document, mettre des numéros<a class="footref" href="#footnote1">1</a> à leur place.</li><li>Entourer chaque élément d’une balise HTML adéquate.</li><li>Regrouper le tout en un unique document HTML.</li></ol><p>Cette approche ne permet pas les notes de bas de page à l’intérieur des textes
en emphase et inversement. C’est un choix arbitraire mais il permet de rester
sur un exemple assez simple. Si, à la fin du chapitre, vous voulez vous lancer
un défi, essayez de modifier le programme pour qu’il prenne en charge les
marquages «&nbsp;imbriqués&nbsp;».</p><p>Le manuscrit complet, sous forme de chaîne, est disponible sur cette page en
appelant la fonction <code>fichierDeErmite</code>.</p></div><hr/><div class="block"><p>La première étape de cet algorithme est triviale. Une ligne blanche est le
résultat de deux retours-chariots consécutifs et, si vous vous rappelez que les
chaînes disposent d’une méthode <code>split</code>, comme vu dans <a href="chapter4.html">chapitre 4</a>, vous
comprendrez que cela fera l’affaire :</p><pre class="code"><span class="keyword">var</span> <span class="variable">paragraphes</span> = <span class="variable">fichierDeErmite</span>().<span class="property">split</span>(<span class="string">&quot;\n\n&quot;</span>);
<span class="variable">print</span>(<span class="string">&quot;Trouvé &quot;</span>, <span class="variable">paragraphes</span>.<span class="property">length</span>, <span class="string">&quot; paragraphes.&quot;</span>);</pre></div><hr/><div class="block"><a name="exercise2"></a><div class="exercisenum">Ex. 6.2</div><div class="exercise"><p>Écrire une fonction <code>transformeParagraphe</code> qui, recevant un paragraphe sous
forme de chaîne en argument, détermine si ce paragraphe est un en-tête. S’il
l’est, enlever les caractères «&nbsp;%&nbsp;» et les compter. Cette fonction renvoie un
objet doté de 2 propriétés, <code>contenu</code> contenant le texte du paragraphe, et
<code>type</code>, qui contient la balise qui devra entourer le paragraphe, <code>&quot;p&quot;</code> pour des
paragraphes proprement dit, <code>&quot;h1&quot;</code> pour les en-têtes avec un seul «&nbsp;% », et
<code>&quot;hX&quot;</code> pour les en-têtes avec <code>X</code> caractères «&nbsp;%&nbsp;».</p><p>Rappelez-vous que les chaînes possèdent une méthode <code>charAt</code> permettant de
rechercher un caractère précis dans les caractères qui la composent.</p></div><div class="solution"><pre class="code"><span class="keyword">function</span> <span class="variable">transformeParagraphe</span>(<span class="variabledef">paragraphe</span>) {
  <span class="keyword">var</span> <span class="variabledef">entete</span> = <span class="atom">0</span>;
  <span class="keyword">while</span> (<span class="localvariable">paragraphe</span>.<span class="property">charAt</span>(<span class="atom">0</span>) == <span class="string">&quot;%&quot;</span>) {
    <span class="localvariable">paragraphe</span> = <span class="localvariable">paragraphe</span>.<span class="property">slice</span>(<span class="atom">1</span>);
    <span class="localvariable">entete</span>++;
  }

  <span class="keyword">return</span> {<span class="property">type</span>: (<span class="localvariable">entete</span> == <span class="atom">0</span> ? <span class="string">&quot;p&quot;</span> : <span class="string">&quot;h&quot;</span> + <span class="localvariable">entete</span>),
          <span class="property">contenu</span>: <span class="localvariable">paragraphe</span>};
}

<span class="variable">show</span>(<span class="variable">transformeParagraphe</span>(<span class="variable">paragraphes</span>[<span class="atom">0</span>]));</pre></div></div><hr/><div class="block"><p>C’est là que nous pouvons essayer la fonction <code>map</code> citée précédemment.</p><pre class="code"><span class="keyword">var</span> <span class="variable">paragraphes</span> = <span class="variable">map</span>(<span class="variable">transformeParagraphe</span>,
                     <span class="variable">fichierDeErmite</span>().<span class="property">split</span>(<span class="string">&quot;\n\n&quot;</span>));</pre><p>Et <em>boum</em>, nous avons un tableau de paragraphes proprement triés. Nous sommes
allés un peu vite, nous avons oublié l’étape 3 de l’algorithme :</p><blockquote>Traiter le texte des paragraphes proprement dit, séparer en texte normal,
texte en emphase, notes de bas de page.</blockquote><p>Ce qui se décompose en :</p><ol><li>Si le paragraphe commence par un astérisque, retirer la partie mise en emphase et la stocker.</li><li>Si le paragraphe commence par une accolade ouvrante, retirer la note de page et la stocker.</li><li>Dans les autres cas, retirer le morceau de texte jusqu’à la première mise en emphase, mise en bas de page, sinon jusqu’à la fin de la chaîne, et l’enregistrer comme texte normal.</li><li>S’il reste encore quelque chose dans le paragraphe, reprendre à nouveau en 1.</li></ol></div><hr/><div class="block"><a name="exercise3"></a><div class="exercisenum">Ex. 6.3</div><div class="exercise"><p>Écrire une fonction <code>decoupeParagraphe</code> qui, recevant une chaîne de caractères
représentant un paragraphe, renvoie un tableau de morceaux du texte. Réfléchir
à la façon de bien représenter les morceaux du texte.</p><p>La méthode <code>indexOf</code>, qui recherche un caractère ou une sous-chaîne de
caractères dans une chaîne de caractères et renvoie sa position, ou <code>-1</code> si
elle ne trouve pas, sera utile ici.</p><p>C’est un algorithme astucieux, et il y a différentes façons approximatives ou
trop longues pour l’expliquer. En cas de difficulté, n’y passer qu’une minute.
Essayer d’écrire des sous-fonctions qui effectuent une partie des actions qui
composent l’algorithme.</p></div><div class="solution"><p>Voici une solution possible :</p><pre class="code"><span class="keyword">function</span> <span class="variable">decoupeParagraphe</span>(<span class="variabledef">texte</span>) {
  <span class="keyword">function</span> <span class="variabledef">indexOuFin</span>(<span class="variabledef">caractere</span>) {
    <span class="keyword">var</span> <span class="variabledef">index</span> = <span class="localvariable">texte</span>.<span class="property">indexOf</span>(<span class="localvariable">caractere</span>);
    <span class="keyword">return</span> <span class="localvariable">index</span> == -<span class="atom">1</span> ? <span class="localvariable">texte</span>.<span class="property">length</span> : <span class="localvariable">index</span>;
  }

  <span class="keyword">function</span> <span class="variabledef">extraitTexteNormal</span>() {
    <span class="keyword">var</span> <span class="variabledef">fin</span> = <span class="variable">reduce</span>(<span class="variable">Math</span>.<span class="property">min</span>, <span class="localvariable">texte</span>.<span class="property">length</span>,
                     <span class="variable">map</span>(<span class="localvariable">indexOuFin</span>, [<span class="string">&quot;*&quot;</span>, <span class="string">&quot;{&quot;</span>]));
    <span class="keyword">var</span> <span class="variabledef">extraction</span> = <span class="localvariable">texte</span>.<span class="property">slice</span>(<span class="atom">0</span>, <span class="localvariable">fin</span>);
    <span class="localvariable">texte</span> = <span class="localvariable">texte</span>.<span class="property">slice</span>(<span class="localvariable">fin</span>);
    <span class="keyword">return</span> <span class="localvariable">extraction</span>;
  }

  <span class="keyword">function</span> <span class="variabledef">extraitJusquA</span>(<span class="variabledef">caractere</span>) {
    <span class="keyword">var</span> <span class="variabledef">fin</span> = <span class="localvariable">texte</span>.<span class="property">indexOf</span>(<span class="localvariable">caractere</span>, <span class="atom">1</span>);
    <span class="keyword">if</span> (<span class="localvariable">fin</span> == -<span class="atom">1</span>)
      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="variable">Error</span>(<span class="string">&quot;Manque '&quot;</span> + <span class="localvariable">caractere</span> + <span class="string">&quot;' fermant&quot;</span>);
    <span class="keyword">var</span> <span class="variabledef">extraction</span> = <span class="localvariable">texte</span>.<span class="property">slice</span>(<span class="atom">1</span>, <span class="localvariable">fin</span>);
    <span class="localvariable">texte</span> = <span class="localvariable">texte</span>.<span class="property">slice</span>(<span class="localvariable">fin</span> + <span class="atom">1</span>);
    <span class="keyword">return</span> <span class="localvariable">extraction</span>;
  }

  <span class="keyword">var</span> <span class="variabledef">fragments</span> = [];

  <span class="keyword">while</span> (<span class="localvariable">texte</span> != <span class="string">&quot;&quot;</span>) {
    <span class="keyword">if</span> (<span class="localvariable">texte</span>.<span class="property">charAt</span>(<span class="atom">0</span>) == <span class="string">&quot;*&quot;</span>)
      <span class="localvariable">fragments</span>.<span class="property">push</span>({<span class="property">type</span>: <span class="string">&quot;enEmphase&quot;</span>,
                      <span class="property">contenu</span>: <span class="localvariable">extraitJusquA</span>(<span class="string">&quot;*&quot;</span>)});
    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="localvariable">texte</span>.<span class="property">charAt</span>(<span class="atom">0</span>) == <span class="string">&quot;{&quot;</span>)
      <span class="localvariable">fragments</span>.<span class="property">push</span>({<span class="property">type</span>: <span class="string">&quot;noteBasDePage&quot;</span>,
                      <span class="property">contenu</span>: <span class="localvariable">extraitJusquA</span>(<span class="string">&quot;}&quot;</span>)});
    <span class="keyword">else</span>
      <span class="localvariable">fragments</span>.<span class="property">push</span>({<span class="property">type</span>: <span class="string">&quot;normal&quot;</span>,
                      <span class="property">contenu</span>: <span class="localvariable">extraitTexteNormal</span>()});
  }
  <span class="keyword">return</span> <span class="localvariable">fragments</span>;
}</pre><p>Remarquez l’utilisation abrupte de <code>map</code> et <code>reduce</code> dans la fonction
<code>extraitTexteNormal</code>. Ceci est un chapitre sur la programmation fonctionnelle,
donc c’est de la programmation fonctionnelle que nous ferons&nbsp;!  Voyez-vous
comment cela fonctionne&nbsp;? La fonction <code>map</code> renvoie un tableau des positions où
les caractères indiqués ont été trouvés, ou bien renvoie la fin de la chaîne si
aucun n’a été trouvé, et la fonction <code>reduce</code> prend le minimum de ces
positions, qui est la prochaine position dans la chaîne où nous allons
regarder.</p><p>Si vous voulez écrire cela sans <code>map</code> et <code>reduce</code>, vous obtiendrez à peu près
ceci :</p><pre class="preformatted">var prochainAsterisque = texte.indexOf(&quot;*&quot;);
var prochaineAccolade = texte.indexOf(&quot;{&quot;);
var fin = texte.length;
if (prochainAsterisque != -1)
  fin = prochainAsterisque;
if (prochaineAccolade != -1 &amp;&amp; prochaineAccolade &lt; fin)
  fin = prochaineAccolade;</pre><p>Ce qui est encore plus moche. La plupart du temps, quand il faut prendre une
décision basée sur plusieurs critères, ne serait-ce que deux, l’écrire sous
forme d’une opération dans un tableau est plus lisible que de décrire chaque
critère dans une instruction <code>if</code>. (Heureusement, dans le <a href="chapter10.html">chapitre 10</a>, il y a une
description simple de la façon de déterminer la première occurrence de &quot;ceci ou
cela&quot; dans une chaîne).</p><p>Si vous avez écrit une fonction <code>decoupeParagraphe</code> qui enregistre les morceaux
de texte d’une façon différente de la solution ci-dessus, vous devriez la
modifier, car les fonctions du reste de ce chapitre supposent que les morceaux
de texte sont des objets ayant des propriétés <code>type</code> et <code>contenu</code>.</p></div></div><hr/><div class="block"><p>Nous pouvons maintenant faire le lien avec <code>transformeParagraphe</code> pour découper
également le texte à l’intérieur des paragraphes, ma version peut être modifiée
de la façon suivante :</p><pre class="code"><span class="keyword">function</span> <span class="variable">transformeParagraphe</span>(<span class="variabledef">paragraphe</span>) {
  <span class="keyword">var</span> <span class="variabledef">entete</span> = <span class="atom">0</span>;
  <span class="keyword">while</span> (<span class="localvariable">paragraphe</span>.<span class="property">charAt</span>(<span class="atom">0</span>) == <span class="string">&quot;%&quot;</span>) {
    <span class="localvariable">paragraphe</span> = <span class="localvariable">paragraphe</span>.<span class="property">slice</span>(<span class="atom">1</span>);
    <span class="localvariable">entete</span>++;
  }

  <span class="keyword">return</span> {<span class="property">type</span>: (<span class="localvariable">entete</span> == <span class="atom">0</span> ? <span class="string">&quot;p&quot;</span> : <span class="string">&quot;h&quot;</span> + <span class="localvariable">entete</span>),
          <span class="property">contenu</span>: <span class="variable">decoupeParagraphe</span>(<span class="localvariable">paragraphe</span>)};
}</pre><p>L’exécution de cette fonction sur le tableau des objets paragraphe nous renvoie
un nouveau tableau d’objets paragraphe, qui contiennent des tableaux d’objets.
Chacun de ces objets contient une fraction de paragraphe.  La chose à faire
ensuite est d’extraire les notes de bas de page, et mettre des références vers
celles-ci à leur place. Comme ceci : </p><pre class="code"><span class="keyword">function</span> <span class="variable">extraitNotesBasDePage</span>(<span class="variabledef">paragraphes</span>) {
  <span class="keyword">var</span> <span class="variabledef">notesBasDePage</span> = [];
  <span class="keyword">var</span> <span class="variabledef">noteEnCours</span> = <span class="atom">0</span>;

  <span class="keyword">function</span> <span class="variabledef">remplaceNoteBasDePage</span>(<span class="variabledef">fragment</span>) {
    <span class="keyword">if</span> (<span class="localvariable">fragment</span>.<span class="property">type</span> == <span class="string">&quot;noteBasDePage&quot;</span>) {
      <span class="localvariable">noteEnCours</span>++;
      <span class="localvariable">notesBasDePage</span>.<span class="property">push</span>(<span class="localvariable">fragment</span>);
      <span class="localvariable">fragment</span>.<span class="property">numero</span> = <span class="localvariable">noteEnCours</span>;
      <span class="keyword">return</span> {<span class="property">type</span>: <span class="string">&quot;reference&quot;</span>, <span class="property">numero</span>: <span class="localvariable">noteEnCours</span>};
    }
    <span class="keyword">else</span> {
      <span class="keyword">return</span> <span class="localvariable">fragment</span>;
    }
  }

  <span class="variable">forEach</span>(<span class="localvariable">paragraphes</span>, <span class="keyword">function</span>(<span class="variabledef">paragraphe</span>) {
    <span class="localvariable">paragraphe</span>.<span class="property">contenu</span> = <span class="variable">map</span>(<span class="localvariable">remplaceNoteBasDePage</span>,
                            <span class="localvariable">paragraphe</span>.<span class="property">contenu</span>);
  });

  <span class="keyword">return</span> <span class="localvariable">notesBasDePage</span>;
}</pre><p>La fonction <code>remplaceNoteBasDePage</code> est appelée sur chaque morceau. Quand elle
reçoit un morceau qui doit rester où il est, elle ne fait que renvoyer ce
morceau, mais si elle reçoit une note de bas de page, elle stocke celui-ci dans
le tableau <code>notesBasDePage</code>, et renvoie une référence vers celui-ci à la place.
Dans le même temps, chaque note de bas de page et sa référence sont numérotées.</p></div><hr/><div class="block"><p>Nous avons suffisamment d’outils pour extraire les informations du fichier. Il
nous reste à générer un fichier HTML correct.</p><p>De nombreuses personnes pensent que la concaténation de chaînes de caractère
est un bon moyen de construire du HTML. Quand elles veulent, par exemple, un
lien vers un site où l’on peut jouer au jeu de Go, elles font ceci :</p><pre class="code"><span class="keyword">var</span> <span class="variable">url</span> = <span class="string">&quot;http://www.gokgs.com/&quot;</span>;
<span class="keyword">var</span> <span class="variable">texte</span> = <span class="string">&quot;Jouez au Go&nbsp;!&quot;</span>;
<span class="keyword">var</span> <span class="variable">texteLien</span> = <span class="string">&quot;&lt;a href=\&quot;&quot;</span> + <span class="variable">url</span> + <span class="string">&quot;\&quot;&gt;&quot;</span> + <span class="variable">texte</span> + <span class="string">&quot;&lt;/a&gt;&quot;</span>;
<span class="variable">print</span>(<span class="variable">texteLien</span>);</pre><p>(Où <code>a</code> est la balise utilisée pour créer des liens dans les documents HTML…)
Ceci est non seulement maladroit, mais, quand la chaîne <code>texte</code> se trouve
contenir un chevron (caractère &quot;&lt;&quot; ou &quot;&gt;&quot;) ou une esperluette (caractère &quot;&amp;&quot;),
cela provoque une erreur. Des choses bizarres vont se passer sur votre site
web, et vous passerez pour un amateur. Nous ne voulons pas que cela se
produise. Il est facile d’écrire quelques fonctions simples de génération de
HTML. Alors, écrivons-les.</p></div><hr/><div class="block"><p>Le secret d’une génération HTML réussie est de traiter votre document comme une
structure de données plutôt qu’un simple texte plat.  Les objets en JavaScript
permettent de modéliser cela facilement :</p><pre class="code"><span class="keyword">var</span> <span class="variable">objetLien</span>= {<span class="property">nom</span>: <span class="string">&quot;a&quot;</span>,
                  <span class="property">attributs</span>: {<span class="property">href</span>: <span class="string">&quot;http://www.gokgs.com/&quot;</span>},
                  <span class="property">contenu</span>: [<span class="string">&quot;Jouez au Go&nbsp;!&quot;</span>]};</pre><p>Chaque élément HTML possède une propriété <code>nom</code>, contenant le nom de la balise
qu’il représente. Quand il a des attributs, il possède également une propriété
<code>attributs</code>, qui est un objet contenant ces attributs. Quand il a un contenu,
il possède une propriété <code>contenu</code> contenant un tableau des autres éléments
qu’il englobe. Des chaînes de caractères contiennent les portions de texte de
notre document HTML, ainsi, le tableau <code>[&quot;Jouer au Go!&quot;]</code> signifie que ce lien
n’a qu’un élément englobé, cet élément étant un simple morceau de texte.</p><p>Saisir tous ces objets à la main serait pénible, mais nous n’allons pas faire
comme ça. Une fonction utilitaire fera cela pour nous :</p><pre class="code"><span class="keyword">function</span> <span class="variable">balise</span>(<span class="variabledef">nom</span>, <span class="variabledef">contenu</span>, <span class="variabledef">attributs</span>) {
  <span class="keyword">return</span> {<span class="property">nom</span>: <span class="localvariable">nom</span>, <span class="property">attributs</span>: <span class="localvariable">attributs</span>, <span class="property">contenu</span>: <span class="localvariable">contenu</span>};
}</pre><p>Remarquez que du fait que nous autorisons que les propriétés <code>attributs</code> et
<code>contenu</code> d’un élément soient indéfinies s’ils ne s’appliquent pas, le second
et troisième élément de cette fonction peuvent être ignorés s’ils ne sont pas
nécessaires.</p><p>La fonction <code>balise</code> est cependant assez simpliste, c’est pourquoi nous
écrivons quelques fonctions utilitaires pour des éléments fréquemment utilisés,
comme les liens, ou la structure générale d’un document simple :</p><pre class="code"><span class="keyword">function</span> <span class="variable">lien</span>(<span class="variabledef">cible</span>, <span class="variabledef">texte</span>) {
  <span class="keyword">return</span> <span class="variable">balise</span>(<span class="string">&quot;a&quot;</span>, [<span class="localvariable">texte</span>], {<span class="property">href</span>: <span class="localvariable">cible</span>});
}

<span class="keyword">function</span> <span class="variable">documentHtml</span>(<span class="variabledef">titre</span>, <span class="variabledef">contenu</span>) {
  <span class="keyword">return</span> <span class="variable">balise</span>(<span class="string">&quot;html&quot;</span>, [<span class="variable">balise</span>(<span class="string">&quot;head&quot;</span>, [<span class="variable">balise</span>(<span class="string">&quot;title&quot;</span>, [<span class="localvariable">titre</span>])]),
                      <span class="variable">balise</span>(<span class="string">&quot;body&quot;</span>, <span class="localvariable">contenu</span>)]);
}</pre></div><hr/><div class="block"><a name="exercise4"></a><div class="exercisenum">Ex. 6.4</div><div class="exercise"><p>En reprenant, si nécessaire, l’exemple de document HTML donné précédemment,
écrire une fonction <code>image</code> qui, recevant un fichier d’image, crée un élément
HTML <code>img</code>.</p></div><div class="solution"><pre class="code"><span class="keyword">function</span> <span class="variable">image</span>(<span class="variabledef">src</span>) {
  <span class="keyword">return</span> <span class="variable">balise</span>(<span class="string">&quot;img&quot;</span>, [], {<span class="property">src</span>: <span class="localvariable">src</span>});
}</pre></div></div><hr/><div class="block"><p>Quand nous aurons créé un document, il devra être mis à plat sous forme de
chaîne. Mais construire cette chaîne à partir des structures de données que
nous aurons construites sera facile. L’aspect important dont il faut se
souvenir est de transformer les caractères spéciaux de notre document…</p><pre class="code"><span class="keyword">function</span> <span class="variable">escapeHTML</span>(<span class="variabledef">texte</span>) {
  <span class="keyword">var</span> <span class="variabledef">remplacements</span> = [[<span class="string">/&amp;/g</span>, <span class="string">&quot;&amp;amp;&quot;</span>], [<span class="string">/&quot;/g</span>, <span class="string">&quot;&amp;quot;&quot;</span>],
                      [<span class="string">/&lt;/g</span>, <span class="string">&quot;&amp;lt;&quot;</span>], [<span class="string">/&gt;/g</span>, <span class="string">&quot;&amp;gt;&quot;</span>]];
  <span class="variable">forEach</span>(<span class="localvariable">remplacements</span>, <span class="keyword">function</span>(<span class="variabledef">remplacement</span>) {
    <span class="localvariable">texte</span> = <span class="localvariable">texte</span>.<span class="property">replace</span>(<span class="localvariable">remplacement</span>[<span class="atom">0</span>], <span class="localvariable">remplacement</span>[<span class="atom">1</span>]);
  });
  <span class="keyword">return</span> <span class="localvariable">texte</span>;
}</pre><p>La méthode <code>replace</code> des objets chaînes crée une nouvelle chaîne dans laquelle
toutes les occurrences du motif passé en premier argument sont remplacées par
le second argument, ainsi <code>&quot;Borobudur&quot;.replace(/r/g, &quot;k&quot;)</code> donne <code>&quot;Bokobuduk&quot;</code>.
Ne vous souciez pas ici de la syntaxe des motifs, cela sera vu au <a href="chapter10.html">chapitre 10</a>. La
fonction <code>escapeHTML</code> stocke les différents motifs à remplacer dans un tableau,
aussi, il suffit d’énumérer à l’aide d’une boucle chacun de ces motifs pour les
appliquer un par un.</p><p>Les guillemets sont également remplacés, car nous utiliserons cette fonction
pour le texte à l’intérieur des attributs des balises HTML. Ces attributs
seront encadrés par des guillemets, et par conséquent ne pourront en contenir
eux-mêmes.</p><p>Appeler quatre fois la méthode replace signifie que l’ordinateur devra balayer
quatre fois la totalité de la chaîne à convertir. Ce n’est pas très efficace.
Avec plus de soin, nous pourrions écrire une version plus complexe de cette
fonction, qui ressemblerait à la fonction <code>decoupeParagraphe</code> vue précédemment,
pour ne parcourir cette chaîne qu’une seule fois. Pour le moment, nous sommes
trop paresseux pour cela. De toute façon, nous verrons au <a href="chapter10.html">chapitre 10</a> une bien
meilleure façon de faire tout cela.</p></div><hr/><div class="block"><p>Pour transformer un élément HTML en une chaîne, nous pouvons utiliser une
fonction récursive comme celle-ci :</p><pre class="code"><span class="keyword">function</span> <span class="variable">renduHTML</span>(<span class="variabledef">element</span>) {
  <span class="keyword">var</span> <span class="variabledef">pieces</span> = [];

  <span class="keyword">function</span> <span class="variabledef">renduAttributs</span>(<span class="variabledef">attributs</span>) {
    <span class="keyword">var</span> <span class="variabledef">resultat</span> = [];
    <span class="keyword">if</span> (<span class="localvariable">attributs</span>) {
      <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">nom</span> <span class="keyword">in</span> <span class="localvariable">attributs</span>)
        <span class="localvariable">resultat</span>.<span class="property">push</span>(<span class="string">&quot; &quot;</span> + <span class="localvariable">nom</span> + <span class="string">&quot;=\&quot;&quot;</span> +
                    <span class="variable">escapeHTML</span>(<span class="localvariable">attributs</span>[<span class="localvariable">nom</span>]) + <span class="string">&quot;\&quot;&quot;</span>);
    }
    <span class="keyword">return</span> <span class="localvariable">resultat</span>.<span class="property">join</span>(<span class="string">&quot;&quot;</span>);
  }

  <span class="keyword">function</span> <span class="variabledef">rendu</span>(<span class="variabledef">element</span>) {
    <span class="comment">// Element texte</span>
    <span class="keyword">if</span> (typeof <span class="localvariable">element</span> == <span class="string">&quot;string&quot;</span>) {
      <span class="localvariable">pieces</span>.<span class="property">push</span>(<span class="variable">escapeHTML</span>(<span class="localvariable">element</span>));
    }
    <span class="comment">// Balise vide</span>
    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="localvariable">element</span>.<span class="property">contenu</span> || <span class="localvariable">element</span>.<span class="property">contenu</span>.<span class="property">length</span> == <span class="atom">0</span>) {
      <span class="localvariable">pieces</span>.<span class="property">push</span>(<span class="string">&quot;&lt;&quot;</span> + <span class="localvariable">element</span>.<span class="property">nom</span> +
                  <span class="localvariable">renduAttributs</span>(<span class="localvariable">element</span>.<span class="property">attributs</span>) + <span class="string">&quot;/&gt;&quot;</span>);
    }
    <span class="comment">// Balise avec du contenu</span>
    <span class="keyword">else</span> {
      <span class="localvariable">pieces</span>.<span class="property">push</span>(<span class="string">&quot;&lt;&quot;</span> + <span class="localvariable">element</span>.<span class="property">nom</span> +
                  <span class="localvariable">renduAttributs</span>(<span class="localvariable">element</span>.<span class="property">attributs</span>) + <span class="string">&quot;&gt;&quot;</span>);
      <span class="variable">forEach</span>(<span class="localvariable">element</span>.<span class="property">contenu</span>, <span class="localvariable">rendu</span>);
      <span class="localvariable">pieces</span>.<span class="property">push</span>(<span class="string">&quot;&lt;/&quot;</span> + <span class="localvariable">element</span>.<span class="property">nom</span> + <span class="string">&quot;&gt;&quot;</span>);
    }
  }

  <span class="localvariable">rendu</span>(<span class="localvariable">element</span>);
  <span class="keyword">return</span> <span class="localvariable">pieces</span>.<span class="property">join</span>(<span class="string">&quot;&quot;</span>);
}</pre><p>Remarquez la boucle avec <code>in</code> qui extrait les propriétés d’un objet JavaScript
dans le but de créer les attributs d’une balise HTML en se basant sur ces
propriétés. Remarquez également qu’à deux reprises, des tableaux sont utilisés
pour stocker des chaînes, qui sont finalement regroupées pour ne former qu’une
seule chaîne. Pourquoi n’avons-nous pas simplement commencé avec une chaîne
vide à laquelle nous aurions ajouté d’autres chaînes, à l’aide de l’opérateur
<code>+=</code>&nbsp;?</p><p>Il se trouve que la création des chaînes, en particulier quand elles sont de
grande taille, représente un certain travail. Rappelez-vous que le contenu des
chaînes JavaScript est immuable. Si vous concaténez une chaîne à une autre, une
nouvelle chaîne est créée, les deux premières ne changeant pas. Si nous
construisons une très grande chaîne en concaténant de nombreuses chaînes, une
nouvelle chaîne doit être créée à chacun des ajouts, et sera supprimée après
l’ajout suivant.  Si, d’un autre côté, nous stockons toutes les chaînes dans un
tableau pour les rassembler à la fin, une seule grande chaîne sera créée.</p></div><hr/><div class="block"><p>Ainsi, essayons notre outil de génération de HTML…</p><pre class="code"><span class="variable">print</span>(<span class="variable">renduHTML</span>(<span class="variable">lien</span>(<span class="string">&quot;http://www.nedroid.com&quot;</span>, <span class="string">&quot;Des dessins&nbsp;!&quot;</span>)));</pre><p>Cela semble fonctionner.</p><pre class="code"><span class="keyword">var</span> <span class="variable">corps</span> = [<span class="variable">balise</span>(<span class="string">&quot;h1&quot;</span>, [<span class="string">&quot;Le Test&quot;</span>]),
            <span class="variable">balise</span>(<span class="string">&quot;p&quot;</span>, [<span class="string">&quot;Voici un paragraphe, et une image…&quot;</span>]),
            <span class="variable">image</span>(<span class="string">&quot;img/sheep.png&quot;</span>)];
<span class="keyword">var</span> <span class="variable">doc</span> = <span class="variable">documentHtml</span>(<span class="string">&quot;Le Test&quot;</span>, <span class="variable">corps</span>);
<span class="variable">viewHTML</span>(<span class="variable">renduHTML</span>(<span class="variable">doc</span>));</pre><p>Je devrais maintenant vous prévenir que cette approche n’est pas parfaite. Ce
qu’elle génère est en fait du <a name="key12"></a>XML, qui est proche du HTML, mais plus
structuré. Dans les cas les plus simples, cela n’engendre pas de problème.
Cependant, il existe des séquences correctes en XML, qui ne sont pas correctes
en HTML, et peuvent embrouiller un navigateur lorsqu’il va vouloir afficher
notre document. Si par exemple vous avez un jeu de balises <code>script</code> vides (on
les utilise pour insérer du JavaScript dans une page) dans votre document, les
navigateurs ne vont pas s’en apercevoir et penser que tout ce qui suit est du
JavaScript (dans ce cas, le problème peut être réglé en mettant une espace
unique entre les balises ouvrante et fermante pour que la balise ne soit pas
vide, et ainsi avoir une balise fermante).</p></div><hr/><div class="block"><a name="exercise5"></a><div class="exercisenum">Ex. 6.5</div><div class="exercise"><p>Écrivez une fonction <code>renduFragment</code>, et utilisez-la pour implémenter une autre
fonction, <code>renduParagraphe</code>, qui prend un objet paragraphe (en ne tenant pas
compte des notes de bas de page) et produit l’élément HTML correct (qui peut
être un paragraphe ou un en-tête, en fonction du <code>type</code> de l’objet paragraphe).</p><p>Cette fonction pourrait s’avérer utile pour produire les liens vers les
références de bas de page :</p><pre class="code"><span class="keyword">function</span> <span class="variable">basDePage</span>(<span class="variabledef">numero</span>) {
  <span class="keyword">return</span> <span class="variable">balise</span>(<span class="string">&quot;sup&quot;</span>, [<span class="variable">lien</span>(<span class="string">&quot;#note&quot;</span> + <span class="localvariable">numero</span>,
                          <span class="variable">String</span>(<span class="localvariable">numero</span>))]);
}</pre><p>Une balise <code>sup</code> affiche son contenu en «&nbsp;exposant&nbsp;», ce qui signifie que ce
contenu sera plus petit et un peu plus haut sur la ligne que le reste du texte.
La cible du lien prendra une forme telle que <code>&quot;#note1&quot;</code>. Les liens contenant un
caractère «&nbsp;#&nbsp;» font référence aux «&nbsp;ancres&nbsp;» à l’intérieur d’une page, et ici
nous les utiliserons pour renvoyer le lecteur à la fin de la page, où seront
les notes de bas de page.</p><p>La balise pour générer des parties mises en emphase est <code>em</code>&nbsp;; un texte normal
peut être généré sans balise supplémentaire.</p></div><div class="solution"><pre class="code"><span class="keyword">function</span> <span class="variable">renduParagraphe</span>(<span class="variabledef">paragraphe</span>) {
  <span class="keyword">return</span> <span class="variable">balise</span>(<span class="localvariable">paragraphe</span>.<span class="property">type</span>, <span class="variable">map</span>(<span class="variable">renduFragment</span>,
                                 <span class="localvariable">paragraphe</span>.<span class="property">contenu</span>));
}

<span class="keyword">function</span> <span class="variable">renduFragment</span>(<span class="variabledef">fragment</span>) {
  <span class="keyword">if</span> (<span class="localvariable">fragment</span>.<span class="property">type</span> == <span class="string">&quot;reference&quot;</span>)
    <span class="keyword">return</span> <span class="variable">basDePage</span>(<span class="localvariable">fragment</span>.<span class="property">numero</span>);
  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="localvariable">fragment</span>.<span class="property">type</span> == <span class="string">&quot;enEmphase&quot;</span>)
    <span class="keyword">return</span> <span class="variable">balise</span>(<span class="string">&quot;em&quot;</span>, [<span class="localvariable">fragment</span>.<span class="property">contenu</span>]);
  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="localvariable">fragment</span>.<span class="property">type</span> == <span class="string">&quot;normal&quot;</span>)
    <span class="keyword">return</span> <span class="localvariable">fragment</span>.<span class="property">contenu</span>;
}</pre></div></div><hr/><div class="block"><p>Nous y sommes presque. Le dernier élément pour lequel nous ne disposons pas de
fonction de génération HTML concerne les notes de bas de page. Pour que les
liens <code>&quot;#note1&quot;</code> fonctionnent, une ancre doit être incluse dans chaque note de
bas de page. En HTML, les ancres sont décrites à l’aide d’une balise <code>a</code>,
également utilisé pour les liens. Dans ce cas, la balise prend un attribut
<code>name</code> au lieu de <code>href</code>.</p><pre class="code"><span class="keyword">function</span> <span class="variable">renduNoteBasDePage</span>(<span class="variabledef">noteBasDePage</span>) {
  <span class="keyword">var</span> <span class="variabledef">numero</span> = <span class="string">&quot;[&quot;</span> + <span class="localvariable">noteBasDePage</span>.<span class="property">numero</span> + <span class="string">&quot;] &quot;</span>;
  <span class="keyword">var</span> <span class="variabledef">ancre</span> = <span class="variable">balise</span>(<span class="string">&quot;a&quot;</span>, [<span class="localvariable">numero</span>], {<span class="property">name</span>: <span class="string">&quot;note&quot;</span> + <span class="localvariable">noteBasDePage</span>.<span class="property">numero</span>});
  <span class="keyword">return</span> <span class="variable">balise</span>(<span class="string">&quot;p&quot;</span>, [<span class="variable">balise</span>(<span class="string">&quot;small&quot;</span>, [<span class="localvariable">ancre</span>, <span class="localvariable">noteBasDePage</span>.<span class="property">contenu</span>])]);
}</pre><p>Enfin, voici une fonction qui, recevant un fichier correctement formaté et un
titre de document, renvoie un document HTML.</p><pre class="code"><span class="keyword">function</span> <span class="variable">renduFichier</span>(<span class="variabledef">fichier</span>, <span class="variabledef">titre</span>) {
  <span class="keyword">var</span> <span class="variabledef">paragraphes</span> = <span class="variable">map</span>(<span class="variable">transformeParagraphe</span>, <span class="localvariable">fichier</span>.<span class="property">split</span>(<span class="string">&quot;\n\n&quot;</span>));
  <span class="keyword">var</span> <span class="variabledef">notesBasDePage</span> = <span class="variable">map</span>(<span class="variable">renduNoteBasDePage</span>,
                      <span class="variable">extraitNotesBasDePage</span>(<span class="localvariable">paragraphes</span>));
  <span class="keyword">var</span> <span class="variabledef">corps</span> = <span class="variable">map</span>(<span class="variable">renduParagraphe</span>, <span class="localvariable">paragraphes</span>).<span class="property">concat</span>(<span class="localvariable">notesBasDePage</span>);
  <span class="keyword">return</span> <span class="variable">renduHTML</span>(<span class="variable">documentHtml</span>(<span class="localvariable">titre</span>, <span class="localvariable">corps</span>));
}

<span class="variable">viewHTML</span>(<span class="variable">renduFichier</span>(<span class="variable">fichierDeErmite</span>(), <span class="string">&quot;Le livre de la programmation&quot;</span>));</pre><p>La méthode <a name="key13"></a><code>concat</code> des objets de type tableau sert à concaténer un tableau
avec un autre, tout comme l’opérateur <code>+</code> le fait avec les chaînes de
caractère.</p></div><hr/><div class="block"><p>Dans les chapitres suivant, les fonctions élémentaires d’ordre supérieur comme
<code>map</code> et <code>reduce</code> seront toujours disponibles, et utilisées dans certains
exemples. Ici et là, on leur ajoutera d’autres outils qui nous sembleront
utiles. Dans le <a href="chapter9.html">chapitre 9</a>, nous verrons une approche plus structurée pour
gérer ce jeu de fonctions de base.</p></div><hr/><div class="block"><p>Lorsqu’on utilise des fonctions d’ordre supérieur, il est souvent agaçant que
les opérateurs ne soient pas des fonctions en JavaScript. Nous avons eu besoin
des fonctions <code>ajouter</code> ou <code>equals</code> à différents endroits. Les réécrire à
chaque fois est fastidieux, n’est-ce pas&nbsp;? Aussi, à partir de maintenant, nous
supposons l’existence d’un objet nommé <code>op</code>, qui contient ces fonctions :</p><pre class="code"><span class="keyword">var</span> <span class="variable">op</span> = {
  <span class="string">&quot;+&quot;</span>: <span class="keyword">function</span>(<span class="variabledef">a</span>, <span class="variabledef">b</span>){<span class="keyword">return</span> <span class="localvariable">a</span> + <span class="localvariable">b</span>;},
  <span class="string">&quot;==&quot;</span>: <span class="keyword">function</span>(<span class="variabledef">a</span>, <span class="variabledef">b</span>){<span class="keyword">return</span> <span class="localvariable">a</span> == <span class="localvariable">b</span>;},
  <span class="string">&quot;===&quot;</span>: <span class="keyword">function</span>(<span class="variabledef">a</span>, <span class="variabledef">b</span>){<span class="keyword">return</span> <span class="localvariable">a</span> === <span class="localvariable">b</span>;},
  <span class="string">&quot;!&quot;</span>: <span class="keyword">function</span>(<span class="variabledef">a</span>){<span class="keyword">return</span> !<span class="localvariable">a</span>;}
  <span class="comment">/* et ainsi de suite */</span>
};</pre><p>Nous pouvons donc écrire <code>reduce(op[&quot;+&quot;], 0, [1, 2, 3, 4, 5])</code> pour faire la
somme d’un tableau. Mais que se passe-t-il si nous avons besoin de quelque
chose comme <code>equals</code> ou <code>creerFonctionAjouter</code>, dans lequel un des arguments a
déjà une valeur&nbsp;? Dans ce cas nous voilà revenus à l’écriture d’une nouvelle
fonction.</p><p>Dans les cas comme ceux-là, l’utilisation d’une «&nbsp;<a name="key14"></a>application partielle&nbsp;» est
intéressante. Vous voulez créer une nouvelle fonction qui connaît déjà un
certain nombre de ces arguments et traite des arguments supplémentaires passés
après ces arguments fixes. Vous pourrez le faire en utilisant de façon créative
la méthode <code>apply</code> d’une fonction :</p><pre class="code"><span class="keyword">function</span> <span class="variable">asArray</span>(<span class="variabledef">quasimentUnTableau</span>, <span class="variabledef">debut</span>) {
  <span class="keyword">var</span> <span class="variabledef">resultat</span> = [];
  <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">i</span> = (<span class="localvariable">debut</span> || <span class="atom">0</span>); <span class="localvariable">i</span> &lt; <span class="localvariable">quasimentUnTableau</span>.<span class="property">length</span>; <span class="localvariable">i</span>++)
    <span class="localvariable">resultat</span>.<span class="property">push</span>(<span class="localvariable">quasimentUnTableau</span>[<span class="localvariable">i</span>]);
  <span class="keyword">return</span> <span class="localvariable">resultat</span>;
}

<span class="keyword">function</span> <span class="variable">partial</span>(<span class="variabledef">func</span>) {
  <span class="keyword">var</span> <span class="variabledef">argumentsFixes</span> = <span class="variable">asArray</span>(<span class="localvariable">arguments</span>, <span class="atom">1</span>);
  <span class="keyword">return</span> <span class="keyword">function</span>(){
    <span class="keyword">return</span> <span class="localvariable">func</span>.<span class="property">apply</span>(<span class="atom">null</span>, <span class="localvariable">argumentsFixes</span>.<span class="property">concat</span>(<span class="variable">asArray</span>(<span class="localvariable">arguments</span>)));
  };
}</pre><p>Nous voulons être en mesure de regrouper plusieurs arguments en un seul, pour
cela, la fonction <code>asArray</code> est nécessaire afin de constituer des tableaux
normaux avec des objets <code>arguments</code>. Elle copie leur contenu dans un vrai
tableau, si bien que la méthode <code>concat</code> peut lui être appliquée. Elle peut
prendre aussi un deuxième argument facultatif, permettant d’ignorer le ou les
premiers arguments.</p><p>Notez également qu’il faut stocker les <code>arguments</code> de la fonction externe
(<code>partial</code>) dans une variable avec un autre nom, sinon la fonction interne ne
peut pas les voir (elle a sa propre variable <code>arguments</code>, qui masque celle de
la fonction externe).</p><p>Maintenant, <code>equals(10)</code> peut s’écrire <code>partial(op[&quot;==&quot;], 10)</code>, sans nécessiter
d’écrire, pour l’occasion, une fonction <code>equals</code>. Et vous pouvez faire ceci :</p><pre class="code"><span class="variable">show</span>(<span class="variable">map</span>(<span class="variable">partial</span>(<span class="variable">op</span>[<span class="string">&quot;+&quot;</span>], <span class="atom">1</span>), [<span class="atom">0</span>, <span class="atom">2</span>, <span class="atom">4</span>, <span class="atom">6</span>, <span class="atom">8</span>, <span class="atom">10</span>]));</pre><p>La raison pour laquelle <code>map</code> prend son argument de fonction avant
l’organisation du tableau est qu’il est souvent utile d’appliquer partiellement
map en lui attribuant une fonction. Ce qui donne à la fonction davantage de
puissance, elle n’opère plus sur une seule valeur mais sur un tableau de
valeurs. Par exemple, si vous avez un tableau de tableaux de nombres, et que
vous voulez les mettre tous au carré, vous procédez ainsi :</p><pre class="code"><span class="keyword">function</span> <span class="variable">nombreAuCarre</span>(<span class="variabledef">x</span>) {<span class="keyword">return</span> <span class="localvariable">x</span> * <span class="localvariable">x</span>;}

<span class="variable">show</span>(<span class="variable">map</span>(<span class="variable">partial</span>(<span class="variable">map</span>, <span class="variable">nombreAuCarre</span>), [[<span class="atom">10</span>, <span class="atom">100</span>], [<span class="atom">12</span>, <span class="atom">16</span>], [<span class="atom">0</span>, <span class="atom">1</span>]]));</pre></div><hr/><div class="block"><p>Une dernière astuce qui peut être utile quand vous voulez combiner des
fonctions est la <a name="key15"></a>composition de fonctions. Au début de ce chapitre j’ai
montré une fonction <code>negate</code>, qui applique l’opérateur booléen <em>not</em> au
résultat de l’appel d’une fonction :</p><pre class="code"><span class="keyword">function</span> <span class="variable">negate</span>(<span class="variabledef">func</span>) {
  <span class="keyword">return</span> <span class="keyword">function</span>() {
    <span class="keyword">return</span> !<span class="localvariable">func</span>.<span class="property">apply</span>(<span class="atom">null</span>, <span class="localvariable">arguments</span>);
  };
}</pre><p>C’est un cas particulier d’une structure plus générale : appeler la fonction A,
puis appliquer la fonction B au résultat. La composition est un concept usuel
en mathématiques.  <a name="key16"></a>Elle peut être utilisée dans une fonction de
haut niveau de la façon suivante :</p><pre class="code"><span class="keyword">function</span> <span class="variable">compose</span>(<span class="variabledef">func1</span>, <span class="variabledef">func2</span>) {
  <span class="keyword">return</span> <span class="keyword">function</span>() {
    <span class="keyword">return</span> <span class="localvariable">func1</span>(<span class="localvariable">func2</span>.<span class="property">apply</span>(<span class="atom">null</span>, <span class="localvariable">arguments</span>));
  };
}

<span class="keyword">var</span> <span class="variable">isUndefined</span> = <span class="variable">partial</span>(<span class="variable">op</span>[<span class="string">&quot;===&quot;</span>], <span class="atom">undefined</span>);
<span class="keyword">var</span> <span class="variable">isDefined</span> = <span class="variable">compose</span>(<span class="variable">op</span>[<span class="string">&quot;!&quot;</span>], <span class="variable">isUndefined</span>);
<span class="variable">show</span>(<span class="variable">isDefined</span>(<span class="variable">Math</span>.<span class="property">PI</span>));
<span class="variable">show</span>(<span class="variable">isDefined</span>(<span class="variable">Math</span>.<span class="property">PIE</span>));</pre><p>Nous voilà en train de définir de nouvelles fonctions sans utiliser du tout le
mot-clé <code>function</code>. Cela peut être utile si vous avez besoin de créer une
fonction simple à passer, par exemple, à <code>map</code> ou <code>reduce</code>.  Toutefois, quand
une fonction devient plus complexe que ces exemples, il est généralement plus
rapide (sans parler du gain en efficacité) de l’écrire avec <code>function</code>.</p></div><ol class="footnotes"><li><a name="footnote1"></a>Comme ceci</li></ol><h1><span class="number">Chapitre 7: </span>Recherche</h1><div class="block"><p>Ce chapitre n’introduit pas de nouveaux concepts spécifiques à JavaScript. À la
place, nous allons étudier les solutions de deux problèmes, et discuter de
techniques et d’algorithmes intéressants tout au long du chapitre. Si cela ne
vous semble pas intéressant, il est possible de sauter ce chapitre.</p></div><hr/><div class="block"><p>Laissez-moi introduire notre premier problème. Jetez un coup d’œil à ce plan.
Il montre Hiva Oa, une petite île tropicale de l’océan Pacifique.</p><div class="illustration"><img src="img/Hiva Oa.png"/></div><p>Les lignes grises sont des routes, et les nombres à côté représentent la
longueur de ces routes. Imaginez que l’on ait besoin de connaître le chemin le
plus court pour relier deux endroits sur Hiva Oa. Quelle approche pourrait-on
adopter&nbsp;?</p><p>Non, vraiment, ne lisez pas le paragraphe en diagonale. Essayez de réfléchir
sérieusement aux manières de le faire, et réfléchissez aux problèmes que vous
pourriez rencontrer. Quand vous lisez un livre technique, il est bien trop
facile de parcourir le texte très rapidement, d’acquiescer solennellement et de
s’empresser d’oublier ce que l’on a lu. Si vous faites sérieusement un effort
pour résoudre un problème, il devient votre problème, et sa solution aura
vraiment du sens.</p></div><hr/><div class="block"><p>Le premier aspect de ce problème est, de nouveau, de représenter nos
informations. Les informations contenues dans l’image n’ont pas beaucoup de
sens pour l’ordinateur. On pourrait essayer de coder un programme qui
étudierait l’image et en extrairait des informations… Mais cela pourrait
devenir compliqué. Si on avait vingt mille cartes à interpréter, ce serait une
bonne idée. En l’occurrence, nous nous chargerons de faire l’interprétation
nous-mêmes, et convertirons les données du plan pour qu’elles soient
exploitables en langage informatique.</p><p>Que doit savoir notre programme&nbsp;? Il doit être capable de trouver quel lieux
sont connectés, et quelle distance font les routes qui les relient. Les lieux
et les routes sur l’île forment un <a name="key1"></a>graphe, comme les mathématiciens
l’appellent. Il y a plusieurs possibilités pour enregistrer les graphes. Une
solution simple consiste à enregistrer dans un tableau des objets de type
route, chacun étant doté de propriétés désignant ses deux extrémités et sa
longueur.</p><pre class="code"><span class="keyword">var</span> <span class="variable">routes</span> = [{<span class="property">point1</span>: <span class="string">&quot;Point Kiukiu&quot;</span>, <span class="property">point2</span>: <span class="string">&quot;Hanaiapa&quot;</span>, <span class="property">length</span>: <span class="atom">19</span>},
             {<span class="property">point1</span>: <span class="string">&quot;Point Kiukiu&quot;</span>, <span class="property">point2</span>: <span class="string">&quot;Mont Feani&quot;</span>, <span class="property">length</span>: <span class="atom">15</span>}
             <span class="comment">/* et ainsi de suite */</span>];</pre><p>Cependant, il s’avère que lorsque le programme essaiera de déterminer une
route, il aura très souvent besoin de consulter une liste de tous les routes
commençant à un point donné, tout comme une personne qui se situe à un
carrefour aura besoin de regarder les panneaux de direction et lire « Hanaiapa
: 19 km, Mont Feani : 15 km&nbsp;». Ce serait sympa si c’était facile (et rapide) à
faire.</p><p>Avec la représentation donnée au-dessus, nous devons éplucher tous les noms de
route en gardant ceux qui sont utiles chaque fois que nous voulons ces panneaux
de direction. Une meilleure technique serait d’enregistrer cette liste
directement. Par exemple, utiliser un objet qui associe les noms de lieux avec
la liste des panneaux :</p><pre class="code"><span class="keyword">var</span> <span class="variable">routes</span> = {<span class="string">&quot;Point Kiukiu&quot;</span>: [{<span class="property">to</span>: <span class="string">&quot;Hanaiapa&quot;</span>, <span class="property">distance</span>: <span class="atom">19</span>},
                              {<span class="property">to</span>: <span class="string">&quot;Mont Feani&quot;</span>, <span class="property">distance</span>: <span class="atom">15</span>},
                              {<span class="property">to</span>: <span class="string">&quot;Taaoa&quot;</span>, <span class="property">distance</span>: <span class="atom">15</span>}],
             <span class="string">&quot;Taaoa&quot;</span>: [<span class="comment">/* et cetera */</span>]};</pre><p>Quand nous avons cet objet, obtenir les routes qui partent du «&nbsp;Point Kiukiu&nbsp;»
revient juste à jeter un œil à <code>routes[&quot;Point Kiukiu&quot;]</code>.</p></div><hr/><div class="block"><p>Toutefois, cette nouvelle représentation contient des données dupliquées : la
route reliant A à B est listée à la fois dans A et dans B. La première
représentation demandait déjà beaucoup de travail pour rentrer les données,
avec celle-là c’est encore pire.</p><p>Heureusement, nous avons à notre disposition le talent de notre ordinateur pour
la répétition des tâches. On peut indiquer les routes une fois, et faire
générer par l’ordinateur la bonne structure de données. D’abord, définissez un
objet initial vide appelé <code>routes</code>, et écrivez une fonction <code>creerRoute</code> :</p><pre class="code"><span class="keyword">var</span> <span class="variable">routes</span> = {};
<span class="keyword">function</span> <span class="variable">creerRoute</span>(<span class="variabledef">depart</span>, <span class="variabledef">arrivee</span>, <span class="variabledef">distance</span>) {
  <span class="keyword">function</span> <span class="variabledef">ajouterRoute</span>(<span class="variabledef">depart</span>, <span class="variabledef">arrivee</span>) {
    <span class="keyword">if</span> (!(<span class="localvariable">depart</span> in <span class="variable">routes</span>))
      <span class="variable">routes</span>[<span class="localvariable">depart</span>] = [];
    <span class="variable">routes</span>[<span class="localvariable">depart</span>].<span class="property">push</span>({<span class="property">arrivee</span>: <span class="localvariable">arrivee</span>, <span class="property">distance</span>: <span class="localvariable">distance</span>});
  }
  <span class="localvariable">ajouterRoute</span>(<span class="localvariable">depart</span>, <span class="localvariable">arrivee</span>);
  <span class="localvariable">ajouterRoute</span>(<span class="localvariable">arrivee</span>, <span class="localvariable">depart</span>);
}</pre><p>Sympa, n’est-ce pas&nbsp;? Remarquez comment la fonction interne (<code>ajouterRoute</code>)
utilise les mêmes noms (<code>depart</code> et <code>arrivee</code>) pour ses paramètres que ceux de
la fonction externe.  Ils ne vont pas interférer : à l’intérieur de
<code>ajouterRoute</code>, ils correspondent aux paramètre de <code>ajouterRoute</code>, et à
l’extérieur, ils correspondent aux paramètres de <code>creerRoute</code>.</p><p>L’instruction <code>if</code> dans <code>ajouterRoute</code> s’assure qu’il y a un tableau de
destinations associées avec le lieu nommé par <code>depart</code>, et s’il n’y en a pas
encore, il ajoute une entrée vide. De cette façon, à la ligne suivante il peut
supposer que le tableau existe déjà et entrer la nouvelle route dedans.</p><p>Maintenant, les informations de la carte ressemblent à ceci :</p><pre class="code"><span class="variable">creerRoute</span>(<span class="string">&quot;Point Kiukiu&quot;</span>, <span class="string">&quot;Hanaiapa&quot;</span>, <span class="atom">19</span>);
<span class="variable">creerRoute</span>(<span class="string">&quot;Point Kiukiu&quot;</span>, <span class="string">&quot;Mont Feani&quot;</span>, <span class="atom">15</span>);
<span class="variable">creerRoute</span>(<span class="string">&quot;Point Kiukiu&quot;</span>, <span class="string">&quot;Taaoa&quot;</span>, <span class="atom">15</span>);
<span class="comment">// …</span></pre></div><hr/><div class="block"><a name="exercise1"></a><div class="exercisenum">Ex. 7.1</div><div class="exercise"><p>Dans la description ci-dessus, on a encore trois fois l’occurrence de la chaîne
de caractères <code>&quot;Point Kiukiu&quot;</code> à la suite. Nous pourrions générer une
description encore plus succincte en permettant à des routes multiples d’être
définies sur une seule ligne.</p><p>Écrivez une fonction <code>creerRoutes</code> qui accepte un nombre variable d’arguments.
Le premier argument est toujours le point de départ des routes, et chaque paire
d’arguments qui suit donne le point d’arrivée et une distance.</p><p>Ne dupliquez pas la fonctionnalité de <code>creerRoute</code>, mais demandez à
<code>creerRoutes</code> d’appeler <code>creerRoute</code> pour réaliser la véritable création de
route.</p></div><div class="solution"><pre class="code"><span class="keyword">function</span> <span class="variable">creerRoutes</span>(<span class="variabledef">depart</span>) {
  <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">i</span> = <span class="atom">1</span>; <span class="localvariable">i</span> &lt; <span class="localvariable">arguments</span>.<span class="property">length</span>; <span class="localvariable">i</span> += <span class="atom">2</span>)
    <span class="variable">creerRoute</span>(<span class="localvariable">depart</span>, <span class="localvariable">arguments</span>[<span class="localvariable">i</span>], <span class="localvariable">arguments</span>[<span class="localvariable">i</span> + <span class="atom">1</span>]);
}</pre><p>Cette fonction utilise un paramètre nommé, <code>depart</code>, et récupère les autres
paramètres dans le (presque-) tableau <code>arguments</code> . <code>i</code> démarre à <code>1</code> car il
doit ignorer le premier paramètre. <code>i += 2</code> est la simplification de l’équation
<code>i = i + 2</code>, comme vous vous rappelez sans doute.</p><pre class="code"><span class="keyword">var</span> <span class="variable">routes</span> = {};
<span class="variable">creerRoutes</span>(<span class="string">&quot;Point Kiukiu&quot;</span>, <span class="string">&quot;Hanaiapa&quot;</span>, <span class="atom">19</span>,
          <span class="string">&quot;Mont Feani&quot;</span>, <span class="atom">15</span>, <span class="string">&quot;Taaoa&quot;</span>, <span class="atom">15</span>);
<span class="variable">creerRoutes</span>(<span class="string">&quot;Airport&quot;</span>, <span class="string">&quot;Hanaiapa&quot;</span>, <span class="atom">6</span>, <span class="string">&quot;Mont Feani&quot;</span>, <span class="atom">5</span>,
          <span class="string">&quot;Atuona&quot;</span>, <span class="atom">4</span>, <span class="string">&quot;Mont Ootua&quot;</span>, <span class="atom">11</span>);
<span class="variable">creerRoutes</span>(<span class="string">&quot;Mont Temetiu&quot;</span>, <span class="string">&quot;Mont Feani&quot;</span>, <span class="atom">8</span>, <span class="string">&quot;Taaoa&quot;</span>, <span class="atom">4</span>);
<span class="variable">creerRoutes</span>(<span class="string">&quot;Atuona&quot;</span>, <span class="string">&quot;Taaoa&quot;</span>, <span class="atom">3</span>, <span class="string">&quot;Hanakee pearl lodge&quot;</span>, <span class="atom">1</span>);
<span class="variable">creerRoutes</span>(<span class="string">&quot;Cemetery&quot;</span>, <span class="string">&quot;Hanakee pearl lodge&quot;</span>, <span class="atom">6</span>, <span class="string">&quot;Mont Ootua&quot;</span>, <span class="atom">5</span>);
<span class="variable">creerRoutes</span>(<span class="string">&quot;Hanapaoa&quot;</span>, <span class="string">&quot;Mont Ootua&quot;</span>, <span class="atom">3</span>);
<span class="variable">creerRoutes</span>(<span class="string">&quot;Puamua&quot;</span>, <span class="string">&quot;Mont Ootua&quot;</span>, <span class="atom">13</span>, <span class="string">&quot;Point Teohotepapapa&quot;</span>, <span class="atom">14</span>);

<span class="variable">show</span>(<span class="variable">routes</span>[<span class="string">&quot;Airport&quot;</span>]);</pre></div></div><hr/><div class="block"><p>Nous avons réussi à réduire considérablement notre description des informations
sur les routes en définissant quelques opérations pratiques. On pourrait dire
que nous avons exprimé l’information de façon plus succincte en élargissant
notre vocabulaire. <a name="key2"></a>Définir un &quot;petit langage&quot; comme
ceci est une technique très puissante ―&nbsp;quand, à un moment, vous vous
retrouvez à écrire du code répétitif ou redondant, arrêtez-vous et essayez de
réduire ce code avec un vocabulaire qui le raccourcira et le condensera.</p><p>Le code redondant est non seulement ennuyeux à écrire mais aussi
potentiellement générateur d’erreurs. Les gens font moins attention quand ils
font des choses qui ne requiert pas de réflexion de leur part. En plus de cela,
le code répétitif est dur à modifier, parce qu’une structure, qui répète le
même motif un millier de fois, doit également être modifiée un millier de fois
si elle s’avère incorrecte ou suboptimale.</p></div><hr/><div class="block"><p>Si vous exécutez tous les morceaux de code ci-dessus, vous devriez avoir une
variable nommée <code>routes</code> qui contient toutes les routes de l’île. Quand nous
avons besoin de la liste des routes qui partent d’un certain lieu, nous pouvons
juste faire <code>routes[lieu]</code>. Mais si quelqu’un fait une coquille dans le nom
d’un endroit, ce qui est fort probable avec des noms pareils, il récupèrera un
<code>undefined</code> à la place du tableau qu’il attendait, et des erreurs étranges
peuvent survenir. Nous allons donc plutôt utiliser une fonction qui permet de
récupérer les tableaux de routes et qui nous hurle dessus si nous lui donnons
un nom de lieu inconnu :</p><pre class="code"><span class="keyword">function</span> <span class="variable">routesDepuis</span>(<span class="variabledef">lieu</span>) {
  <span class="keyword">var</span> <span class="variabledef">trouve</span> = <span class="variable">routes</span>[<span class="localvariable">lieu</span>];
  <span class="keyword">if</span> (<span class="localvariable">trouve</span> == <span class="atom">undefined</span>)
    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="variable">Error</span>(<span class="string">&quot;Auncun lieu nommé '&quot;</span> + <span class="localvariable">lieu</span> + <span class="string">&quot;' n’a été trouvé.&quot;</span>);
  <span class="keyword">else</span>
    <span class="keyword">return</span> <span class="localvariable">trouve</span>;
}

<span class="variable">show</span>(<span class="variable">routesDepuis</span>(<span class="string">&quot;Puamua&quot;</span>));</pre></div><hr/><div class="block"><p>Voici un premier jet pour un algorithme de recherche de chemin, la méthode du
joueur :</p><pre class="code"><span class="keyword">function</span> <span class="variable">routeDuJoueur</span>(<span class="variabledef">depart</span>, <span class="variabledef">arrivee</span>) {
  <span class="keyword">function</span> <span class="variabledef">entierAuHasard</span>(<span class="variabledef">seuil</span>) {
    <span class="keyword">return</span> <span class="variable">Math</span>.<span class="property">floor</span>(<span class="variable">Math</span>.<span class="property">random</span>() * <span class="localvariable">seuil</span>);
  }
  <span class="keyword">function</span> <span class="variabledef">directionAuHasard</span>(<span class="variabledef">depart</span>) {
    <span class="keyword">var</span> <span class="variabledef">options</span> = <span class="variable">routesDepuis</span>(<span class="localvariable">depart</span>);
    <span class="keyword">return</span> <span class="localvariable">options</span>[<span class="localvariable">entierAuHasard</span>(<span class="localvariable">options</span>.<span class="property">length</span>)].<span class="property">arrivee</span>;
  }

  <span class="keyword">var</span> <span class="variabledef">chemin</span> = [];
  <span class="keyword">while</span> (<span class="atom">true</span>) {
    <span class="localvariable">chemin</span>.<span class="property">push</span>(<span class="localvariable">depart</span>);
    <span class="keyword">if</span> (<span class="localvariable">depart</span> == <span class="localvariable">arrivee</span>)
      <span class="keyword">break</span>;
    <span class="localvariable">depart</span> = <span class="localvariable">directionAuHasard</span>(<span class="localvariable">depart</span>);
  }
  <span class="keyword">return</span> <span class="localvariable">chemin</span>;
}

<span class="variable">show</span>(<span class="variable">routeDuJoueur</span>(<span class="string">&quot;Hanaiapa&quot;</span>, <span class="string">&quot;Mont Feani&quot;</span>));</pre><p>À chaque branche de la route, le joueur lance son dé pour décider quelle route
il va prendre. Si le dé le renvoie à son lieu de départ, ainsi soit-il. Tôt ou
tard, il arrivera à destination, du moment que tous les endroits de l’île sont
reliés par des routes.</p><p>La ligne la plus déroutante est surement celle contenant <a name="key3"></a><code>Math.random</code>. Cette
fonction renvoie un nombre pseudo-aléatoire<a class="footref" href="#footnote1">1</a> entre 0 et 1. Essayez de
l’appeler un certain nombre de fois à la console, vous verrez qu’elle vous
donnera (fort probablement) un nombre différent à chaque fois. La fonction
<code>entierAuHasard</code> multiplie ce nombre par l’argument qui lui est donné et
arrondit le résultat au chiffre inférieur avec <code>Math.floor</code>. Ainsi par exemple,
<code>entierAuHasard(3)</code> renverra les chiffres <code>0</code>, <code>1</code> ou <code>2</code>.</p></div><hr/><div class="block"><p>La méthode du joueur est la manière de faire pour ceux qui abhorrent la
structuration et la planification, qui cherchent désespérément l’aventure. Nous
avons décidé d’écrire un programme qui peut trouver le chemin <em>le plus court</em>
pour aller d’un point à un autre, il nous faut donc utiliser une autre méthode.</p><p>Une approche très simple est de résoudre un tel problème par la méthode dite
«&nbsp;<a name="key4"></a>essais et erreurs&nbsp;». Il faut :</p><ol><li>Générer toutes les routes possibles.</li><li>Dans cet ensemble, trouver le plus court chemin qui connecte le point de départ au point d’arrivée.</li></ol><p>L’étape 2 n’est pas difficile. L’étape 1 est un peu plus problématique. Si vous
acceptez des routes avec des boucles, il existe une infinité de routes. Bien
sûr, il est peu probable que les routes avec des boucles soient les chemins les
plus courts pour aller d’un point à un autre, et les routes qui ne commencent
pas au point de départ ne doivent pas non plus être prises en compte. Pour un
petit graphe telle que Hiva Oa, il devrait être possible de générer des routes
non cycliques (exemptes de boucles) démarrant d’un lieu donné.</p></div><hr/><div class="block"><p>Mais d’abord, nous avons besoin de nouveaux outils. Le premier est une fonction
nommée <code>member</code>, qui est utilisée pour déterminer si un élément est présent
dans un tableau. L’itinéraire (que l’on appellera également route par la suite)
sera conservé comme un tableau de noms, et quand le voyageur arrivera à un
nouveau lieu, l’algorithme appellera <code>member</code> pour vérifier si le voyageur est
déjà passé par cet endroit. Cela peut ressembler à ça :</p><pre class="code"><span class="keyword">function</span> <span class="variable">member</span>(<span class="variabledef">tableau</span>, <span class="variabledef">valeur</span>) {
  <span class="keyword">var</span> <span class="variabledef">trouve</span> = <span class="atom">false</span>;
  <span class="variable">forEach</span>(<span class="localvariable">tableau</span>, <span class="keyword">function</span>(<span class="variabledef">element</span>) {
    <span class="keyword">if</span> (<span class="localvariable">element</span> === <span class="localvariable">valeur</span>)
      <span class="localvariable">trouve</span> = <span class="atom">true</span>;
  });
  <span class="keyword">return</span> <span class="localvariable">trouve</span>;
}

<span class="variable">print</span>(<span class="variable">member</span>([<span class="atom">6</span>, <span class="atom">7</span>, <span class="string">&quot;Bordeaux&quot;</span>], <span class="atom">7</span>));</pre><p>Toutefois, ceci va parcourir la totalité du tableau, même si la valeur est
trouvée immédiatement en première position. Quel gâchis. Quand vous utilisez
une boucle <code>for</code>, vous pouvez en sortir avec l’instruction <code>break</code>, mais dans
une structure <code>forEach</code> ceci ne fonctionnera pas, parce que le cœur de la
boucle est une fonction et l’instruction <code>break</code> n’interrompt pas une fonction.
Une solution pour être d’adapter <code>forEach</code> pour qu’il reconnaisse certains
types d’exceptions comme une un signal pour un arrêt (similaire à <code>break</code> dans
les boucles <code>for</code>)</p><pre class="code"><span class="keyword">var</span> <span class="variable">Break</span> = {<span class="property">toString</span>: <span class="keyword">function</span>() {<span class="keyword">return</span> <span class="string">&quot;Break&quot;</span>;}};

<span class="keyword">function</span> <span class="variable">forEach</span>(<span class="variabledef">tableau</span>, <span class="variabledef">action</span>) {
  <span class="keyword">try</span> {
    <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">i</span> = <span class="atom">0</span>; <span class="localvariable">i</span> &lt; <span class="localvariable">tableau</span>.<span class="property">length</span>; <span class="localvariable">i</span>++)
      <span class="localvariable">action</span>(<span class="localvariable">tableau</span>[<span class="localvariable">i</span>]);
  }
  <span class="keyword">catch</span> (<span class="variabledef">exception</span>) {
    <span class="keyword">if</span> (<span class="localvariable">exception</span> != <span class="variable">Break</span>)
      <span class="keyword">throw</span> <span class="localvariable">exception</span>;
  }
}</pre></div><hr/><div class="block"><p>Maintenant, si la fonction <code>action</code> lance un <code>Break</code>, <code>forEach</code> absorbera
l’exception et interrompra la boucle. L’objet stocké dans la variable <code>Break</code>
est utilisé exclusivement comme un élément de comparaison. La seule raison pour
laquelle je lui ai donné une propriété <code>toString</code> est qu’il pourrait être très
utile de trouver à quelle étrange valeur vous avez à faire si vous finissez par
récupérer une exception <code>Break</code> en-dehors d’un <code>forEach</code>.</p></div><hr/><div class="block"><p>Disposer d’un moyen de sortir de boucles <code>forEach</code> peut être très utile, mais
dans le cas de la fonction <code>member</code> le résultat demeure assez moche, parce que
vous avez besoin de stocker ce résultat particulier et de le retourner plus
tard. Nous pourrions encore ajouter une autre sorte d’exception, <code>Return</code>, à
laquelle on peut attribuer une propriété <code>value</code>, et faire en sorte que
<code>forEach</code> renvoie cette valeur lorsqu’une exception de ce genre est lancée,
mais ce serait vraiment spécifique à notre problème et plutôt confus. Ce dont
nous avons vraiment besoin c’est d’une nouvelle fonction de haut niveau,
appelée <a name="key5"></a><code>any</code> (ou quelquefois <code>some</code>). Elle ressemble à ceci :</p><pre class="code"><span class="keyword">function</span> <span class="variable">any</span>(<span class="variabledef">test</span>, <span class="variabledef">tableau</span>) {
  <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">i</span> = <span class="atom">0</span>; <span class="localvariable">i</span> &lt; <span class="localvariable">tableau</span>.<span class="property">length</span>; <span class="localvariable">i</span>++) {
    <span class="keyword">var</span> <span class="variabledef">trouve</span> = <span class="localvariable">test</span>(<span class="localvariable">tableau</span>[<span class="localvariable">i</span>]);
    <span class="keyword">if</span> (<span class="localvariable">trouve</span>)
      <span class="keyword">return</span> <span class="localvariable">trouve</span>;
  }
  <span class="keyword">return</span> <span class="atom">false</span>;
}

<span class="keyword">function</span> <span class="variable">member</span>(<span class="variabledef">tableau</span>, <span class="variabledef">valeur</span>) {
  <span class="keyword">return</span> <span class="variable">any</span>(<span class="variable">partial</span>(<span class="variable">op</span>[<span class="string">&quot;===&quot;</span>], <span class="localvariable">valeur</span>), <span class="localvariable">tableau</span>);
}

<span class="variable">print</span>(<span class="variable">member</span>([<span class="string">&quot;Peur&quot;</span>, <span class="string">&quot;Répugnance&quot;</span>], <span class="string">&quot;Rejet&quot;</span>));</pre><p><code>any</code> parcourt tous les éléments d’un tableau, de gauche à droite, et les
soumet à une fonction de test. Le premier élément ayant déclenché une réponse
<code>true</code> de la fonction de test est renvoyé. Si aucun élément ne déclenche de
réponse <code>true</code>, elle retourne <code>false</code>. Appeler <code>any(test, tableau)</code> est plus ou
moins équivalent à <code>test(tableau[0]) || test(tableau[1]) || …</code> et cætera.</p></div><hr/><div class="block"><p>Tout comme <code>&amp;&amp;</code> est le pendant de <code>||</code>, <code>any</code> a son pendant, appelé <a name="key6"></a><code>every</code> :</p><pre class="code"><span class="keyword">function</span> <span class="variable">every</span>(<span class="variabledef">test</span>, <span class="variabledef">tableau</span>) {
  <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">i</span> = <span class="atom">0</span>; <span class="localvariable">i</span> &lt; <span class="localvariable">tableau</span>.<span class="property">length</span>; <span class="localvariable">i</span>++) {
    <span class="keyword">var</span> <span class="variabledef">trouve</span> = <span class="localvariable">test</span>(<span class="localvariable">tableau</span>[<span class="localvariable">i</span>]);
    <span class="keyword">if</span> (!<span class="localvariable">trouve</span>)
      <span class="keyword">return</span> <span class="localvariable">trouve</span>;
  }
  <span class="keyword">return</span> <span class="atom">true</span>;
}

<span class="variable">show</span>(<span class="variable">every</span>(<span class="variable">partial</span>(<span class="variable">op</span>[<span class="string">&quot;!=&quot;</span>], <span class="atom">0</span>), [<span class="atom">1</span>, <span class="atom">2</span>, -<span class="atom">1</span>]));</pre></div><hr/><div class="block"><p>Une autre fonction dont nous aurons besoin est <code>flatten</code>. Cette fonction prend
un tableau de tableaux et met les éléments des tableaux dans un unique grand
tableau.</p><pre class="code">  <span class="keyword">function</span> <span class="variable">flatten</span>(<span class="variabledef">tableaux</span>) {
    <span class="keyword">var</span> <span class="variabledef">resultat</span> = [];
    <span class="variable">forEach</span>(<span class="localvariable">tableaux</span>, <span class="keyword">function</span> (<span class="variabledef">tableau</span>) {
      <span class="variable">forEach</span>(<span class="localvariable">tableau</span>, <span class="keyword">function</span> (<span class="variabledef">element</span>){<span class="localvariable">resultat</span>.<span class="property">push</span>(<span class="localvariable">element</span>);});
    });
    <span class="keyword">return</span> <span class="localvariable">resultat</span>;
  }</pre><p>La même chose pourrait être faite en utilisant la méthode <code>concat</code> et un genre
de <code>reduce</code>, mais ceci serait moins efficace. De la même manière, concaténer
ensemble des chaînes de caractères à de nombreuses reprises est plus lent que
les mettre dans un tableau puis appeler la méthode <code>join</code>. Concaténer ensemble
des tableaux de manière répétée produit beaucoup de tableaux intermédiaires et
inutiles.</p></div><hr/><div class="block"><a name="exercise2"></a><div class="exercisenum">Ex. 7.2</div><div class="exercise"><p>Avant de commencer à générer des routes, nous avons besoin d’une fonction
d’ordre supérieur supplémentaire. Celle-ci est appelée <a name="key7"></a><code>filter</code>. Tout comme
<code>map</code>, elle prend une fonction et un tableau en arguments, et produit un
nouveau tableau, mais au lieu de placer les résultats des appels à la fonction
dans le nouveau tableau, elle produit un tableau avec seulement les valeurs de
l’ancien tableau pour lequel la fonction donnée retourne <code>true</code> (ou une valeur
considérée équivalente a <code>true</code>). Écrivez cette fonction.</p></div><div class="solution"><pre class="code"><span class="keyword">function</span> <span class="variable">filter</span>(<span class="variabledef">test</span>, <span class="variabledef">tableau</span>) {
  <span class="keyword">var</span> <span class="variabledef">resultat</span> = [];
  <span class="variable">forEach</span>(<span class="localvariable">tableau</span>, <span class="keyword">function</span> (<span class="variabledef">element</span>) {
    <span class="keyword">if</span> (<span class="localvariable">test</span>(<span class="localvariable">element</span>))
      <span class="localvariable">resultat</span>.<span class="property">push</span>(<span class="localvariable">element</span>);
  });
  <span class="keyword">return</span> <span class="localvariable">resultat</span>;
}

<span class="variable">show</span>(<span class="variable">filter</span>(<span class="variable">partial</span>(<span class="variable">op</span>[<span class="string">&quot;&gt;&quot;</span>], <span class="atom">5</span>), [<span class="atom">0</span>, <span class="atom">4</span>, <span class="atom">8</span>, <span class="atom">12</span>]));</pre><p>(Si le résultat de cette utilisation de <code>filter</code> vous surprend, souvenez-vous
que l’argument donné à <code>partial</code> est utilisé comme le <em>premier</em> argument de la
fonction, de manière à ce qu’il se retrouve à la gauche de <code>&gt;</code>.)</p></div></div><hr/><div class="block"><p>Imaginez à quoi un algorithme permettant de générer des itinéraires pourrait
ressembler ―&nbsp;il commence au point de départ et génère un itinéraire pour
chaque route qui quitte ce lieu. À la fin de chaque route, il continue à
générer des itinéraires supplémentaires. Il ne parcourt pas un simple
itinéraire, il se ramifie. À cause de cela, la <a name="key8"></a>récursion est une manière
normale de modéliser cet algorithme.</p><pre class="code"><span class="keyword">function</span> <span class="variable">itinerairesPossibles</span>(<span class="variabledef">depart</span>, <span class="variabledef">arrivee</span>) {
  <span class="keyword">function</span> <span class="variabledef">trouverItineraires</span>(<span class="variabledef">itineraire</span>) {
    <span class="keyword">function</span> <span class="variabledef">pasParcouru</span>(<span class="variabledef">route</span>) {
      <span class="keyword">return</span> !<span class="variable">member</span>(<span class="localvariable">itineraire</span>.<span class="property">lieux</span>, <span class="localvariable">route</span>.<span class="property">arrivee</span>);
    }
    <span class="keyword">function</span> <span class="variabledef">continueItineraire</span>(<span class="variabledef">route</span>) {
      <span class="keyword">return</span> <span class="localvariable">trouverItineraires</span>({<span class="property">lieux</span>: <span class="localvariable">itineraire</span>.<span class="property">lieux</span>.<span class="property">concat</span>([<span class="localvariable">route</span>.<span class="property">arrivee</span>]),
                         <span class="property">length</span>: <span class="localvariable">itineraire</span>.<span class="property">length</span> + <span class="localvariable">route</span>.<span class="property">distance</span>});
    }

    <span class="keyword">var</span> <span class="variabledef">fin</span> = <span class="localvariable">itineraire</span>.<span class="property">lieux</span>[<span class="localvariable">itineraire</span>.<span class="property">lieux</span>.<span class="property">length</span> - <span class="atom">1</span>];
    <span class="keyword">if</span> (<span class="localvariable">fin</span> == <span class="localvariable">arrivee</span>)
      <span class="keyword">return</span> [<span class="localvariable">itineraire</span>];
    <span class="keyword">else</span>
      <span class="keyword">return</span> <span class="variable">flatten</span>(<span class="variable">map</span>(<span class="localvariable">continueItineraire</span>, <span class="variable">filter</span>(<span class="localvariable">pasParcouru</span>,
                                               <span class="variable">routesDepuis</span>(<span class="localvariable">fin</span>))));
  }
  <span class="keyword">return</span> <span class="localvariable">trouverItineraires</span>({<span class="property">lieux</span>: [<span class="localvariable">depart</span>], <span class="property">length</span>: <span class="atom">0</span>});
}

<span class="variable">show</span>(<span class="variable">itinerairesPossibles</span>(<span class="string">&quot;Point Teohotepapapa&quot;</span>, <span class="string">&quot;Point Kiukiu&quot;</span>).<span class="property">length</span>);
<span class="variable">show</span>(<span class="variable">itinerairesPossibles</span>(<span class="string">&quot;Hanapaoa&quot;</span>, <span class="string">&quot;Mont Ootua&quot;</span>));</pre><p>La fonction renvoie un tableau d’objets itinéraire, chacun contenant un tableau
de lieux parcourus par l’itinéraire et une longueur. <code>trouverItineraires</code>
continue un itinéraire récursivement, renvoyant un tableau avec toutes les
extensions possibles de cette route. Quand la fin de l’itinéraire est le lieu
défini comme lieu de fin, il retourne juste l’itinéraire, sachant que continuer
l’itinéraire serait absurde. Si c’est un autre lieu, il faut donc continuer. La
ligne contenant <code>flatten</code>/<code>map</code>/<code>filter</code> est probablement la plus dure à
appréhender. Voilà ce qu’elle dit : «&nbsp;Prends toutes les routes partant de ce
lieu, en te débarrassant de celles qui vont à des endroits que nous avons déjà
visités. Continue chacune de ces routes, ce qui donnera pour chacune d’entre
elles un tableau d’itinéraires finis, puis mets toutes ces routes dans un grand
tableau renvoyé en résultat&nbsp;».</p><p>Cette ligne fait beaucoup de choses. C’est en cela que les bonnes abstractions
sont utiles : elles vous permettent de dire des choses compliquées sans taper
des écrans entiers de code.</p><p>Ceci ne risque-t-il pas de se répéter indéfiniment, en continuant à s’appeler
lui-même (via <code>continueItineraire</code>)&nbsp;? Non, à un certain moment, toutes les
routes iront à des lieux déjà traversés par l’itinéraire, et le résultat de
<code>filter</code> sera un tableau vide. Cartographier un tableau vide renvoie un tableau
vide, l’écraser renvoie également un tableau vide. Donc appeler
<code>trouverItineraires</code> dans une impasse entraîne un tableau vide, qui signifie «
il n’y a aucun moyen de continuer cet itinéraire&nbsp;».</p><p>Veuillez noter que les lieux sont ajoutés à des itinéraires en utilisant
<a name="key9"></a><code>concat</code> et non <a name="key10"></a><code>push</code>. La méthode <code>concat</code> crée un nouveau tableau, alors
que <code>push</code> modifie le tableau existant. Comme cette fonction risque de faire
bifurquer divers itinéraires à partir d’une seule portion de route, il ne faut
pas modifier le tableau qui représente l’itinéraire original, parce qu’il doit
être utilisé plusieurs fois.</p></div><hr/><div class="block"><a name="exercise3"></a><div class="exercisenum">Ex. 7.3</div><div class="exercise"><p>Maintenant que nous avons tous les itinéraires possibles, essayons de trouver
le plus court. Écrivez une fonction <code>itineraireLePlusCourt</code> qui, tout comme
<code>itinerairesPossibles</code>, prend les noms des lieux de début et de fin en
arguments. Elle retournera un simple objet itinéraire, du même type que ce que
<code>itinerairesPossibles</code> produit.</p></div><div class="solution"><pre class="code"><span class="keyword">function</span> <span class="variable">itineraireLePlusCourt</span>(<span class="variabledef">depart</span>, <span class="variabledef">arrivee</span>) {
  <span class="keyword">var</span> <span class="variabledef">itineraireLePlusCourtTrouve</span> = <span class="atom">null</span>;
  <span class="variable">forEach</span>(<span class="variable">itinerairesPossibles</span>(<span class="localvariable">depart</span>, <span class="localvariable">arrivee</span>), <span class="keyword">function</span>(<span class="variabledef">itineraire</span>) {
    <span class="keyword">if</span> (!<span class="localvariable">itineraireLePlusCourtTrouve</span> || <span class="localvariable">itineraireLePlusCourtTrouve</span>.<span class="property">length</span> &gt; <span class="localvariable">itineraire</span>.<span class="property">length</span>)
      <span class="localvariable">itineraireLePlusCourtTrouve</span> = <span class="localvariable">itineraire</span>;
  });
  <span class="keyword">return</span> <span class="localvariable">itineraireLePlusCourtTrouve</span>;
}</pre><p>Le point épineux dans les algorithmes de «&nbsp;minimisation&nbsp;» ou de «&nbsp;maximisation
» est qu’il ne faut pas tout massacrer quand un tableau vide est passé à un tel
algorithme.  Dans notre cas, on sait qu’il y aura au moins une route entre 2
lieux donnés, donc nous pouvons simplement ignorer ce problème. Mais ce
raisonnement est un peu léger. Que faire si la route entre Puamua et le Mont
Ootua, qui est escarpée et boueuse, est emportée par une pluie torrentielle ?
Ce serait dommage que cela engendre une erreur dans notre fonction, donc il
faut que la fonction renvoie une valeur <code>null</code> quand aucun itinéraire n’est
trouvé.</p><p>Voici donc une approche très &quot;programmation fonctionnelle&quot;, aussi abstraite que
possible :</p><pre class="code"><span class="keyword">function</span> <span class="variable">minimise</span>(<span class="variabledef">func</span>, <span class="variabledef">tableau</span>) {
  <span class="keyword">var</span> <span class="variabledef">plusPetitScore</span> = <span class="atom">null</span>;
  <span class="keyword">var</span> <span class="variabledef">trouve</span> = <span class="atom">null</span>;
  <span class="variable">forEach</span>(<span class="localvariable">tableau</span>, <span class="keyword">function</span>(<span class="variabledef">element</span>) {
    <span class="keyword">var</span> <span class="variabledef">score</span> = <span class="localvariable">func</span>(<span class="localvariable">element</span>);
    <span class="keyword">if</span> (<span class="localvariable">plusPetitScore</span> == <span class="atom">null</span> || <span class="localvariable">score</span> &lt; <span class="localvariable">plusPetitScore</span>) {
      <span class="localvariable">plusPetitScore</span> = <span class="localvariable">score</span>;
      <span class="localvariable">trouve</span> = <span class="localvariable">element</span>;
    }
  });
  <span class="keyword">return</span> <span class="localvariable">trouve</span>;
}

<span class="keyword">function</span> <span class="variable">getProperty</span>(<span class="variabledef">nomDePropriete</span>) {
  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="variabledef">objet</span>) {
    <span class="keyword">return</span> <span class="localvariable">objet</span>[<span class="localvariable">nomDePropriete</span>];
  };
}

<span class="keyword">function</span> <span class="variable">itineraireLePlusCourt</span>(<span class="variabledef">depart</span>, <span class="variabledef">arrivee</span>) {
  <span class="keyword">return</span> <span class="variable">minimise</span>(<span class="variable">getProperty</span>(<span class="string">&quot;length&quot;</span>), <span class="variable">itinerairesPossibles</span>(<span class="localvariable">depart</span>, <span class="localvariable">arrivee</span>));
}</pre><p>Malheureusement, cette version est trois fois plus longue que l’autre. Dans les
programmes où vous voulez minimiser un certain nombre de choses, il peut être
intéressant d’écrire un algorithme générique comme celui-ci, que vous pourrez
réutiliser. Dans la plupart des cas, la première version suffira.</p><p>Notez toutefois la fonction <a name="key11"></a><code>getProperty</code>, elle est souvent utile quand on
fait de la programmation fonctionnelle avec des objets.</p></div></div><hr/><div class="block"><p>Voyons à quel trajet aboutit notre algorithme entre la pointe Kiukiu et la
pointe Teohotepapapa…</p><pre class="code"><span class="variable">show</span>(<span class="variable">itineraireLePlusCourt</span>(<span class="string">&quot;Point Kiukiu&quot;</span>, <span class="string">&quot;Point Teohotepapapa&quot;</span>).<span class="property">lieux</span>);</pre></div><hr/><div class="block"><p>Sur une petite île comme Hiva Oa, ce n’est pas une tâche insurmontable de
générer tous les itinéraires possibles. Si vous essayez de faire ça sur une
carte raisonnablement détaillée de la Belgique, par exemple, cela va prendre un
temps ridiculement long, sans parler d’une quantité de mémoire démentielle.
Pourtant, vous avez sans doute déjà vu de tels planificateurs d’itinéraires en
ligne. Ils vous indiquent un trajet plus ou moins idéal parmi un énorme
labyrinthe de routes possibles en quelques secondes à peine. Comment font-ils
ça&nbsp;?</p><p>Si vous êtes attentif, vous avez peut-être remarqué qu’il n’est pas nécessaire
de générer tous les itinéraires jusqu’au bout. Si nous comparons les
itinéraires <em>pendant</em> que nous les élaborons, nous pouvons éviter de calculer
un ensemble volumineux d’itinéraire, dès que nous avons trouvé un premier
itinéraire pour notre destination, nous pouvons cesser l’extension des autres
itinéraires plus longs que celui-ci.</p></div><hr/><div class="block"><p>Pour essayer, nous utiliserons une grille de 20 sur 20 en guise de carte :</p><div class="illustration"><img src="img/height.png"/></div><p>Ce que vous voyez là est une carte en relief d’un terrain montagneux. Les
points jaunes représentent les pics, et les zones bleues, les vallées. La zone
est divisée en carrés de 100 mètres de côté. Nous disposons d’une fonction
<code>altitudeEn</code>, qui peut nous donner l’altitude en mètres, de n’importe quel
carré de cette carte, dans laquelle les carrés sont représentés par des objets
avec des propriétés <code>x</code> et <code>y</code>.</p><pre class="code"><span class="variable">print</span>(<span class="variable">altitudeEn</span>({<span class="property">x</span>: <span class="atom">0</span>, <span class="property">y</span>: <span class="atom">0</span>}));
<span class="variable">print</span>(<span class="variable">altitudeEn</span>({<span class="property">x</span>: <span class="atom">11</span>, <span class="property">y</span>: <span class="atom">18</span>}));</pre></div><hr/><div class="block"><p>Nous voulons traverser ce territoire à pied, en partant en haut à gauche pour
arriver en bas à droite. Une grille peut être assimilée à un graphe. Chaque
carré est un nœud connecté aux carrés qui l’entourent.</p><p>Nous n’aimons pas gaspiller l’énergie, donc nous préférons prendre le chemin le
plus facile. Monter est plus pénible que descendre, et descendre plus pénible
que marcher sur un terrain plat<a class="footref" href="#footnote2">2</a>. Cette fonction calcule le «&nbsp;dénivelé&nbsp;» entre
deux carrés adjacents, qui représente l’intensité de la fatigue que vous
éprouvez à marcher ou grimper de l’un à l’autre. On considère que monter est
deux fois plus pénible que descendre.</p><pre class="code"><span class="keyword">function</span> <span class="variable">distancePonderee</span>(<span class="variabledef">pointA</span>, <span class="variabledef">pointB</span>) {
  <span class="keyword">var</span> <span class="variabledef">differenceHauteur</span> = <span class="variable">altitudeEn</span>(<span class="localvariable">pointB</span>) - <span class="variable">altitudeEn</span>(<span class="localvariable">pointA</span>);
  <span class="keyword">var</span> <span class="variabledef">facteurElevation</span> = (<span class="localvariable">differenceHauteur</span> &lt; <span class="atom">0</span> ? <span class="atom">1</span> : <span class="atom">2</span>);
  <span class="keyword">var</span> <span class="variabledef">distanceaPlat</span> = (<span class="localvariable">pointA</span>.<span class="property">x</span> == <span class="localvariable">pointB</span>.<span class="property">x</span> || <span class="localvariable">pointA</span>.<span class="property">y</span> == <span class="localvariable">pointB</span>.<span class="property">y</span> ? <span class="atom">100</span> : <span class="atom">141</span>);
  <span class="keyword">return</span> <span class="localvariable">distanceaPlat</span> + <span class="localvariable">facteurElevation</span> * <span class="variable">Math</span>.<span class="property">abs</span>(<span class="localvariable">differenceHauteur</span>);
}</pre><p>Notez le calcul de <code>distanceaPlat</code>. Si les deux points sont sur la même ligne
ou colonne, ils sont contigus, et la distance qui les sépare est cent mètres.
Sinon, on considère qu’ils sont adjacents en diagonale, et la distance en
diagonale entre deux carrés de cette taille est cent fois la racine carrée de
deux, ce qui fait à peu près <code>141</code>. Cette fonction ne doit pas être appelée
pour des carrés qui sont éloignés de plus d’une unité (elle pourrait faire une
double vérification … mais elle est trop paresseuse).</p></div><hr/><div class="block"><p>Les points sur la carte sont représentés par des objets contenant des
propriétés <code>x</code> et <code>y</code>. Ces trois fonctions sont utiles quand on travaille sur
de tels objets :</p><pre class="code"><span class="keyword">function</span> <span class="variable">point</span>(<span class="variabledef">x</span>, <span class="variabledef">y</span>) {
  <span class="keyword">return</span> {<span class="property">x</span>: <span class="localvariable">x</span>, <span class="property">y</span>: <span class="localvariable">y</span>};
}

<span class="keyword">function</span> <span class="variable">ajouterPoints</span>(<span class="variabledef">a</span>, <span class="variabledef">b</span>) {
  <span class="keyword">return</span> <span class="variable">point</span>(<span class="localvariable">a</span>.<span class="property">x</span> + <span class="localvariable">b</span>.<span class="property">x</span>, <span class="localvariable">a</span>.<span class="property">y</span> + <span class="localvariable">b</span>.<span class="property">y</span>);
}

<span class="keyword">function</span> <span class="variable">pointsIdentiques</span>(<span class="variabledef">a</span>, <span class="variabledef">b</span>) {
  <span class="keyword">return</span> <span class="localvariable">a</span>.<span class="property">x</span> == <span class="localvariable">b</span>.<span class="property">x</span> &amp;&amp; <span class="localvariable">a</span>.<span class="property">y</span> == <span class="localvariable">b</span>.<span class="property">y</span>;
}

<span class="variable">show</span>(<span class="variable">pointsIdentiques</span>(<span class="variable">ajouterPoints</span>(<span class="variable">point</span>(<span class="atom">10</span>, <span class="atom">10</span>), <span class="variable">point</span>(<span class="atom">4</span>, -<span class="atom">2</span>)),
               <span class="variable">point</span>(<span class="atom">14</span>, <span class="atom">8</span>)));</pre></div><hr/><div class="block"><a name="exercise4"></a><div class="exercisenum">Ex. 7.4</div><div class="exercise"><p>Si nous nous mettons à chercher des trajets sur cette carte, nous aurons encore
besoin de créer des «&nbsp;panneaux&nbsp;», des listes de directions que l’on peut
prendre à un point donné. Écrivez une fonction <code>directionsPossible</code> qui prend
un objet point comme argument et renvoie un tableau des points qui
l’environnent. Nous pouvons nous déplacer seulement vers des points adjacents,
à la fois en ligne droite et en diagonale, si bien que les carrés ont au
maximum huit carrés voisins. Prenez garde à ne pas renvoyer des carrés qui se
trouveraient en-dehors de la carte. Pour autant qu’on sache, le bord de la
carte pourrait bien être le bord du monde.</p></div><div class="solution"><pre class="code"><span class="keyword">function</span> <span class="variable">directionsPossible</span>(<span class="variabledef">depart</span>) {
  <span class="keyword">var</span> <span class="variabledef">dimensionCarte</span> = <span class="atom">20</span>;
  <span class="keyword">function</span> <span class="variabledef">dansLaCarte</span>(<span class="variabledef">point</span>) {
    <span class="keyword">return</span> <span class="localvariable">point</span>.<span class="property">x</span> &gt;= <span class="atom">0</span> &amp;&amp; <span class="localvariable">point</span>.<span class="property">x</span> &lt; <span class="localvariable">dimensionCarte</span> &amp;&amp;
           <span class="localvariable">point</span>.<span class="property">y</span> &gt;= <span class="atom">0</span> &amp;&amp; <span class="localvariable">point</span>.<span class="property">y</span> &lt; <span class="localvariable">dimensionCarte</span>;
  }

  <span class="keyword">var</span> <span class="variabledef">directions</span> = [<span class="variable">point</span>(-<span class="atom">1</span>, <span class="atom">0</span>), <span class="variable">point</span>(<span class="atom">1</span>, <span class="atom">0</span>), <span class="variable">point</span>(<span class="atom">0</span>, -<span class="atom">1</span>),
                    <span class="variable">point</span>(<span class="atom">0</span>, <span class="atom">1</span>), <span class="variable">point</span>(-<span class="atom">1</span>, -<span class="atom">1</span>), <span class="variable">point</span>(-<span class="atom">1</span>, <span class="atom">1</span>),
                    <span class="variable">point</span>(<span class="atom">1</span>, <span class="atom">1</span>), <span class="variable">point</span>(<span class="atom">1</span>, -<span class="atom">1</span>)];
  <span class="keyword">return</span> <span class="variable">filter</span>(<span class="localvariable">dansLaCarte</span>, <span class="variable">map</span>(<span class="variable">partial</span>(<span class="variable">ajouterPoints</span>, <span class="localvariable">depart</span>),
                               <span class="localvariable">directions</span>));
}

<span class="variable">show</span>(<span class="variable">directionsPossible</span>(<span class="variable">point</span>(<span class="atom">0</span>, <span class="atom">0</span>)));</pre><p>J’ai créé une variable <code>dimensionCarte</code>, dans le seul but de ne pas avoir à
écrire deux fois <code>20</code>. Si, à un autre moment, nous voulons utiliser la même
fonction pour une autre carte, ce serait laborieux avec un code farci de <code>20</code>,
qu’il faudrait tous remplacer un à un. Nous pourrions même aller jusqu’à
utiliser <code>dimensionCarte</code> comme argument de <code>directionsPossible</code>, pour pouvoir
utiliser la fonction pour différentes cartes sans les modifier. J’ai estimé que
ce n’était pas nécessaire dans ce cas, de telles choses peuvent toujours être
modifiées quand le besoin s’en fait sentir.</p><p>Alors, pourquoi n’ai-je pas ajouté une variable pour stocker <code>0</code>, qui apparaît
également à plusieurs reprises&nbsp;? J’ai fait comme si les cartes commençaient
toujours à <code>0</code>, donc il est peu probable que cela change, et utiliser une
variable pour cela ne fait qu’ajouter du bruit.</p></div></div><hr/><div class="block"><p>Pour trouver une route sur cette carte sans que notre navigateur n’interrompe
le programme parce qu’il prend trop de temps à se terminer, nous devons arrêter
de faire de l’amateurisme et mettre en œuvre un algorithme sérieux. Beaucoup de
travail a été consacré à de tels problèmes dans le passé, et beaucoup de
solutions ont été conçues (certaines brillantes, d’autres inutiles). Une
solution très populaire et efficace est nommé <a name="key12"></a>A* (prononcé A étoile). Nous
allons consacrer le reste de ce chapitre à intégrer une fonction de recherche
d’itinéraire A* pour notre carte.</p><p>Avant que je me penche sur l’algorithme en lui-même, laissez-moi vous en dire
un peu plus sur le problème qu’il résout. Le problème avec la recherche de
routes par l’intermédiaire de graphes, c’est que dans les grands graphes, il y
a énormément de routes. Notre chercheur de route Hiva Oa nous a montré que
quand le graphe est petit, tout ce que l’on avait besoin de faire c’était de
s’assurer que nos itinéraires ne repassaient pas par des points où ils étaient
déjà passés. Sur notre nouvelle carte, ceci ne suffit plus.</p><p>Le problème fondamental, c’est qu’il y a trop de possibilités pour aller dans
la mauvaise direction. À moins de savoir comment nous diriger vers la
destination pendant l’exploration des chemins, un choix que nous faisons pour
poursuivre une route donnée va plus probablement nous faire emprunter le
mauvais chemin plutôt que le bon. Si vous continuez à générer des itinéraires
de cette façon, et même si l’un d’entre eux atteint la cible de manière
accidentelle, vous ne savez pas si c’est le chemin le plus court.</p><p>Donc ce que vous voulez faire, c’est explorer les directions susceptibles de
vous amener à la destination finale en premier. Sur une grille comme sur une
carte, vous pouvez avoir une petite estimation de l’optimisation d’un tracé en
vérifiant sa longueur et la proximité de sa destination avec la cible. En
ajoutant sa longueur à l’estimation de la distance restante, vous pouvez vous
faire une bonne idée des itinéraires qui sont prometteurs. Si vous prolongez
les itinéraires prometteurs en premier, vous avez moins de risques de perdre du
temps avec ceux qui sont inutiles.</p></div><hr/><div class="block"><p>Mais cela ne suffit pas encore. Si notre carte était celle d’un monde
parfaitement plat, le chemin qui semble prometteur serait presque toujours le
meilleur, et nous pourrions utiliser la méthode ci-dessus pour nous rendre
directement au but. Mais nous avons des vallées et des collines sur notre
chemin, donc il est difficile de prédire à l’avance quel itinéraire sera le
plus direct. À cause de cela, nous finissons toujours pas explorer beaucoup
trop de possibilités différentes.</p><p>Pour y remédier, nous pouvons tirer parti du fait que nous recherchons sans
arrêt l’itinéraire le plus prometteur. Une fois que l’on a déterminé que le
chemin A est le meilleur moyen de se rendre au point X, nous pouvons nous en
souvenir. Quand plus tard le chemin B se rend aussi au point X, nous savons que
ce n’est pas la meilleure route, donc nous n’avons pas à faire plus de
recherches dessus. Ceci peut éviter à notre programme de calculer beaucoup
d’itinéraires inutiles.</p></div><hr/><div class="block"><p>Donc, l’algorithme ressemble à quelque chose comme ça :</p><p>Il y a deux ensembles de données pour garder un historique. Le premier est
appelé la liste ouverte, elle contient des itinéraires partiels qui doivent
toujours être explorés. Chaque chemin a une note, qui est calculée en
additionnant sa longueur à la distance estimée qui sépare du but. Cette
estimation doit toujours être optimiste, elle ne doit jamais exagérer la
longueur. Le second est un ensemble de nœuds que nous avons parcourus, avec
l’itinéraire partiel qui nous y a amené. Celui-ci, nous l’appellerons la liste
des nœuds atteints. On commence en ajoutant à la liste ouverte un itinéraire
qui contient uniquement le nœud de départ et on l’enregistre dans la liste des
nœuds atteints.</p><p>Puis, tant qu’il y a des nœuds dans la liste ouverte, nous prenons celui qui a
le plus petit score (donc le meilleur), et nous trouvons les directions dans
lesquelles il peut continuer (en appelant <code>directionsPossible</code>). Pour chaque
nœud obtenu en retour, nous créons un nouveau chemin en le rattachant à notre
route initiale et en ajustant la longueur du chemin par l’intermédiaire de
<code>distancePonderee</code>. L’extrémité de chacun de ces itinéraires est ensuite
recherchée dans la liste des nœuds atteints.</p><p>Si le nœud n’est pas dans la liste des nœuds atteints, cela veut dire que nous
ne l’avons pas encore rencontré avant, nous ajoutons le nouveau chemin à la
liste ouverte, et nous l’enregistrons dans la liste des nœuds parcourus. Si
nous l’<em>avons</em> vu avant, nous comparons la note du nouvel itinéraire aux notes
des autres itinéraires de la liste des nœuds parcourus. Si le nouveau chemin
est plus court, on remplace la route existante avec la nouvelle. Autrement, on
se débarrasse du nouvel itinéraire puisque on a déjà une manière plus rapide de
se rendre à ce point.</p><p>On continue ainsi jusqu’à ce que l’itinéraire que nous sortons de la liste des
nœuds parcourus atteigne le nœud correspondant au but ultime, auquel cas nous
avons trouvé notre itinéraire, ou jusqu’à ce que la liste des nœuds parcourus
soit vide, auquel cas nous nous sommes rendus compte qu’il n’y a pas de route.
Dans notre cas, la carte ne contient pas d’obstacles insurmontables, donc il y
a toujours un chemin.</p><p>Comment savons-nous que le premier itinéraire complet que nous obtenons de la
liste des nœuds parcourus est le plus direct&nbsp;? C’est la conséquence du fait que
nous nous intéressons seulement à un chemin quand il fait le score le plus bas.
Le score d’un itinéraire est sa longueur actuelle additionnée d’un estimation
<em>optimiste</em> de sa longueur restante. Cela veut dire que si un itinéraire
obtient la note la plus basse dans la liste ouverte, c’est toujours le chemin
le plus direct vers sa destination finale, il est impossible qu’un autre
itinéraire puisse trouver plus tard une meilleure route vers ce point, car si
elle était meilleure, son score aurait été plus bas.</p></div><hr/><div class="block"><p>Essayez de ne pas vous énerver lorsque les subtilités de ce fonctionnement vous
échappent. Quand on réfléchit à des algorithmes tels que ceux-là, avoir vu
avant «&nbsp;quelque chose qui y ressemble&nbsp;» aide beaucoup, cela vous donne un point
de repère pour comparer les approches. Les programmeurs débutants doivent faire
sans de tels points de repères, ce qui peut les amener facilement à s’égarer.
Ayez simplement conscience que ce travail est d’un niveau assez avancé, faites
une lecture globale du reste du chapitre, et revenez-y plus tard quand vous
vous sentirez de taille à relever le défi.</p></div><hr/><div class="block"><p>Je suis désolé de vous l’annoncer, mais pour une partie de l’algorithme, je
vais encore devoir invoquer la magie. La liste ouverte nécessite de pouvoir
disposer d’une grande quantité de routes, et de trouver rapidement celle qui
fait le plus petit score. Les enregistrer dans un tableau normal et parcourir
ce tableau chaque fois est beaucoup trop lent, je vous donne donc une structure
de données appelée <a name="key13"></a>tas binaire. Vous les créez avec <code>new</code>, tout comme les
objets <code>Date</code>, en leur donnant une fonction qui est utilisée pour «&nbsp;donner un
score&nbsp;» aux éléments passés en argument. L’objet résultant possède les méthodes
<code>push</code> et <code>pop</code>, tout comme un tableau, mais <code>pop</code> donne toujours l’élément
avec le plus petit score, au lieu de donner celui qui a été ajouté (avec la
méthode <code>push</code>) en dernier.</p><pre class="code"><span class="keyword">function</span> <span class="variable">identity</span>(<span class="variabledef">x</span>) {
  <span class="keyword">return</span> <span class="localvariable">x</span>;
}

<span class="keyword">var</span> <span class="variable">tasBinaire</span> = <span class="keyword">new</span> <span class="variable">BinaryHeap</span>(<span class="variable">identity</span>);
<span class="variable">forEach</span>([<span class="atom">2</span>, <span class="atom">4</span>, <span class="atom">5</span>, <span class="atom">1</span>, <span class="atom">6</span>, <span class="atom">3</span>], <span class="keyword">function</span>(<span class="variabledef">nombre</span>) {
  <span class="variable">tasBinaire</span>.<span class="property">push</span>(<span class="localvariable">nombre</span>);
});
<span class="keyword">while</span> (<span class="variable">tasBinaire</span>.<span class="property">size</span>() &gt; <span class="atom">0</span>)
  <span class="variable">show</span>(<span class="variable">tasBinaire</span>.<span class="property">pop</span>());</pre><p>L’<a href="appendix2.html">appendice 2</a> traite de l’implémentation de la structure de données, ce qui
est assez intéressant. Après avoir lu le <a href="chapter8.html">chapitre 8</a>, vous pourriez vouloir jeter un
œil dessus.</p></div><hr/><div class="block"><p>Les nécessités de l’optimisation peuvent avoir un autre effet. L’algorithme
d’Hiva Oa utilisait des tableaux de destination pour enregistrer les routes, et
copiait celles-ci avec la méthode <code>concat</code> quand il allongeait ces routes.
Cette fois, nous ne pouvons pas nous permettre de copier des tableaux puisque
nous explorerons des tonnes de chemins. Nous allons donc plutôt utiliser une «
chaîne&nbsp;» d’objets pour stocker une route. Chaque objet dans la chaîne possède
des propriétés, notamment la position sur la carte et la longueur de la route
déjà effectuée, mais garde également en mémoire une propriété qui pointe vers
l’objet précédent de la chaîne. Ça donne quelque chose comme ça :</p><div class="illustration"><img src="img/objectchain.png"/></div><p>Les cercles couleur cyan sont les objet utiles, et les lignes sont les
propriétés. L’objet <code>A</code> est le début de la route ici. L’objet <code>B</code> est utilisé
pour construire un nouveau tracé qui se prolonge après <code>A</code>. Quand on doit plus
tard reconstruire une route, on peut se reposer sur ces propriétés pour trouver
tous les points par où la route est passée. On remarque que l’objet <code>B</code>
appartient à deux routes, une qui se termine en <code>D</code>, et une autre qui se
termine en <code>E</code>. Quand il y a beaucoup de routes, cela peut nous faire
économiser beaucoup d’espace mémoire, chaque nouvelle route nécessite seulement
un nouvel objet pour elle-même, le reste est partagé avec les autres routes qui
ont commencé de la même manière.</p></div><hr/><div class="block"><a name="exercise5"></a><div class="exercisenum">Ex. 7.5</div><div class="exercise"><p>Écrivez une fonction <code>distanceEstimee</code> qui donne une estimation optimiste de la
distance séparant deux emplacements. Elle n’a pas besoin de s’intéresser aux
données d’altitude, mais peut supposer que le terrain est plat. Rappelez-vous
que l’on se déplace seulement tout droit et en diagonale, et que l’on compte
les déplacements en diagonale entre deux carrés comme valant <code>141</code>.</p></div><div class="solution"><pre class="code"><span class="keyword">function</span> <span class="variable">distanceEstimee</span>(<span class="variabledef">pointA</span>, <span class="variabledef">pointB</span>) {
  <span class="keyword">var</span> <span class="variabledef">dx</span> = <span class="variable">Math</span>.<span class="property">abs</span>(<span class="localvariable">pointA</span>.<span class="property">x</span> - <span class="localvariable">pointB</span>.<span class="property">x</span>),
      <span class="variabledef">dy</span> = <span class="variable">Math</span>.<span class="property">abs</span>(<span class="localvariable">pointA</span>.<span class="property">y</span> - <span class="localvariable">pointB</span>.<span class="property">y</span>);
  <span class="keyword">if</span> (<span class="localvariable">dx</span> &gt; <span class="localvariable">dy</span>)
    <span class="keyword">return</span> (<span class="localvariable">dx</span> - <span class="localvariable">dy</span>) * <span class="atom">100</span> + <span class="localvariable">dy</span> * <span class="atom">141</span>;
  <span class="keyword">else</span>
    <span class="keyword">return</span> (<span class="localvariable">dy</span> - <span class="localvariable">dx</span>) * <span class="atom">100</span> + <span class="localvariable">dx</span> * <span class="atom">141</span>;
}</pre><p>Ces formules étranges sont utilisées pour décomposer le trajet en une partie
rectiligne et une partie en diagonale. Si vous avec un trajet tel que
celui-là :</p><div class="illustration"><img src="img/diagonalpath.png"/></div><p>… le chemin fait <code>6</code> cases de larges et <code>4</code> de haut, donc vous avez <code>6 - 3 = 3</code>
déplacements rectilignes et <code>3</code> déplacements en diagonales.</p><p>Si vous écriviez une fonction qui calcule la distance «&nbsp;pythagoricienne&nbsp;»
directe entre ces points, cela fonctionnerait aussi. Nous avons besoin d’une
estimation optimiste, et supposer que nous pouvons aller tout droit vers notre
but est certainement optimiste. Quoi qu’il en soit, plus notre estimation est
correcte, moins notre programme essaiera des itinéraires inutiles.</p></div></div><hr/><div class="block"><a name="exercise6"></a><div class="exercisenum">Ex. 7.6</div><div class="exercise"><p>Nous allons utiliser un tas binaire pour stocker la liste ouverte. Quelle
structure serait la bonne pour la liste des nœuds atteints&nbsp;? Cette liste sera
utilisée pour chercher des routes, en lui passant un couple <code>x</code>, <code>y</code> de
coordonnées. Rapidement de préférence. Écrivez trois fonctions
<code>creerListePointsParcourus</code>, <code>stockerPointsParcourus</code>, et
<code>trouverPointsParcourus</code>. La première crée la structure de données&nbsp;; la
seconde, étant donné une liste de nœuds atteints, un point, et une route,
stocke cette route; la dernière, étant donné une liste de nœuds atteints et un
point, retourne une route ou <code>undefined</code> pour indiquer qu’aucune route n’a été
trouvée pour ce point.</p></div><div class="solution"><p>Une idée raisonnable serait d’utiliser un objet avec des objets à l’intérieur.
Une des coordonnées des points, par exemple <code>x</code>, est utilisé comme nom de
propriété pour l’objet extérieur, et l’autre, <code>y</code>, pour l’objet intérieur. Cela
va nécessiter un peu de tenue de compte pour gérer le fait que, parfois,
l’objet intérieur que nous recherchons n’existe pas (encore).</p><pre class="code"><span class="keyword">function</span> <span class="variable">creerListePointsParcourus</span>() {
  <span class="keyword">return</span> {};
}

<span class="keyword">function</span> <span class="variable">stockerPointsParcourus</span>(<span class="variabledef">liste</span>, <span class="variabledef">point</span>, <span class="variabledef">itineraire</span>) {
  <span class="keyword">var</span> <span class="variabledef">listeInterne</span> = <span class="localvariable">liste</span>[<span class="localvariable">point</span>.<span class="property">x</span>];
  <span class="keyword">if</span> (<span class="localvariable">listeInterne</span> == <span class="atom">undefined</span>) {
    <span class="localvariable">listeInterne</span> = {};
    <span class="localvariable">liste</span>[<span class="localvariable">point</span>.<span class="property">x</span>] = <span class="localvariable">listeInterne</span>;
  }
  <span class="localvariable">listeInterne</span>[<span class="localvariable">point</span>.<span class="property">y</span>] = <span class="localvariable">itineraire</span>;
}

<span class="keyword">function</span> <span class="variable">trouverPointsParcourus</span>(<span class="variabledef">liste</span>, <span class="variabledef">point</span>) {
  <span class="keyword">var</span> <span class="variabledef">listeInterne</span> = <span class="localvariable">liste</span>[<span class="localvariable">point</span>.<span class="property">x</span>];
  <span class="keyword">if</span> (<span class="localvariable">listeInterne</span> == <span class="atom">undefined</span>)
    <span class="keyword">return</span> <span class="atom">undefined</span>;
  <span class="keyword">else</span>
    <span class="keyword">return</span> <span class="localvariable">listeInterne</span>[<span class="localvariable">point</span>.<span class="property">y</span>];
}</pre><p>Une autre possibilité est de fusionner les <code>x</code> et <code>y</code> du point en un nom unique
de propriété, et de l’utiliser pour stocker les itinéraires dans un objet
unique.</p><pre class="code"><span class="keyword">function</span> <span class="variable">pointID</span>(<span class="variabledef">point</span>) {
  <span class="keyword">return</span> <span class="localvariable">point</span>.<span class="property">x</span> + <span class="string">&quot;-&quot;</span> + <span class="localvariable">point</span>.<span class="property">y</span>;
}

<span class="keyword">function</span> <span class="variable">creerListePointsParcourus</span>() {
  <span class="keyword">return</span> {};
}

<span class="keyword">function</span> <span class="variable">stockerPointsParcourus</span>(<span class="variabledef">liste</span>, <span class="variabledef">point</span>, <span class="variabledef">itineraire</span>) {
  <span class="localvariable">liste</span>[<span class="variable">pointID</span>(<span class="localvariable">point</span>)] = <span class="localvariable">itineraire</span>;
}

<span class="keyword">function</span> <span class="variable">trouverPointsParcourus</span>(<span class="variabledef">liste</span>, <span class="variabledef">point</span>) {
  <span class="keyword">return</span> <span class="localvariable">liste</span>[<span class="variable">pointID</span>(<span class="localvariable">point</span>)];
}</pre></div></div><hr/><div class="block"><p><a name="key14"></a> Définir un type de structure donné en fournissant un ensemble
de fonctions pour créer et manipuler de telles structures est une technique
utile. Cela permet «&nbsp;d’isoler&nbsp;» le code qui utilise la structure, des détails
de la structure elle-même. Remarquez que, peu importe laquelle des deux
implémentations ci-dessus est utilisée, le code qui a besoin d’une liste des
nœuds atteints fonctionne exactement de la même façon. Il ne se préoccupe pas
du type d’objet utilisé, tant qu’il reçoit le résultat qu’il attend.</p><p>On discutera plus en détail de cela au <a href="chapter8.html">chapitre 8</a>, où nous apprendrons à faire des
types d’objet comme <code>BinaryHeap</code> (tas binaire), qui sont créés en utilisant
<code>new</code> et qui ont des méthodes pour les manipuler.</p></div><hr/><div class="block"><p>Nous avons donc enfin notre vraie fonction de recherche de chemin :</p><pre class="code"><span class="keyword">function</span> <span class="variable">trouverItineraire</span>(<span class="variabledef">depart</span>, <span class="variabledef">arrivee</span>) {
  <span class="keyword">var</span> <span class="variabledef">listeOuverte</span> = <span class="keyword">new</span> <span class="variable">BinaryHeap</span>(<span class="variable">scoreItineraire</span>);
  <span class="keyword">var</span> <span class="variabledef">pointsParcourus</span> = <span class="variable">creerListePointsParcourus</span>();

  <span class="keyword">function</span> <span class="variabledef">scoreItineraire</span>(<span class="variabledef">itineraire</span>) {
    <span class="keyword">if</span> (<span class="localvariable">itineraire</span>.<span class="property">score</span> == <span class="atom">undefined</span>)
      <span class="localvariable">itineraire</span>.<span class="property">score</span> = <span class="variable">distanceEstimee</span>(<span class="localvariable">itineraire</span>.<span class="property">point</span>, <span class="localvariable">arrivee</span>) +
                    <span class="localvariable">itineraire</span>.<span class="property">longueur</span>;
    <span class="keyword">return</span> <span class="localvariable">itineraire</span>.<span class="property">score</span>;
  }
  <span class="keyword">function</span> <span class="variabledef">ajouterItineraireOuvert</span>(<span class="variabledef">itineraire</span>) {
    <span class="localvariable">listeOuverte</span>.<span class="property">push</span>(<span class="localvariable">itineraire</span>);
    <span class="variable">stockerPointsParcourus</span>(<span class="localvariable">pointsParcourus</span>, <span class="localvariable">itineraire</span>.<span class="property">point</span>, <span class="localvariable">itineraire</span>);
  }
  <span class="localvariable">ajouterItineraireOuvert</span>({<span class="property">point</span>: <span class="localvariable">depart</span>, <span class="property">longueur</span>: <span class="atom">0</span>});

  <span class="keyword">while</span> (<span class="localvariable">listeOuverte</span>.<span class="property">size</span>() &gt; <span class="atom">0</span>) {
    <span class="keyword">var</span> <span class="variabledef">itineraire</span> = <span class="localvariable">listeOuverte</span>.<span class="property">pop</span>();
    <span class="keyword">if</span> (<span class="variable">pointsIdentiques</span>(<span class="localvariable">itineraire</span>.<span class="property">point</span>, <span class="localvariable">arrivee</span>))
      <span class="keyword">return</span> <span class="localvariable">itineraire</span>;

    <span class="variable">forEach</span>(<span class="variable">directionsPossible</span>(<span class="localvariable">itineraire</span>.<span class="property">point</span>), <span class="keyword">function</span>(<span class="variabledef">direction</span>) {
      <span class="keyword">var</span> <span class="variabledef">itineraireConnu</span> = <span class="variable">trouverPointsParcourus</span>(<span class="localvariable">pointsParcourus</span>, <span class="localvariable">direction</span>);
      <span class="keyword">var</span> <span class="variabledef">nouvelleLongueur</span> = <span class="localvariable">itineraire</span>.<span class="property">longueur</span> +
                      <span class="variable">distancePonderee</span>(<span class="localvariable">itineraire</span>.<span class="property">point</span>, <span class="localvariable">direction</span>);
      <span class="keyword">if</span> (!<span class="localvariable">itineraireConnu</span> || <span class="localvariable">itineraireConnu</span>.<span class="property">longueur</span> &gt; <span class="localvariable">nouvelleLongueur</span>){
        <span class="keyword">if</span> (<span class="localvariable">itineraireConnu</span>)
          <span class="localvariable">listeOuverte</span>.<span class="property">remove</span>(<span class="localvariable">itineraireConnu</span>);
        <span class="localvariable">ajouterItineraireOuvert</span>({<span class="property">point</span>: <span class="localvariable">direction</span>,
                      <span class="property">from</span>: <span class="localvariable">itineraire</span>,
                      <span class="property">longueur</span>: <span class="localvariable">nouvelleLongueur</span>});
      }
    });
  }
  <span class="keyword">return</span> <span class="atom">null</span>;
}</pre><p>Premièrement, il crée les structures de données dont il a besoin : une liste
ouverte et une liste des nœuds atteints. <code>scoreItineraire</code> est la fonction de
calcul de score passée au tas binaire. Remarquez comment il stocke ses
résultats dans l’objet route, pour éviter d’avoir à le recalculer plusieurs fois.</p><p><code>ajouterItineraireOuvert</code> est une fonction commode pour ajouter une nouvelle
route à la fois à la liste ouverte et à la liste des nœuds atteints. On
l’utilise immédiatement pour ajouter le début de la route. Remarquez que les
objets route ont toujours une propriétés <code>point</code>, qui stocke le point d’arrivée
de la route, et <code>longueur</code>, qui stocke la longueur courante de la route. Les
routes qui ont plus d’une case de longueur, ont aussi une propriété <code>depart</code>,
qui pointe sur leurs prédécesseurs.</p><p>La boucle <code>while</code>, comme décrit dans l’algorithme, prend constamment la route
de plus faible score dans la liste ouverte et vérifie si cela nous mène au but.
Si ce n’est pas le cas, on doit continuer en l’étendant. C’est ce dont s’occupe
<code>forEach</code>. Il cherche si ce nouveau point est dans la liste des nœuds atteints.
S’il ne le trouve pas, ou si le nœud trouvé a une route plus longue que la
nouvelle route, un nouveau objet route est créé et ajouté à la liste ouverte et
la liste des nœuds atteints, et la route existante (s’il y en a une) est
supprimée de la liste ouverte.</p><p>Que se passe-t-il si la route dans <code>itineraireConnu</code> n’est pas dans la liste
ouverte&nbsp;? Cela peut arriver, car les routes ne sont supprimés de la liste
ouverte que lorsqu’on a déterminé qu’elles étaient la route optimale pour
atteindre leur destination. Si nous essayons de supprimer du tas binaire une
valeur qui n’y est pas, cela va lever une exception, donc si mon raisonnement
est faux, nous verrons probablement une exception au moment d’exécuter la
fonction.</p><p>Quand le code devient suffisamment complexe pour vous faire douter de certaines
choses à son propos, c’est une bonne idée d’ajouter quelques vérifications qui
lèvent une exception quand quelque chose se passe mal. De cette façon, vous
savez qu’il ne se passe rien de bizarre «&nbsp;silencieusement&nbsp;», et quand vous
cassez quelque chose, vous saurez immédiatement ce que vous avez cassé.</p></div><hr/><div class="block"><p>Remarquez que cet algorithme n’utilise pas la récursion, mais réussit tout de
même à explorer toutes les branches. La liste ouverte remplace plus ou moins le
rôle qu’avait la pile d’appel de fonction dans la solution récursive du
problème Hiva Oa : il garde une trace des chemins qui doivent encore être
parcourus. Chaque algorithme récursif peut être réécrit d’une façon
non-récursive et utilisant une structure de données qui stocke les «&nbsp;choses
encore à faire&nbsp;».</p></div><hr/><div class="block"><p>Bien, essayons notre recherche de route :</p><pre class="code"><span class="keyword">var</span> <span class="variable">route</span> = <span class="variable">trouverItineraire</span>(<span class="variable">point</span>(<span class="atom">0</span>, <span class="atom">0</span>), <span class="variable">point</span>(<span class="atom">19</span>, <span class="atom">19</span>));</pre><p>Si vous avez exécuté tout le code depuis le début du chapitre, et que vous
n’avez pas introduit d’erreurs, cet appel, même si cela peut prendre quelques
secondes à s’exécuter, devrait vous donner un objet <code>route</code>. Cet objet est
plutôt difficile à lire. On peut le faire en utilisant la fonction <code>showRoute</code>
qui, si votre console est assez grande, vous montrera une route sur une carte.</p><pre class="code"><span class="variable">showRoute</span>(<span class="variable">route</span>);</pre><p>Vous pouvez également passer plusieurs routes à <code>showRoute</code>, ce qui peut être
utile si, par exemple, vous voulez planifier un itinéraire touristique, qui
doit inclure le magnifique point de vue en <code>11</code>, <code>17</code>.</p><pre class="code"><span class="variable">showRoute</span>(<span class="variable">trouverItineraire</span>(<span class="variable">point</span>(<span class="atom">0</span>, <span class="atom">0</span>), <span class="variable">point</span>(<span class="atom">11</span>, <span class="atom">17</span>)),
          <span class="variable">trouverItineraire</span>(<span class="variable">point</span>(<span class="atom">11</span>, <span class="atom">17</span>), <span class="variable">point</span>(<span class="atom">19</span>, <span class="atom">19</span>)));</pre></div><hr/><div class="block"><p>Les variations sur le thème <a name="key15"></a>«&nbsp;chercher un itinéraire optimal dans
un graphe&nbsp;» peuvent être appliquées à de nombreux problèmes, dont beaucoup ne
sont pas liés au fait de trouver un chemin physique. Par exemple, un programme
qui résout le problème de faire rentrer un nombre donné de blocs dans un espace
limité, peut être résolu en explorant les différents &quot;chemins&quot; possibles qu’il
obtient en essayant de positionner un certain bloc à une certaine place. Les
chemins se terminant avec un manque de place pour les derniers blocs sont des
culs-de-sac, et le chemin qui permet de faire rentrer tous les blocs dans
l’espace est la solution.</p></div><ol class="footnotes"><li><a name="footnote1"></a>Les ordinateurs sont des machines déterministes : elles réagissent tout le
temps de la même manière aux données qu’elles reçoivent, et ne peuvent pas
produire de réelles valeurs aléatoires. Par conséquent, nous devons nous
accommoder d’une série de nombres qui semblent aléatoires, mais qui dans les
faits sont le résultat de quelques calculs complexes et déterministes.</li><li><a name="footnote2"></a>Si si, je vous assure.</li></ol><h1><span class="number">Chapitre 8: </span>Programmation orientée objet</h1><div class="block"><p>Au début des années 90, une chose appelée <a name="key1"></a>programmation orientée objet
souffla un vent nouveau sur l’industrie du logiciel. La plupart des idées
derrière ce concept n’étaient pas vraiment nouvelles, mais elles avaient enfin
suffisamment d’élan pour décoller, et devenir «&nbsp;à la mode&nbsp;». Des livres furent
écrits sur le sujet, des cours furent organisés, des langages de programmation
développés. Tout d’un coup, tout le monde se mit à vanter les mérites de la
programmation orientée objet, appliquant ses recettes à tous les problèmes avec
enthousiasme, se convainquant qu’on avait enfin trouvé <em>la bonne façon d’écrire
des programmes</em>.</p><p>Ces choses arrivent souvent. Quand un problème est compliqué, les gens
cherchent toujours une solution magique.  Quand arrive quelque chose qui
ressemble à cette solution, ils sont prêts à s’y jeter corps et âme. Pour de
nombreux programmeurs, encore aujourd’hui, l’orientation objet (ou du moins la
vision qu’ils en ont) est la panacée. Si un programme n’est pas «&nbsp;en pur objet
», quel que soit le sens de cette expression, il est considéré comme résolument
inférieur.</p><p>Toutefois, peu d’engouements ont duré si longtemps. La longévité de la
programmation orientée objet peut sûrement s’expliquer par le fait que les
idées centrales de concept sont utiles et simples. Dans ce chapitre, nous
allons parler de ces idées et de leur application, plutôt excentriques, au
JavaScript. Les paragraphes précédents n’étaient absolument pas destinés à
discréditer ces idées. Mon objectif était juste d’éviter qu’on ne jure plus que
par elles.</p></div><hr/><div class="block"><p>Comme son nom l’indique, la programmation orientée objet est centrée sur la
notion d’objet. Depuis le début, nous avons utilisé les objets comme des
espèces de fourre-tout plein de valeurs, où l’on ajoute ou modifie des
propriétés à notre guise. En fait, dans une approche orientée objet, les objets
sont vus comme des microcosmes indépendants, qui ne communiquent avec
l’extérieur qu’à travers un nombre limité d’<a name="key2"></a>interfaces, un ensemble de
méthodes et propriétés spécifiques. La «&nbsp;liste des nœuds atteints&nbsp;» utilisée à
la fin du <a href="chapter7.html">chapitre 7</a> en est un exemple : nous avons utilisé trois fonctions,
<code>creerListePointsParcourus</code>, <code>stockerPointsParcourus</code> et
<code>trouverPointsParcourus</code> pour interagir avec elle. Ces trois fonctions forment
une interface pour cette sorte d’objets.</p><p>Les objets <code>Date</code>, <code>Error</code> et <code>BinaryHeap</code> que nous avons vus fonctionnent
également comme cela. Au lieu de fournir des fonctions classiques pour
travailler avec ces objets, ils fournissent une manière d’être créés, via le
mot-clé <code>new</code>, et un certain nombre de méthodes et propriétés qui forment le
reste de l’interface.</p></div><hr/><div class="block"><p>Pour faire une méthode d’objet, il suffit de définir une variable qui
contiendra une fonction.</p><pre class="code"><span class="keyword">var</span> <span class="variable">lapin</span> = {};
<span class="variable">lapin</span>.<span class="property">parler</span> = <span class="keyword">function</span>(<span class="variabledef">tirade</span>) {
  <span class="variable">print</span>(<span class="string">&quot;Le lapin dit '&quot;</span>, <span class="localvariable">tirade</span>, <span class="string">&quot;'&quot;</span>);
};

<span class="variable">lapin</span>.<span class="property">parler</span>(<span class="string">&quot;Eh bien, maintenant c’est vous qui me le demandez.&quot;</span>);</pre><p>Dans la plupart des cas, la méthode aura besoin de savoir sur <em>qui</em> elle doit
s’appliquer. Par exemple, s’il y a plusieurs lapins, la méthode <code>parler</code> doit
pouvoir indiquer quel est le lapin qui parle. Pour ce faire, il y a une
variable spéciale appelée <a name="key3"></a><code>this</code>, qui est toujours définie à l’intérieur
d’une fonction et qui pointe vers l’objet sur lequel la fonction s’applique.
Une fonction définie en tant que propriété d’un objet s’utilise comme une
méthode, elle est appelée de la façon suivante : <code>objet.methode()</code>.</p><pre class="code"><span class="keyword">function</span> <span class="variable">parler</span>(<span class="variabledef">tirade</span>) {
  <span class="variable">print</span>(<span class="string">&quot;Le lapin &quot;</span>, <span class="localvariable">this</span>.<span class="property">adjectif</span>, <span class="string">&quot; dit «&nbsp;&quot;</span>, <span class="localvariable">tirade</span>, <span class="string">&quot;&nbsp;»&quot;</span>);
}
<span class="keyword">var</span> <span class="variable">lapinBlanc</span> = {<span class="property">adjectif</span>: <span class="string">&quot;blanc&quot;</span>, <span class="property">parler</span>: <span class="variable">parler</span>};
<span class="keyword">var</span> <span class="variable">grosLapin</span> = {<span class="property">adjectif</span>: <span class="string">&quot;gras&quot;</span>, <span class="property">parler</span>: <span class="variable">parler</span>};

<span class="variable">lapinBlanc</span>.<span class="property">parler</span>(<span class="string">&quot;Par ma moustache et mes oreilles, comme il se fait tard&nbsp;!&quot;</span>);
<span class="variable">grosLapin</span>.<span class="property">parler</span>(<span class="string">&quot;J’ai bien envie d’une carotte, maintenant.&quot;</span>);</pre></div><hr/><div class="block"><p>Je peux maintenant clarifier la présence du mystérieux premier argument de la
méthode <a name="key4"></a><code>apply</code>, pour lequel nous avons toujours mis <code>null</code> dans le <a href="chapter6.html">chapitre 6</a>.
Cet argument peut être utilisé pour spécifier un objet sur lequel la fonction
s’appliquera, qui prendra donc le rôle de <code>this</code>. Toutefois, pour les fonctions
qui ne sont pas des méthodes, cela n’a pas de sens, d’où le <code>null</code>.</p><pre class="code"><span class="variable">parler</span>.<span class="property">apply</span>(<span class="variable">grosLapin</span>, [<span class="string">&quot;Miam.&quot;</span>]);</pre><p>Les fonctions ont également une méthode <a name="key5"></a><code>call</code>, qui se comporte comme
<code>apply</code>, à l’exception du fait que les arguments peuvent être fournis
séparément, et non dans un tableau :</p><pre class="code"><span class="variable">parler</span>.<span class="property">call</span>(<span class="variable">grosLapin</span>, <span class="string">&quot;Rot.&quot;</span>);</pre></div><hr/><div class="block"><p>Le mot-clé <a name="key6"></a><code>new</code> fournit un bon moyen de créer de nouveaux objets. Quand une
fonction est appelée avec le mot <code>new</code> devant, sa variable <a name="key7"></a><code>this</code> pointe sur
un <em>nouvel</em> objet, qui sera automatiquement retourné (à moins que la fonction
ne retourne explicitement autre chose). Les fonctions utilisées pour créer de
nouveaux objets de cette manière sont appelées des <a name="key8"></a>constructeurs. En voici un
pour les lapins :</p><pre class="code"><span class="keyword">function</span> <span class="variable">Lapin</span>(<span class="variabledef">adjectif</span>) {
  <span class="localvariable">this</span>.<span class="property">adjectif</span> = <span class="localvariable">adjectif</span>;
  <span class="localvariable">this</span>.<span class="property">parler</span> = <span class="keyword">function</span>(<span class="variabledef">tirade</span>) {
    <span class="variable">print</span>(<span class="string">&quot;Le lapin &quot;</span>, <span class="localvariable">this</span>.<span class="property">adjectif</span>, <span class="string">&quot; dit '&quot;</span>, <span class="localvariable">tirade</span>, <span class="string">&quot;'&quot;</span>);
  };
}

<span class="keyword">var</span> <span class="variable">lapinTueur</span> = <span class="keyword">new</span> <span class="variable">Lapin</span>(<span class="string">&quot;tueur&quot;</span>);
<span class="variable">lapinTueur</span>.<span class="property">parler</span>(<span class="string">&quot;GRAAAAAAAAAH&nbsp;!&quot;</span>);</pre><p>Il y a une convention, parmi les programmeurs JavaScript, qui consiste à faire
débuter les noms de constructeurs par une lettre majuscule. Cela permet de
mieux les reconnaître au milieu des autres fonctions.</p><p>Mais pourquoi le mot clé <code>new</code> est-il nécessaire&nbsp;? Après tout, nous aurions pu
écrire simplement :</p><pre class="code"><span class="keyword">function</span> <span class="variable">creerLapin</span>(<span class="variabledef">adjectif</span>) {
  <span class="keyword">return</span> {
    <span class="property">adjectif</span>: <span class="localvariable">adjectif</span>,
    <span class="property">parler</span>: <span class="keyword">function</span>(<span class="variabledef">tirade</span>) {<span class="comment">/*etc.*/</span>}
  };
}

<span class="keyword">var</span> <span class="variable">lapinNoir</span> = <span class="variable">creerLapin</span>(<span class="string">&quot;noir&quot;</span>);</pre><p>Mais ce n’est pas exactement la même chose. <code>new</code> en fait discrètement plus. En
fait, notre fonction <code>lapinTueur</code> a une propriété appelée <a name="key9"></a><code>constructor</code>, qui
pointe vers la fonction <code>Lapin</code> l’ayant créée. <code>lapinNoir</code> a également cette
propriété, mais elle pointe vers la fonction <a name="key10"></a><code>Object</code>.</p><pre class="code"><span class="variable">show</span>(<span class="variable">lapinTueur</span>.<span class="property">constructor</span>);
<span class="variable">show</span>(<span class="variable">lapinNoir</span>.<span class="property">constructor</span>);</pre></div><hr/><div class="block"><p>D’où vient la propriété <code>constructor</code>&nbsp;? Elle fait partie du <a name="key11"></a>prototype d’un
lapin. Les prototypes sont une partie importante du fonctionnement des objets
en JavaScript. Chaque objet est basé sur un prototype, qui lui confère un
ensemble de propriétés. Les objets simples que nous avons utilisés jusque-là
sont tous basés sur le plus élémentaires des prototypes, celui associé au
constructeur <code>Object</code>. En fait, taper <code>{}</code> est équivalent à taper <code>new
Object()</code>.</p><pre class="code"><span class="keyword">var</span> <span class="variable">objetSimple</span> = {};
<span class="variable">show</span>(<span class="variable">objetSimple</span>.<span class="property">constructor</span>);
<span class="variable">show</span>(<span class="variable">objetSimple</span>.<span class="property">toString</span>);</pre><p><a name="key12"></a><code>toString</code> est une méthode qui fait partie du prototype <code>Object</code>. Ça signifie
que tous les objets de base ont une méthode <code>toString</code>, qui les convertit en
chaîne de caractères. Nos objets lapin sont basés sur le prototype associé au
constructeur <code>Lapin</code>. Il est possible d’utiliser la propriété <code>prototype</code> d’un
constructeur pour accéder à… leur prototype :</p><pre class="code"><span class="variable">show</span>(<span class="variable">Lapin</span>.<span class="property">prototype</span>);
<span class="variable">show</span>(<span class="variable">Lapin</span>.<span class="property">prototype</span>.<span class="property">constructor</span>);</pre><p>Chaque fonction est automatiquement munie d’une propriété <code>prototype</code>, dont la
propriété <code>constructor</code> renvoie à la fonction. Puisque que le prototype lapin
est lui-même un objet, il est basé sur le prototype <code>Object</code>, et partage sa
méthode <code>toString</code>.</p><pre class="code"><span class="variable">show</span>(<span class="variable">lapinTueur</span>.<span class="property">toString</span> == <span class="variable">objetSimple</span>.<span class="property">toString</span>);</pre></div><hr/><div class="block"><p>Même si les objets semblent partager des propriétés avec leur prototype, ce
partage n’est qu’à sens unique. Les propriétés des prototypes influencent les
objets basés dessus, mais les propriétés de cet objet ne changent jamais le
prototype.</p><p>Les règles sont précisément les suivantes : pour trouver la valeur d’une
propriété, JavaScript cherche d’abord parmi les propriétés de l’objet
<em>lui-même</em>. Si une propriété porte le nom que l’on recherche, c’est sa valeur
que l’on obtient. Si le nom n’existe pas, la recherche se poursuit à travers le
prototype de l’objet, et ensuite à travers le prototype du prototype, et ainsi
de suite. Si aucune propriété n’est trouvée, c’est la valeur <code>undefined</code> qui
est renvoyée. À l’inverse, lorsqu’on <em>définit</em> la valeur d’une propriété,
JavaScript ne remonte jamais au prototype, il attribue directement la valeur à
une propriété de l’objet lui-même.</p><pre class="code"><span class="variable">Lapin</span>.<span class="property">prototype</span>.<span class="property">dents</span> = <span class="string">&quot;petites&quot;</span>;
<span class="variable">show</span>(<span class="variable">lapinTueur</span>.<span class="property">dents</span>);
<span class="variable">lapinTueur</span>.<span class="property">dents</span> = <span class="string">&quot;longues, pointues et sanglantes&quot;</span>;
<span class="variable">show</span>(<span class="variable">lapinTueur</span>.<span class="property">dents</span>);
<span class="variable">show</span>(<span class="variable">Lapin</span>.<span class="property">prototype</span>.<span class="property">dents</span>);</pre><p>Cela signifie que le prototype peut être utilisé pour ajouter des propriétés et
des méthodes à tous les objets basés dessus. Par exemple, il se peut que nos
lapins aient soudainement besoin de danser.</p><pre class="code"><span class="variable">Lapin</span>.<span class="property">prototype</span>.<span class="property">danser</span> = <span class="keyword">function</span>() {
  <span class="variable">print</span>(<span class="string">&quot;Le lapin &quot;</span>, <span class="localvariable">this</span>.<span class="property">adjectif</span>, <span class="string">&quot; danse une jigue.&quot;</span>);
};

<span class="variable">lapinTueur</span>.<span class="property">danser</span>();</pre><p>Et, comme vous vous en doutez, le prototype de lapin est le meilleur endroit où
ajouter des éléments communs à tous les lapins, comme la méthode <code>parler</code>.
Voici donc une nouvelle approche pour notre constructeur de <code>Lapin</code> :</p><pre class="code"><span class="keyword">function</span> <span class="variable">Lapin</span>(<span class="variabledef">adjectif</span>) {
  <span class="localvariable">this</span>.<span class="property">adjectif</span> = <span class="localvariable">adjectif</span>;
}
<span class="variable">Lapin</span>.<span class="property">prototype</span>.<span class="property">parler</span> = <span class="keyword">function</span>(<span class="variabledef">tirade</span>) {
  <span class="variable">print</span>(<span class="string">&quot;Le lapin &quot;</span>, <span class="localvariable">this</span>.<span class="property">adjectif</span>, <span class="string">&quot; dit '&quot;</span>, <span class="localvariable">tirade</span>, <span class="string">&quot;'&quot;</span>);
};

<span class="keyword">var</span> <span class="variable">noisetteLeLapin</span> = <span class="keyword">new</span> <span class="variable">Lapin</span>(<span class="string">&quot;noisette&quot;</span>);
<span class="variable">noisetteLeLapin</span>.<span class="property">parler</span>(<span class="string">&quot;Good Frith!&quot;</span>);</pre></div><hr/><div class="block"><p>Le fait que tous les objets aient leur prototype et reçoivent des propriétés de
ce prototype peut apporter quelques complications. Ça signifie qu’utiliser un
objet pour stocker des trucs, comme les chats du <a href="chapter4.html">chapitre 4</a>, peut mal se passer.
Par exemple, si nous nous étions demandé s’il y a un chat nommé «&nbsp;<code>constructor</code>
», nous aurions implémenté le test suivant :</p><pre class="code"><span class="keyword">var</span> <span class="variable">pasUnSeulChat</span> = {};
<span class="keyword">if</span> (<span class="string">&quot;constructor&quot;</span> in <span class="variable">pasUnSeulChat</span>)
  <span class="variable">print</span>(<span class="string">&quot;Oui, il y a sans aucun doute un chat appelé «&nbsp;constructor&nbsp;».&quot;</span>);</pre><p>C’est problématique. Un autre problème tient au fait qu’il est souvent pratique
d’étendre les prototypes des constructeurs standards comme <code>Object</code> ou <code>Array</code>
avec de nouvelles fonctions. Par exemple, nous pouvons donner à tous les objets
une méthode nommée <code>properties</code>, qui retourne un tableau contenant le nom des
propriétés (non cachées) d’un objet.</p><pre class="code"><span class="variable">Object</span>.<span class="property">prototype</span>.<span class="property">properties</span> = <span class="keyword">function</span>() {
  <span class="keyword">var</span> <span class="variabledef">resultat</span> = [];
  <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">property</span> <span class="keyword">in</span> <span class="localvariable">this</span>)
    <span class="localvariable">resultat</span>.<span class="property">push</span>(<span class="localvariable">property</span>);
  <span class="keyword">return</span> <span class="localvariable">resultat</span>;
};

<span class="keyword">var</span> <span class="variable">test</span> = {<span class="property">x</span>: <span class="atom">10</span>, <span class="property">y</span>: <span class="atom">3</span>};
<span class="variable">show</span>(<span class="variable">test</span>.<span class="property">properties</span>());</pre><p>Et cela met tout de suite le problème en évidence. Maintenant que le prototype
<code>Object</code> a une propriété appelée <code>properties</code>, parcourir les propriétés de
n’importe quel objet, en utilisant <code>for</code> et <a name="key13"></a><code>in</code>, renverra également cette
propriété partagée, ce qui n’est généralement pas ce que nous souhaitons. Nous
sommes seulement intéressés par les propriétés que l’objet a lui-même.</p><p>Heureusement, il y a un moyen de trouver si une propriété appartient à un objet
lui-même, ou à l’un de ses prototypes. Malheureusement, cela complique un peu
le parcours des propriétés d’un objet. Tout objet a une méthode appelée
<a name="key14"></a><code>hasOwnProperty</code>, qui nous indique si l’objet possède une propriété dont le
nom est passé en argument. En se basant sur ce mécanisme, nous pouvons réécrire
notre méthode <code>properties</code> de la manière suivante :</p><pre class="code"><span class="variable">Object</span>.<span class="property">prototype</span>.<span class="property">properties</span> = <span class="keyword">function</span>() {
  <span class="keyword">var</span> <span class="variabledef">resultat</span> = [];
  <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">property</span> <span class="keyword">in</span> <span class="localvariable">this</span>) {
    <span class="keyword">if</span> (<span class="localvariable">this</span>.<span class="property">hasOwnProperty</span>(<span class="localvariable">property</span>))
      <span class="localvariable">resultat</span>.<span class="property">push</span>(<span class="localvariable">property</span>);
  }
  <span class="keyword">return</span> <span class="localvariable">resultat</span>;
};

<span class="keyword">var</span> <span class="variable">test</span> = {<span class="string">&quot;Gros Igor&quot;</span>: <span class="atom">true</span>, <span class="string">&quot;Boule de Feu&quot;</span>: <span class="atom">true</span>};
<span class="variable">show</span>(<span class="variable">test</span>.<span class="property">properties</span>());</pre><p><a name="key15"></a>Et bien sûr, nous pouvons abstraire cela dans une fonction de
haut niveau. Notez que la fonction <code>action</code> est appelée avec à la fois le nom
de la propriété et la valeur qu’elle a dans l’objet.</p><pre class="code"><span class="keyword">function</span> <span class="variable">forEachIn</span>(<span class="variabledef">objet</span>, <span class="variabledef">action</span>) {
  <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">property</span> <span class="keyword">in</span> <span class="localvariable">objet</span>) {
    <span class="keyword">if</span> (<span class="localvariable">objet</span>.<span class="property">hasOwnProperty</span>(<span class="localvariable">property</span>))
      <span class="localvariable">action</span>(<span class="localvariable">property</span>, <span class="localvariable">objet</span>[<span class="localvariable">property</span>]);
  }
}

<span class="keyword">var</span> <span class="variable">chimere</span> = {<span class="property">visage</span>: <span class="string">&quot;lion&quot;</span>, <span class="property">corps</span>: <span class="string">&quot;chèvre&quot;</span>, <span class="property">derrière</span>: <span class="string">&quot;serpent&quot;</span>};
<span class="variable">forEachIn</span>(<span class="variable">chimere</span>, <span class="keyword">function</span>(<span class="variabledef">nom</span>, <span class="variabledef">valeur</span>) {
  <span class="variable">print</span>(<span class="string">&quot;Un &quot;</span>, <span class="localvariable">nom</span>, <span class="string">&quot; de &quot;</span>, <span class="localvariable">valeur</span>, <span class="string">&quot;.&quot;</span>);
});</pre><p>Mais, que se passe-t-il si on rencontre un chat nommé <code>hasOwnProperty</code>&nbsp;? (on ne
sait jamais.) Il sera stocké dans l’objet, et la tentative suivante de
parcourir la collection de chats, utilisant <code>objet.hasOwnProperty</code>, sera un
échec, car cette propriété ne pointera plus vers la fonction. Une façon
d’éviter ce problème est d’agir encore plus salement :</p><pre class="code"><span class="keyword">function</span> <span class="variable">forEachIn</span>(<span class="variabledef">objet</span>, <span class="variabledef">action</span>) {
   <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">property</span> <span class="keyword">in</span> <span class="localvariable">objet</span>) {
       <span class="keyword">if</span> (<span class="variable">Object</span>.<span class="property">prototype</span>.<span class="property">hasOwnProperty</span>.<span class="property">call</span>(<span class="localvariable">objet</span>, <span class="localvariable">property</span>))
           <span class="localvariable">action</span>(<span class="localvariable">property</span>, <span class="localvariable">objet</span>[<span class="localvariable">property</span>]);
   }
}

<span class="keyword">var</span> <span class="variable">test</span> = {<span class="property">name</span>: <span class="string">&quot;Mardochée&quot;</span>, <span class="property">hasOwnProperty</span>: <span class="string">&quot;Oh-oh&quot;</span>};
<span class="variable">forEachIn</span>(<span class="variable">test</span>, <span class="keyword">function</span> (<span class="variabledef">nom</span>, <span class="variabledef">valeur</span>) {
   <span class="variable">print</span> (<span class="string">&quot;Property &quot;</span>, <span class="localvariable">nom</span>, <span class="string">&quot; = &quot;</span>, <span class="localvariable">valeur</span>);
});</pre><p>(Note : Cet exemple ne fonctionne pas pour l’instant correctement dans Internet
Explorer 8, qui a semble-t-il des problèmes avec la redéfinition des propriétés
intégrées.)</p><p>Ici, au lieu d’utiliser la méthode trouvée dans l’objet lui-même, nous prenons
la méthode fournie par le prototype <code>Object</code>, et l’appliquons en utilisant
<code>call</code> sur le bon objet. À moins que quelqu’un n’ait joué avec la méthode de
<code>Object.prototype</code> (et ne faites pas ça), le programme devrait fonctionner
correctement.</p></div><hr/><div class="block"><p><code>hasOwnProperty</code> peut également être utilisée dans les situations où l’on
utilise l’opérateur <a name="key16"></a><code>in</code> pour savoir si un objet contient une propriété
particulière. Mais il y a encore une subtilité. Nous avons vu dans le <a href="chapter4.html">chapitre 4</a>
que certaines propriétés, comme <code>toString</code>, sont «&nbsp;cachées&nbsp;», et ne sont donc
pas considérées lors du parcours des éléments d’un objet via une instruction
<code>for</code>/<code>in</code>. Il s’avère que les navigateurs de la famille Gecko (Firefox
principalement) donnent à chaque objet une propriété cachée nommée <code>__proto__</code>,
qui pointe vers le prototype de cet objet. <code>hasOwnProperty</code> retourne <code>true</code>,
pour cette propriété, même si le programme ne l’a pas explicitement ajoutée.
Avoir accès au prototype d’un objet peut être très pratique, mais en faire une
propriété comme ça n’était pas une très bonne idée. Toutefois, Firefox est un
navigateur web très utilisé, et il convient de faire attention à cela quand
vous écrivez des programmes pour le web. Il y a une méthode
<a name="key17"></a><code>propertyIsEnumerable</code>, qui retourne <code>false</code>, pour les propriétés cachées, et
peut donc être utilisé pour filtrer les étrangetés comme <code>__proto__</code>. Pour
contourner ce problème de manière fiable, on peut utiliser une expression
comme :</p><pre class="code"><span class="keyword">var</span> <span class="variable">objet</span> = {<span class="property">foo</span>: <span class="string">&quot;bar&quot;</span>};
<span class="variable">show</span> (<span class="variable">Object</span>.<span class="property">prototype</span>.<span class="property">hasOwnProperty</span>.<span class="property">call</span>(<span class="variable">objet</span>, <span class="string">&quot;foo&quot;</span>) &amp;&amp;
   <span class="variable">Object</span>.<span class="property">prototype</span>.<span class="property">propertyIsEnumerable</span>.<span class="property">call</span>(<span class="variable">objet</span>, <span class="string">&quot;foo&quot;</span>));</pre><p>Simple et agréable n’est-ce pas&nbsp;? C’est l’un des aspects de JavaScript qui ne
sont pas si bien conçus que ça. Les objets jouent à la fois le rôle de «
valeurs avec méthodes&nbsp;», qui fonctionnent très bien avec les prototypes, et «
d’ensemble de propriétés&nbsp;», pour lesquels les prototypes ne font que déranger.</p></div><hr/><div class="block"><p>Écrire l’expression ci-dessus à chaque fois qu’on a besoin de vérifier la
présence d’une propriété dans un objet n’est pas viable. Nous pourrions le
mettre dans une fonction, mais une meilleure approche est encore d’écrire un
constructeur et un prototype dédié aux situations où nous voulons utiliser un
objet simplement comme un ensemble propriétés. Puisqu’il est prévu pour pouvoir
y chercher des choses par leurs noms, nous l’appellerons <a name="key18"></a><code>Dictionary</code>
(dictionnaire).</p><pre class="code"><span class="keyword">function</span> <span class="variable">Dictionary</span>(<span class="variabledef">valeursInitiales</span>) {
  <span class="localvariable">this</span>.<span class="property">valeurs</span> = <span class="localvariable">valeursInitiales</span> || {};
}
<span class="variable">Dictionary</span>.<span class="property">prototype</span>.<span class="property">store</span> = <span class="keyword">function</span>(<span class="variabledef">nom</span>, <span class="variabledef">valeur</span>) {
  <span class="localvariable">this</span>.<span class="property">valeurs</span>[<span class="localvariable">nom</span>] = <span class="localvariable">valeur</span>;
};
<span class="variable">Dictionary</span>.<span class="property">prototype</span>.<span class="property">lookup</span> = <span class="keyword">function</span>(<span class="variabledef">nom</span>) {
  <span class="keyword">return</span> <span class="localvariable">this</span>.<span class="property">valeurs</span>[<span class="localvariable">nom</span>];
};
<span class="variable">Dictionary</span>.<span class="property">prototype</span>.<span class="property">contains</span> = <span class="keyword">function</span>(<span class="variabledef">nom</span>) {
  <span class="keyword">return</span> <span class="variable">Object</span>.<span class="property">prototype</span>.<span class="property">hasOwnProperty</span>.<span class="property">call</span>(<span class="localvariable">this</span>.<span class="property">valeurs</span>, <span class="localvariable">nom</span>) &amp;&amp;
    <span class="variable">Object</span>.<span class="property">prototype</span>.<span class="property">propertyIsEnumerable</span>.<span class="property">call</span>(<span class="localvariable">this</span>.<span class="property">valeurs</span>, <span class="localvariable">nom</span>);
};
<span class="variable">Dictionary</span>.<span class="property">prototype</span>.<span class="property">each</span> = <span class="keyword">function</span>(<span class="variabledef">action</span>) {
  <span class="variable">forEachIn</span>(<span class="localvariable">this</span>.<span class="property">valeurs</span>, <span class="localvariable">action</span>);
};

<span class="keyword">var</span> <span class="variable">couleurs</span> = <span class="keyword">new</span> <span class="variable">Dictionary</span>({<span class="property">Grover</span>: <span class="string">&quot;bleu&quot;</span>,
                              <span class="property">Elmo</span>: <span class="string">&quot;orange&quot;</span>,
                              <span class="property">Bart</span>: <span class="string">&quot;jaune&quot;</span>});
<span class="variable">show</span>(<span class="variable">couleurs</span>.<span class="property">contains</span>(<span class="string">&quot;Grover&quot;</span>));
<span class="variable">show</span>(<span class="variable">couleurs</span>.<span class="property">contains</span>(<span class="string">&quot;constructor&quot;</span>));
<span class="variable">couleurs</span>.<span class="property">each</span>(<span class="keyword">function</span>(<span class="variabledef">nom</span>, <span class="variabledef">couleur</span>) {
  <span class="variable">print</span>(<span class="localvariable">nom</span>, <span class="string">&quot; est &quot;</span>, <span class="localvariable">couleur</span>);
});</pre><p>Désormais, tous les inconvénients de l’utilisation des objets en tant
qu’ensemble de propriétés sont «&nbsp;cachés&nbsp;» derrière une interface pratique : un
constructeur et quatre méthodes. Notez que la propriété <code>valeurs</code> d’un objet
<code>Dictionary</code> ne fait pas partie de son interface, ce n’est qu’un détail
interne, et quand vous utilisez des objets <code>Dictionary</code>, vous n’avez pas besoin
de l’utiliser directement.</p><p>Chaque fois que vous écrivez une interface, il est utile d’y ajouter un
commentaire retraçant rapidement ce qu’elle fait et comment l’utiliser. De
cette manière, quand quelqu’un (éventuellement vous dans trois mois) souhaite
travailler avec cette interface, il peut se faire rapidement une idée de
comment l’utiliser, et n’a alors pas besoin d’étudier tout le programme.</p><p>La plupart du temps, quand vous concevez une nouvelle interface, des problèmes
et des limitations dans ce que vous aviez prévu viennent rapidement se
confronter à vous. En conséquence, vous changez votre interface. Pour éviter de
perdre du temps, il est conseillé de ne documenter vos interfaces <em>qu’après</em>
les avoir expérimentées un certain temps sur des cas concrets, et qu’elles se
soient révélées efficaces. ―&nbsp;Bien sûr, cela pourrait augmenter la tentation de
ne pas documenter du tout. Mais personnellement, je considère la documentation
comme une «&nbsp;touche finale&nbsp;» à ajouter au système. Quand ça donne l’impression
d’être prêt, c’est qu’il est temps d’écrire un peu sur le sujet, et de voir si
ça sonne aussi bien en français (ou n’importe quelle autre langue vivante),
qu’en JavaScript (où n’importe quel autre langage de programmation).</p></div><hr/><div class="block"><p>La distinction entre l’interface d’un objet et ses détails de fonctionnement
internes est importante pour deux raisons. D’abord, avoir une petite interface
bien décrite rend un objet plus facile à utiliser. Il suffit de garder
l’interface en tête, sans plus se préoccuper du reste, à moins d’avoir à
changer l’objet lui-même.</p><p>Ensuite, il arrive régulièrement d’avoir à changer quelque chose dans le
fonctionnement interne d’un type<a class="footref" href="#footnote1">1</a> d’objet, pour le rendre plus efficace par
exemple, ou pour corriger un problème. Si le code extérieur a accès à toutes
les propriétés d’un objet, il est difficile de changer le moindre détail sans
avoir à mettre à jour tout le reste du code. Si le code extérieur utilise une
petite interface, vous pouvez changer le fonctionnement interne de l’objet
comme bon vous semble, tant que l’interface ne change pas.</p><p>Certaines personnes vont assez loin avec ce concept. Ils n’incluent, par
exemple, aucune propriété dans l’interface d’un objet, et n’y autorisent que
des méthodes ―&nbsp;si leur type d’objet a une longueur, elle sera accessible via
une méthode <code>getLength</code>, et pas directement comme une propriété <code>length</code>. De
cette manière, si jamais ils décident de modifier leur objet de telle manière
qu’il n’a plus de propriété <code>length</code>, par exemple parce que la longueur à
retourner devient celle d’un tableau, ils peuvent mettre la fonction à jour,
sans changer l’interface.</p><p>D’après mon point de vue personnel, dans la plupart des cas cela n’en vaut pas
la peine. Ajouter une méthode <code>getLength</code> ne contenant que <code>return
this.length;</code> est essentiellement un ajout de code inutile. En règle générale,
je considère le code inutile plus problématique que la nécessité de modifier de
temps à autre l’interface de mes objets.</p></div><hr/><div class="block"><p>Ajouter de nouvelles méthodes à des prototypes existants peut être très utile.
En particulier les prototypes de <code>Array</code> et <code>String</code> en JavaScript peuvent
recevoir quelques méthodes basiques supplémentaires. Nous pouvons, par exemple,
remplacer <code>forEach</code> et <code>map</code> par des méthodes sur les tableaux, et transformer
la fonction <code>chaineCommencePar</code> que nous avons écrite au <a href="chapter4.html">chapitre 4</a> en méthode sur
les chaînes de caractère.</p><p>De plus, si votre programme doit fonctionner sur la même page web qu’un autre
programme (qu’il soit de vous ou non) qui utilise naïvement <code>for</code>/<code>in</code> ― comme
nous l’avons vu jusque-là ―&nbsp;alors ajouter des choses aux prototypes, et
précisément à ceux d’<code>Object</code> et <code>Array</code> aura toutes les chances de casser
quelque chose, vu que ces boucles vont d’un coup se mettre à inclure les
nouvelles propriétés. Du coup, certaines personnes préfèrent ne pas toucher du
tout à ces prototypes. Mais bien sûr, si vous êtes prudent, et qu’il n’y a
aucune raison que votre code cohabite avec un code mal écrit, ajouter des
méthodes aux prototypes standards est une très bonne technique.</p></div><hr/><div class="block"><p>Dans ce chapitre, nous allons fabriquer un terrarium virtuel, une boîte en
verre avec des insectes vivants dedans. Ça impliquera de jouer avec des objets
(ce qui tombe assez bien vu le nom du chapitre). Nous allons adopter une
approche assez simple, en modélisant le terrarium par une grille à deux
dimensions, comme la deuxième carte du <a href="chapter7.html">chapitre 7</a>. Sur cette grille, il y a un
certain nombre de bestioles. Quand le terrarium est actif, toutes les bébêtes
ont une opportunité d’agir (comme d’effectuer un déplacement) toutes les
demi-secondes.</p><p>Du coup, on découpe l’espace et le temps en unités de taille fixe ―&nbsp;des cases
pour l’espace et des demi-secondes pour le temps. Ça rend généralement les
choses plus simple à modéliser dans un programme, mais ça a bien sûr
l’inconvénient d’être largement imprécis. Heureusement, ce simulateur de
terrarium n’a pas besoin d’être précis et nous pouvons donc faire avec.</p></div><hr/><div class="block"><p>Un terrarium peut être représenté comme un «&nbsp;plan&nbsp;», défini comme étant un
tableau de chaînes de caractères. Nous aurions pu n’utiliser qu’une seule
chaîne de caractères, mais comme les chaînes de caractères JavaScript ne
doivent comporter qu’une seule ligne, ça aurait été beaucoup plus compliqué à
taper.</p><pre class="code"><span class="keyword">var</span> <span class="variable">lePlan</span> =
  [<span class="string">&quot;############################&quot;</span>,
   <span class="string">&quot;#      #    #      o      ##&quot;</span>,
   <span class="string">&quot;#                          #&quot;</span>,
   <span class="string">&quot;#          #####           #&quot;</span>,
   <span class="string">&quot;##         #   #    ##     #&quot;</span>,
   <span class="string">&quot;###           ##     #     #&quot;</span>,
   <span class="string">&quot;#           ###      #     #&quot;</span>,
   <span class="string">&quot;#   ####                   #&quot;</span>,
   <span class="string">&quot;#   ##       o             #&quot;</span>,
   <span class="string">&quot;# o  #         o       ### #&quot;</span>,
   <span class="string">&quot;#    #                     #&quot;</span>,
   <span class="string">&quot;############################&quot;</span>];</pre><p>Les caractères <code>&quot;#&quot;</code> sont utilisés pour représenter les murs du terrarium (et
les éléments de décors, comme les rochers au sol), les <code>&quot;o&quot;</code> représentent les
bêtes et les espaces, comme vous vous en êtes sûrement doutés, représentent les
espaces vides.</p><p>Un plan-tableau de ce type est approprié pour représenter un objet terrarium.
Cet objet garde trace de la forme et du contenu du terrarium, et permet aux
insectes à l’intérieur de bouger. Il a quatre méthodes : tout d’abord
<code>toString</code>, qui convertit le terrarium en une chaîne de caractères affichable,
permettant d’avoir un aperçu de ce qui se passe dedans. Ensuite, il y a <code>step</code>,
qui permet à toutes les bêtes du terrarium de se déplacer d’une case si elles
le veulent. Et enfin il y a <code>start</code> et <code>stop</code>, qui contrôlent l’activité du
terrarium. Lorsqu’il fonctionne, <code>step</code> est appelé automatiquement toutes les
demi-secondes, et donc les insectes se déplacent.</p></div><hr/><div class="block"><a name="exercise1"></a><div class="exercisenum">Ex. 8.1</div><div class="exercise"><p><a name="key19"></a>Les points sur la grille représenteront également des objets. Dans le
<a href="chapter7.html">chapitre 7</a> nous avons utilisé trois fonctions : <code>point</code>, <code>ajouterPoints</code> et
<code>pointsIdentiques</code> pour travailler avec les points. Cette fois, nous
utiliserons un constructeur et deux méthodes. Écrire le constructeur <code>Point</code>,
qui prend deux arguments, les coordonnées x et y du point, et produit un objet
avec des propriétés <code>x</code> et <code>y</code>. Ajoutez au prototype de ce constructeur une
méthode <code>add</code>, qui prend un autre point en argument et retourne un <em>nouveau</em>
point dont les <code>x</code> et <code>y</code> sont la somme des <code>x</code> et <code>y</code> des deux points donnés.
Ajoutez également une méthode <code>isEqualTo</code>, qui prend un point et renvoie un
booléen, indiquant si le point local (<code>this</code>) a les mêmes coordonnées que le
point donné.</p><p>En dehors des deux méthodes, les propriétés <code>x</code> et <code>y</code> font également partie de
l’interface de ce type d’objets : le code utilisant des objets de type point
pourra lire et modifier librement les <code>x</code> et <code>y</code>.</p></div><div class="solution"><pre class="code"><span class="keyword">function</span> <span class="variable">Point</span>(<span class="variabledef">x</span>, <span class="variabledef">y</span>) {
  <span class="localvariable">this</span>.<span class="property">x</span> = <span class="localvariable">x</span>;
  <span class="localvariable">this</span>.<span class="property">y</span> = <span class="localvariable">y</span>;
}
<span class="variable">Point</span>.<span class="property">prototype</span>.<span class="property">add</span> = <span class="keyword">function</span>(<span class="variabledef">autre</span>) {
  <span class="keyword">return</span> <span class="keyword">new</span> <span class="variable">Point</span>(<span class="localvariable">this</span>.<span class="property">x</span> + <span class="localvariable">autre</span>.<span class="property">x</span>, <span class="localvariable">this</span>.<span class="property">y</span> + <span class="localvariable">autre</span>.<span class="property">y</span>);
};
<span class="variable">Point</span>.<span class="property">prototype</span>.<span class="property">isEqualTo</span> = <span class="keyword">function</span>(<span class="variabledef">autre</span>) {
  <span class="keyword">return</span> <span class="localvariable">this</span>.<span class="property">x</span> == <span class="localvariable">autre</span>.<span class="property">x</span> &amp;&amp; <span class="localvariable">this</span>.<span class="property">y</span> == <span class="localvariable">autre</span>.<span class="property">y</span>;
};

<span class="variable">show</span>((<span class="keyword">new</span> <span class="variable">Point</span>(<span class="atom">3</span>, <span class="atom">1</span>)).<span class="property">add</span>(<span class="keyword">new</span> <span class="variable">Point</span>(<span class="atom">2</span>, <span class="atom">4</span>)));</pre><p>Assurez-vous que votre version de <code>add</code> laisse le point local (<code>this</code>) intact
et produise bien un nouvel objet Point. Une méthode qui change le point courant
serait similaire à l’opérateur <code>+=</code>, alors qu’on la veut équivalente à
l’opérateur <code>+</code>.</p></div></div><hr/><div class="block"><p>Quand on écrit des objets pour développer un programme, on ne sait pas toujours
quelle fonctionnalité va où. Certaines choses sont mieux implémentées sous
forme de méthodes de l’objet, d’autres mieux rangées dans des fonctions et
d’autres encore mieux modélisées par de nouveaux types d’objets. Pour garder
l’organisation limpide, il est important de garder le nombre de méthodes et de
responsabilités des objets aussi petit que possible. Quand un objet en fait
trop, il devient un gros bazar de fonctionnalités et une formidable source de
confusions.</p><p>J’ai dit plus haut que l’objet terrarium serait responsable du stockage de son
contenu et de permettre aux insectes de bouger. Tout d’abord, précisons qu’il
ne fait que <em>permettre</em> aux insectes de bouger. Les bébêtes seront elles-mêmes
des objets, et ces objets seront responsables de leur propres décisions. Le
terrarium ne fournit en gros que l’infrastructure qui leur demande quoi faire
chaque demi-seconde. Et s’ils décident de bouger, il s’assure que ça se fasse.</p><p>Stocker la grille sur laquelle le contenu du terrarium prend place peut vite se
compliquer. Il faut définir une représentation, des moyens d’accéder à cette
représentation, d’initialiser la grille depuis le «&nbsp;plan&nbsp;» (fourni sous forme
de tableau) et de restituer le contenu de la grille sous la forme d’une chaîne
de caractères pour la méthode <code>toString</code>, sans oublier le mouvement des
insectes sur la grille.</p></div><hr/><div class="block"><p>Lorsque vous vous retrouvez à mélanger représentations de données et code
spécifique à un problème donné dans un seul objet, c’est une bonne idée
d’essayer de mettre la représentation des données dans un type d’objet séparé.
Dans ce cas, nous avons besoin de représenter une grille de valeurs, j’ai donc
écrit un type <code>Grille</code>, qui supporte les opérations dont ce terrarium aura
besoin.</p><p>Pour stocker les valeurs de la grille, il y a deux options. L’une peut utiliser
un tableau de tableaux :</p><pre class="code"><span class="keyword">var</span> <span class="variable">grille</span> = [[<span class="string">&quot;0,0&quot;</span>, <span class="string">&quot;1,0&quot;</span>, <span class="string">&quot;2,0&quot;</span>],
             [<span class="string">&quot;0,1&quot;</span>, <span class="string">&quot;1,1&quot;</span>, <span class="string">&quot;2,1&quot;</span>]];
<span class="variable">show</span>(<span class="variable">grille</span>[<span class="atom">1</span>][<span class="atom">2</span>]);</pre><p>Ou alors les valeurs peuvent toutes être mises dans un seul tableau. Dans ce
cas, on retrouve l’élément <code>x</code>/<code>y</code> en cherchant dans le tableau l’élément en
position <code>x + y * largeur</code>, où <code>largeur</code> est la largeur de la grille.</p><pre class="code"><span class="keyword">var</span> <span class="variable">grille</span> = [<span class="string">&quot;0,0&quot;</span>, <span class="string">&quot;1,0&quot;</span>, <span class="string">&quot;2,0&quot;</span>,
              <span class="string">&quot;0,1&quot;</span>, <span class="string">&quot;1,1&quot;</span>, <span class="string">&quot;2,1&quot;</span>];
<span class="variable">show</span>(<span class="variable">grille</span>[<span class="atom">2</span> + <span class="atom">1</span> * <span class="atom">3</span>]);</pre><p><a name="key20"></a>J’ai choisi la seconde représentation, car elle simplifie
l’initialisation du tableau. <code>new Array(x)</code> produit un nouveau tableau de
longueur <code>x</code>, rempli de valeurs <code>undefined</code> (indéfinies).</p><pre class="code"><span class="keyword">function</span> <span class="variable">Grille</span>(<span class="variabledef">largeur</span>, <span class="variabledef">hauteur</span>) {
  <span class="localvariable">this</span>.<span class="property">largeur</span> = <span class="localvariable">largeur</span>;
  <span class="localvariable">this</span>.<span class="property">hauteur</span> = <span class="localvariable">hauteur</span>;
  <span class="localvariable">this</span>.<span class="property">cellules</span> = <span class="keyword">new</span> <span class="variable">Array</span>(<span class="localvariable">largeur</span> * <span class="localvariable">hauteur</span>);
}
<span class="variable">Grille</span>.<span class="property">prototype</span>.<span class="property">valeurEn</span> = <span class="keyword">function</span>(<span class="variabledef">point</span>) {
  <span class="keyword">return</span> <span class="localvariable">this</span>.<span class="property">cellules</span>[<span class="localvariable">point</span>.<span class="property">y</span> * <span class="localvariable">this</span>.<span class="property">largeur</span> + <span class="localvariable">point</span>.<span class="property">x</span>];
};
<span class="variable">Grille</span>.<span class="property">prototype</span>.<span class="property">ecritValeurEn</span> = <span class="keyword">function</span>(<span class="variabledef">point</span>, <span class="variabledef">valeur</span>) {
  <span class="localvariable">this</span>.<span class="property">cellules</span>[<span class="localvariable">point</span>.<span class="property">y</span> * <span class="localvariable">this</span>.<span class="property">largeur</span> + <span class="localvariable">point</span>.<span class="property">x</span>] = <span class="localvariable">valeur</span>;
};
<span class="variable">Grille</span>.<span class="property">prototype</span>.<span class="property">estDedans</span> = <span class="keyword">function</span>(<span class="variabledef">point</span>) {
  <span class="keyword">return</span> <span class="localvariable">point</span>.<span class="property">x</span> &gt;= <span class="atom">0</span> &amp;&amp; <span class="localvariable">point</span>.<span class="property">y</span> &gt;= <span class="atom">0</span> &amp;&amp;
         <span class="localvariable">point</span>.<span class="property">x</span> &lt; <span class="localvariable">this</span>.<span class="property">largeur</span> &amp;&amp; <span class="localvariable">point</span>.<span class="property">y</span> &lt; <span class="localvariable">this</span>.<span class="property">hauteur</span>;
};
<span class="variable">Grille</span>.<span class="property">prototype</span>.<span class="property">deplaceElement</span> = <span class="keyword">function</span>(<span class="variabledef">depuis</span>, <span class="variabledef">vers</span>) {
  <span class="localvariable">this</span>.<span class="property">ecritValeurEn</span>(<span class="localvariable">vers</span>, <span class="localvariable">this</span>.<span class="property">valeurEn</span>(<span class="localvariable">depuis</span>));
  <span class="localvariable">this</span>.<span class="property">ecritValeurEn</span>(<span class="localvariable">depuis</span>, <span class="atom">undefined</span>);
};</pre></div><hr/><div class="block"><a name="exercise2"></a><div class="exercisenum">Ex. 8.2</div><div class="exercise"><p>Nous allons également avoir besoin de parcourir tous les éléments de la grille,
pour trouver les insectes qui ont besoin de bouger, ou pour convertir
l’ensemble en une chaîne de caractères. Pour simplifier la chose, nous pouvons
utiliser une fonction de haut niveau qui prend une action en argument. Ajouter
une méthode <code>each</code> au prototype de <code>Grille</code>, qui prend en argument une fonction
à deux arguments. Elle appelle cette fonction pour chaque point de la grille,
lui donnant l’objet point comment premier argument, et la valeur du point sur
la grille comme deuxième argument.</p><p>Parcourir les points depuis <code>0</code>, <code>0</code>, une ligne à la fois, de manière à ce que
le point <code>1</code>, <code>0</code> soit parcouru avant <code>0</code>, <code>1</code>. Cela simplifiera l’écriture de
la fonction <code>toString</code> du terrarium après. (Indice : mettre une boucle <code>for</code>
pour la coordonnée <code>x</code> à l’intérieur de la boucle for de la coordonnée <code>y</code>.)</p><p>Il est conseillé de ne pas mettre son nez directement dans la propriété
<code>cellules</code> de la grille, mais d’utiliser <code>valeurEn</code>, pour récupérer ces
valeurs. De cette manière, si nous décidons (pour une raison ou pour une autre)
d’utiliser une méthode différente pour stocker les valeurs, nous n’aurons qu’à
réécrire la fonction <code>valeurEn</code> et <code>ecritValeurEn</code>, et les autres méthodes
resterons intactes.</p></div><div class="solution"><pre class="code"><span class="variable">Grille</span>.<span class="property">prototype</span>.<span class="property">each</span> = <span class="keyword">function</span>(<span class="variabledef">action</span>) {
  <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">y</span> = <span class="atom">0</span>; <span class="localvariable">y</span> &lt; <span class="localvariable">this</span>.<span class="property">hauteur</span>; <span class="localvariable">y</span>++) {
    <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">x</span> = <span class="atom">0</span>; <span class="localvariable">x</span> &lt; <span class="localvariable">this</span>.<span class="property">largeur</span>; <span class="localvariable">x</span>++) {
      <span class="keyword">var</span> <span class="variabledef">point</span> = <span class="keyword">new</span> <span class="variable">Point</span>(<span class="localvariable">x</span>, <span class="localvariable">y</span>);
      <span class="localvariable">action</span>(<span class="localvariable">point</span>, <span class="localvariable">this</span>.<span class="property">valeurEn</span>(<span class="localvariable">point</span>));
    }
  }
};</pre></div></div><hr/><div class="block"><p>Enfin, pour tester l’objet grille :</p><pre class="code"><span class="keyword">var</span> <span class="variable">testGrille</span> = <span class="keyword">new</span> <span class="variable">Grille</span>(<span class="atom">3</span>, <span class="atom">2</span>);
<span class="variable">testGrille</span>.<span class="property">ecritValeurEn</span>(<span class="keyword">new</span> <span class="variable">Point</span>(<span class="atom">1</span>, <span class="atom">0</span>), <span class="string">&quot;#&quot;</span>);
<span class="variable">testGrille</span>.<span class="property">ecritValeurEn</span>(<span class="keyword">new</span> <span class="variable">Point</span>(<span class="atom">1</span>, <span class="atom">1</span>), <span class="string">&quot;o&quot;</span>);
<span class="variable">testGrille</span>.<span class="property">each</span>(<span class="keyword">function</span>(<span class="variabledef">point</span>, <span class="variabledef">valeur</span>) {
  <span class="variable">print</span>(<span class="localvariable">point</span>.<span class="property">x</span>, <span class="string">&quot;,&quot;</span>, <span class="localvariable">point</span>.<span class="property">y</span>, <span class="string">&quot;: &quot;</span>, <span class="localvariable">valeur</span>);
});</pre></div><hr/><div class="block"><p>Avant d’écrire un nouveau constructeur <code>Terrarium</code>, nous devons être plus
précis à propos de ces «&nbsp;objets insectes&nbsp;» qui évolueront à l’intérieur.
Précédemment, j’ai dit que le terrarium demandera aux insectes quelle action
ils veulent effectuer. Cela fonctionnera de la fonction suivante : chaque
insecte aura une méthode <code>agit</code> qui, appelée, renverra une «&nbsp;action&nbsp;». Une
action est un objet doté d’une propriété <code>type</code>, nommant le type d’action que
l’insecte souhaitera effectuer. Par exemple <code>&quot;déplacement&quot;</code>. La plupart des
actions porteront d’autres informations, par exemple la direction souhaitée par
l’insecte qui voudra se déplacer.</p><p>Les insectes sont terriblement myopes, ils ne peuvent voir que les cases à côté
d’eux sur la grille. Mais ils peuvent s’en servir pour déterminer leurs
actions. Quand la méthode <code>agit</code> est appelée, il lui est fourni un objet avec
des informations sur l’environnement de l’insecte en question. Il porte une
propriété pour chacune des huit directions autour de l’insecte. La propriété
indiquant ce qu’il y a au-dessus de l’insecte est appelé <code>&quot;n&quot;</code>, pour Nord, pour
ce qu’il y a au-dessus à droite <code>&quot;ne&quot;</code>, pour Nord-Est, et ainsi de suite.  Pour
savoir quelle direction explorer selon le nom de la direction, l’objet
dictionnaire suivant sera utile :</p><pre class="code"><span class="keyword">var</span> <span class="variable">directions</span> = <span class="keyword">new</span> <span class="variable">Dictionary</span>(
  {<span class="string">&quot;n&quot;</span>:  <span class="keyword">new</span> <span class="variable">Point</span>( <span class="atom">0</span>, -<span class="atom">1</span>),
   <span class="string">&quot;ne&quot;</span>: <span class="keyword">new</span> <span class="variable">Point</span>( <span class="atom">1</span>, -<span class="atom">1</span>),
   <span class="string">&quot;e&quot;</span>:  <span class="keyword">new</span> <span class="variable">Point</span>( <span class="atom">1</span>,  <span class="atom">0</span>),
   <span class="string">&quot;se&quot;</span>: <span class="keyword">new</span> <span class="variable">Point</span>( <span class="atom">1</span>,  <span class="atom">1</span>),
   <span class="string">&quot;s&quot;</span>:  <span class="keyword">new</span> <span class="variable">Point</span>( <span class="atom">0</span>,  <span class="atom">1</span>),
   <span class="string">&quot;so&quot;</span>: <span class="keyword">new</span> <span class="variable">Point</span>(-<span class="atom">1</span>,  <span class="atom">1</span>),
   <span class="string">&quot;o&quot;</span>:  <span class="keyword">new</span> <span class="variable">Point</span>(-<span class="atom">1</span>,  <span class="atom">0</span>),
   <span class="string">&quot;no&quot;</span>: <span class="keyword">new</span> <span class="variable">Point</span>(-<span class="atom">1</span>, -<span class="atom">1</span>)});

<span class="variable">show</span>(<span class="keyword">new</span> <span class="variable">Point</span>(<span class="atom">4</span>, <span class="atom">4</span>).<span class="property">add</span>(<span class="variable">directions</span>.<span class="property">lookup</span>(<span class="string">&quot;se&quot;</span>)));</pre><p>Quand un insecte décide de se déplacer, il indique dans quelle direction il
veut aller en renvoyant un objet action dont la propriété <code>direction</code> nomme
laquelle de ces directions. Nous pouvons programmer un insecte primitif et
idiot qui va toujours vers le sud, «&nbsp;vers la lumière&nbsp;», comme ceci :</p><pre class="code"><span class="keyword">function</span> <span class="variable">InsecteStupide</span>() {};
<span class="variable">InsecteStupide</span>.<span class="property">prototype</span>.<span class="property">agit</span> = <span class="keyword">function</span>(<span class="variabledef">alentours</span>) {
  <span class="keyword">return</span> {<span class="property">type</span>: <span class="string">&quot;déplacement&quot;</span>, <span class="property">direction</span>: <span class="string">&quot;s&quot;</span>};
};</pre></div><hr/><div class="block"><p>Nous pouvons maintenir construire le type d’objet <code>Terrarium</code> lui-même.
Commençons par son constructeur, qui reçoit un plan (un tableau de chaîne)
comme argument, et initialise son objet grille.</p><pre class="code"><span class="keyword">var</span> <span class="variable">mur</span> = {};

<span class="keyword">function</span> <span class="variable">Terrarium</span>(<span class="variabledef">plan</span>) {
  <span class="keyword">var</span> <span class="variabledef">grille</span> = <span class="keyword">new</span> <span class="variable">Grille</span>(<span class="localvariable">plan</span>[<span class="atom">0</span>].<span class="property">length</span>, <span class="localvariable">plan</span>.<span class="property">length</span>);
  <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">y</span> = <span class="atom">0</span>; <span class="localvariable">y</span> &lt; <span class="localvariable">plan</span>.<span class="property">length</span>; <span class="localvariable">y</span>++) {
    <span class="keyword">var</span> <span class="variabledef">ligne</span> = <span class="localvariable">plan</span>[<span class="localvariable">y</span>];
    <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">x</span> = <span class="atom">0</span>; <span class="localvariable">x</span> &lt; <span class="localvariable">ligne</span>.<span class="property">length</span>; <span class="localvariable">x</span>++) {
      <span class="localvariable">grille</span>.<span class="property">ecritValeurEn</span>(<span class="keyword">new</span> <span class="variable">Point</span>(<span class="localvariable">x</span>, <span class="localvariable">y</span>),
                      <span class="variable">elementdApresCaractere</span>(<span class="localvariable">ligne</span>.<span class="property">charAt</span>(<span class="localvariable">x</span>)));
    }
  }
  <span class="localvariable">this</span>.<span class="property">grille</span> = <span class="localvariable">grille</span>;
}

<span class="keyword">function</span> <span class="variable">elementdApresCaractere</span>(<span class="variabledef">caractere</span>) {
  <span class="keyword">if</span> (<span class="localvariable">caractere</span> == <span class="string">&quot; &quot;</span>)
    <span class="keyword">return</span> <span class="atom">undefined</span>;
  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="localvariable">caractere</span> == <span class="string">&quot;#&quot;</span>)
    <span class="keyword">return</span> <span class="variable">mur</span>;
  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="localvariable">caractere</span> == <span class="string">&quot;o&quot;</span>)
    <span class="keyword">return</span> <span class="keyword">new</span> <span class="variable">InsecteStupide</span>();
}</pre><p><code>mur</code> est un objet utilisé pour repérer la position des murs sur la grille.
Comme un vrai mur, il ne fait pas grand-chose, juste être quelque part et
occuper une partie de l’espace.</p></div><hr/><div class="block"><p>La méthode la plus évidente de l’objet terrarium est <code>toString</code>, qui transforme
un terrarium en chaîne de caractères. Pour faciliter cette tâche, nous donnons
à <code>mur</code> et au prototype de <code>InsecteStupide</code> une propriété <code>caractere</code>,
contenant la représentation sous forme de caractère de ceux-ci.</p><pre class="code"><span class="variable">mur</span>.<span class="property">caractere</span> = <span class="string">&quot;#&quot;</span>;
<span class="variable">InsecteStupide</span>.<span class="property">prototype</span>.<span class="property">caractere</span> = <span class="string">&quot;o&quot;</span>;

<span class="keyword">function</span> <span class="variable">caracteredApresElement</span>(<span class="variabledef">element</span>) {
  <span class="keyword">if</span> (<span class="localvariable">element</span> == <span class="atom">undefined</span>)
    <span class="keyword">return</span> <span class="string">&quot; &quot;</span>;
  <span class="keyword">else</span>
    <span class="keyword">return</span> <span class="localvariable">element</span>.<span class="property">caractere</span>;
}

<span class="variable">show</span>(<span class="variable">caracteredApresElement</span>(<span class="variable">mur</span>));</pre></div><hr/><div class="block"><a name="exercise3"></a><div class="exercisenum">Ex. 8.3</div><div class="exercise"><p>Maintenant, nous pouvons utiliser la méthode <code>each</code> de l’objet <code>Grille</code> pour
construire une chaîne de caractères. Pour que le résultat soit lisible, il est
préférable d’avoir un retour chariot à chaque ligne. La coordonnée <code>x</code> de
chaque case de la grille sera utilisée pour déterminer si la fin d’une ligne
est atteinte.  Ajouter une méthode <code>toString</code> au prototype de <code>Terrarium</code>.
Cette méthode ne prend pas d’argument et renvoie une chaîne de caractères
destinée à être passée à <code>print</code>, affichant ainsi une belle vue
bidimensionnelle du terrarium.</p></div><div class="solution"><pre class="code"><span class="variable">Terrarium</span>.<span class="property">prototype</span>.<span class="property">toString</span> = <span class="keyword">function</span>() {
  <span class="keyword">var</span> <span class="variabledef">caracteres</span> = [];
  <span class="keyword">var</span> <span class="variabledef">finDeLigne</span> = <span class="localvariable">this</span>.<span class="property">grille</span>.<span class="property">largeur</span> - <span class="atom">1</span>;
  <span class="localvariable">this</span>.<span class="property">grille</span>.<span class="property">each</span>(<span class="keyword">function</span>(<span class="variabledef">point</span>, <span class="variabledef">valeur</span>) {
    <span class="localvariable">caracteres</span>.<span class="property">push</span>(<span class="variable">caracteredApresElement</span>(<span class="localvariable">valeur</span>));
    <span class="keyword">if</span> (<span class="localvariable">point</span>.<span class="property">x</span> == <span class="localvariable">finDeLigne</span>)
      <span class="localvariable">caracteres</span>.<span class="property">push</span>(<span class="string">&quot;\n&quot;</span>);
  });
  <span class="keyword">return</span> <span class="localvariable">caracteres</span>.<span class="property">join</span>(<span class="string">&quot;&quot;</span>);
};</pre><p>Et pour l’essayer …</p><pre class="code"><span class="keyword">var</span> <span class="variable">terrarium</span> = <span class="keyword">new</span> <span class="variable">Terrarium</span>(<span class="variable">lePlan</span>);
<span class="variable">print</span>(<span class="variable">terrarium</span>.<span class="property">toString</span>());</pre></div></div><hr/><div class="block"><p>Il est possible qu’en essayant de résoudre l’exercice précédent, vous ayez
voulu accéder à <code>this.grille</code> dans le corps de la fonction passé en argument de
la méthode <code>each</code> de l’objet grille. Cela ne peut pas fonctionner, car l’appel
à une fonction a pour conséquence qu’à l’intérieur de cette fonction, <code>this</code>
prend une nouvelle valeur, même si elle n’est pas utilisée en tant que méthode.
Ainsi, aucune variable <code>this</code> à l’extérieur d’une fonction ne peut être
visible.</p><p>Parfois, il est nécessaire de contourner ceci en stockant les informations dont
on a besoin dans une variable, par exemple <code>finDeLigne</code>, qui elle <em>est</em> visible
dans la fonction imbriquée. Si vous avez besoin d’accéder à la variable <code>this</code>
d’un objet, vous pouvez la stocker dans une autre variable. Le nom <code>self</code> (ou
<code>that</code>) est souvent utilisée pour une telle
variable.</p><p>Mais l’utilisation de ces variables en plus peut être source de confusion. Une
autre bonne solution est d’utiliser une fonction proche de <code>partial</code> décrite
dans le <a href="chapter6.html">chapitre 6</a>. Au lieu d’ajouter un argument à la fonction, celle-ci passe
l’objet <code>this</code>, par l’intermédiaire du premier argument de la méthode <code>apply</code>
dont disposent toutes les fonctions :</p><pre class="code"><span class="keyword">function</span> <span class="variable">bind</span>(<span class="variabledef">func</span>, <span class="variabledef">objet</span>) {
  <span class="keyword">return</span> <span class="keyword">function</span>(){
    <span class="keyword">return</span> <span class="localvariable">func</span>.<span class="property">apply</span>(<span class="localvariable">objet</span>, <span class="localvariable">arguments</span>);
  };
}

<span class="keyword">var</span> <span class="variable">tableauTest</span> = [];
<span class="keyword">var</span> <span class="variable">ajouterDansTest</span> = <span class="variable">bind</span>(<span class="variable">tableauTest</span>.<span class="property">push</span>, <span class="variable">tableauTest</span>);
<span class="variable">ajouterDansTest</span>(<span class="string">&quot;A&quot;</span>);
<span class="variable">ajouterDansTest</span>(<span class="string">&quot;B&quot;</span>);
<span class="variable">show</span>(<span class="variable">tableauTest</span>);</pre><p>De cette façon, vous pouvez lier la variable <code>this</code> d’une fonction imbriquée à
la variable <code>this</code> de la fonction appelante, les deux <code>this</code> seront identiques.</p></div><hr/><div class="block"><a name="exercise4"></a><div class="exercisenum">Ex. 8.4</div><div class="exercise"><p>Dans l’expression <code>bind(tableauTest.push, tableauTest)</code> le nom <code>tableauTest</code>
est encore utilisé deux fois. Pouvez-vous concevoir une fonction <a name="key21"></a><code>method</code>,
qui permet de lier un objet à une de ses méthodes <em>sans</em> nommer deux fois
l’objet&nbsp;?</p></div><div class="solution"><p>Il est possible de passer à un objet une chaîne de caractères contenant le nom
d’une de ses méthodes. De cette façon, la fonction <code>method</code> peut connaître le
nom de la fonction à appliquer à l’objet.</p><pre class="code"><span class="keyword">function</span> <span class="variable">method</span>(<span class="variabledef">objet</span>, <span class="variabledef">nom</span>) {
  <span class="keyword">return</span> <span class="keyword">function</span>() {
    <span class="localvariable">objet</span>[<span class="localvariable">nom</span>].<span class="property">apply</span>(<span class="localvariable">objet</span>, <span class="localvariable">arguments</span>);
  };
}

<span class="keyword">var</span> <span class="variable">ajouterDansTest</span> = <span class="variable">method</span>(<span class="variable">tableauTest</span>, <span class="string">&quot;push&quot;</span>);</pre></div></div><hr/><div class="block"><p>Nous aurons besoin de <code>bind</code> (ou <code>method</code>) quand nous écrirons la méthode
<code>step</code> de l’objet terrarium. Cette méthode devra parcourir tous les insectes de
la grille, en leur demandant quelle action ils veulent effectuer, et en
effectuant pour eux cette action.  Vous pourriez être tenté d’utiliser <code>each</code>
sur l’objet grille, et traiter les insectes un par un au fur et à mesure que
vous les rencontriez. Mais ce faisant, si un insecte se déplaçait vers le sud
ou l’est, vous le rencontriez à nouveau dans le même tour, et il serait à
nouveau déplacé.</p><p>À la place, nous allons extraire tous les insectes vers un tableau, et partant
de là, les traiter un par un.  La méthode ci-dessous extrait les insectes, et
même tout objet qui possède une méthode <code>agit</code>, et enregistre ces objets, et
leurs positions respectives avant déplacement, dans un tableau d’objets.</p><pre class="code"><span class="variable">Terrarium</span>.<span class="property">prototype</span>.<span class="property">listeCreaturesEnAction</span> = <span class="keyword">function</span>() {
  <span class="keyword">var</span> <span class="variabledef">trouves</span> = [];
  <span class="localvariable">this</span>.<span class="property">grille</span>.<span class="property">each</span>(<span class="keyword">function</span>(<span class="variabledef">point</span>, <span class="variabledef">valeur</span>) {
    <span class="keyword">if</span> (<span class="localvariable">valeur</span> != <span class="atom">undefined</span> &amp;&amp; <span class="localvariable">valeur</span>.<span class="property">agit</span>)
      <span class="localvariable">trouves</span>.<span class="property">push</span>({<span class="property">object</span>: <span class="localvariable">valeur</span>, <span class="property">point</span>: <span class="localvariable">point</span>});
  });
  <span class="keyword">return</span> <span class="localvariable">trouves</span>;
};</pre></div><hr/><div class="block"><a name="exercise5"></a><div class="exercisenum">Ex. 8.5</div><div class="exercise"><p>Lorsque l’on demande à un insecte quel déplacement il souhaite réaliser, il
faut lui passer un objet lui décrivant les cases alentours. Cet objet utilisera
les noms de direction que nous avons vu précédemment (<code>&quot;n&quot;</code>, <code>&quot;ne&quot;</code>, etc.)
comme noms de propriétés. Chaque propriété contiendra une chaîne d’un caractère
tel que renvoyé par <code>caracteredApresElement</code>, indiquant ce que peut voir
l’insecte dans cette direction.</p><p>Ajouter une méthode <code>listeAlentours</code> au prototype de <code>Terrarium</code>. Elle prend un
argument, le point où l’insecte se trouve, et renvoie un objet décrivant
l’entourage de ce point. Quand un point se trouve à une bordure de la grille,
utiliser <code>&quot;#&quot;</code> pour les directions qui débordent de la grille, ainsi l’insecte
ne pourra s’y rendre.</p><p>Conseil : ne pas décrire chacune des directions, mais utiliser la méthode
<code>each</code> sur le dictionnaire <code>directions</code>.</p></div><div class="solution"><pre class="code"><span class="variable">Terrarium</span>.<span class="property">prototype</span>.<span class="property">listeAlentours</span> = <span class="keyword">function</span>(<span class="variabledef">centre</span>) {
  <span class="keyword">var</span> <span class="variabledef">resultat</span> = {};
  <span class="keyword">var</span> <span class="variabledef">grille</span> = <span class="localvariable">this</span>.<span class="property">grille</span>;
  <span class="variable">directions</span>.<span class="property">each</span>(<span class="keyword">function</span>(<span class="variabledef">nom</span>, <span class="variabledef">direction</span>) {
    <span class="keyword">var</span> <span class="variabledef">place</span> = <span class="localvariable">centre</span>.<span class="property">add</span>(<span class="localvariable">direction</span>);
    <span class="keyword">if</span> (<span class="localvariable">grille</span>.<span class="property">estDedans</span>(<span class="localvariable">place</span>))
      <span class="localvariable">resultat</span>[<span class="localvariable">nom</span>] = <span class="variable">caracteredApresElement</span>(<span class="localvariable">grille</span>.<span class="property">valeurEn</span>(<span class="localvariable">place</span>));
    <span class="keyword">else</span>
      <span class="localvariable">resultat</span>[<span class="localvariable">nom</span>] = <span class="string">&quot;#&quot;</span>;
  });
  <span class="keyword">return</span> <span class="localvariable">resultat</span>;
};</pre><p>Remarquez l’utilisation de la variable <code>grille</code> pour passer outre les
difficultés liées à l’usage de <code>this</code>.</p></div></div><hr/><div class="block"><p>Les deux méthodes ci-dessus ne font pas partie de l’interface externe de
l’objet <code>Terrarium</code>, mais sont des détails internes à l’objet. Certains
langages de programmation permettent de déclarer explicitement certaines
méthodes et propriétés comme &quot;privées&quot;, et provoquent une erreur si on accède à
celles-ci en dehors de l’objet.  Ce n’est pas le cas de JavaScript, c’est
pourquoi vous pourriez utiliser des commentaires pour décrire l’interface d’un
objet.  Parfois il est utile d’utiliser des conventions de nommage pour
distinguer les propriétés externes et internes, par exemple en préfixant les
propriétés internes avec un caractère souligné (&quot;_&quot;).  Cela permet de repérer
plus facilement les utilisations accidentelles des propriétés qui ne font pas
partie de l’interface des objets.</p></div><hr/><div class="block"><p>Voici encore une méthode interne, celle qui va demander à un insecte ce qu’il
veut faire, et l’effectuer. Elle prend en argument un objet avec les propriétés
<code>object</code> et <code>point</code>, comme le renvoie <code>listeCreaturesEnAction</code>.  Pour le
moment, elle ne reconnaît que l’action <code>&quot;déplacement&quot;</code> :</p><pre class="code"><span class="variable">Terrarium</span>.<span class="property">prototype</span>.<span class="property">actionnerUneCreature</span> = <span class="keyword">function</span>(<span class="variabledef">creature</span>) {
  <span class="keyword">var</span> <span class="variabledef">alentours</span> = <span class="localvariable">this</span>.<span class="property">listeAlentours</span>(<span class="localvariable">creature</span>.<span class="property">point</span>);
  <span class="keyword">var</span> <span class="variabledef">action</span> = <span class="localvariable">creature</span>.<span class="property">object</span>.<span class="property">agit</span>(<span class="localvariable">alentours</span>);
  <span class="keyword">if</span> (<span class="localvariable">action</span>.<span class="property">type</span> == <span class="string">&quot;déplacement&quot;</span> &amp;&amp; <span class="variable">directions</span>.<span class="property">contains</span>(<span class="localvariable">action</span>.<span class="property">direction</span>)) {
    <span class="keyword">var</span> <span class="variabledef">to</span> = <span class="localvariable">creature</span>.<span class="property">point</span>.<span class="property">add</span>(<span class="variable">directions</span>.<span class="property">lookup</span>(<span class="localvariable">action</span>.<span class="property">direction</span>));
    <span class="keyword">if</span> (<span class="localvariable">this</span>.<span class="property">grille</span>.<span class="property">estDedans</span>(<span class="localvariable">to</span>) &amp;&amp; <span class="localvariable">this</span>.<span class="property">grille</span>.<span class="property">valeurEn</span>(<span class="localvariable">to</span>) == <span class="atom">undefined</span>)
      <span class="localvariable">this</span>.<span class="property">grille</span>.<span class="property">deplaceElement</span>(<span class="localvariable">creature</span>.<span class="property">point</span>, <span class="localvariable">to</span>);
  }
  <span class="keyword">else</span> {
    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="variable">Error</span>(<span class="string">&quot;Action invalide : &quot;</span> + <span class="localvariable">action</span>.<span class="property">type</span>);
  }
};</pre><p>Remarquez que la méthode vérifie si la direction choisie amène bien à une case
vide. Dans le cas contraire, la méthode ignore le déplacement. De cette façon,
les insectes peuvent bien demander tout ce qu’ils veulent ― l’action ne sera
effectuée que si elle est possible.  Ce mécanisme agit comme une couche
d’isolation entre les insectes et le terrarium, et nous autorise quelques
approximations dans l’écriture des méthodes <code>agit</code> des insectes ―&nbsp;par exemple
<code>InsecteStupide</code> ne se déplace que vers le sud, sans se demander si un mur se
trouve sur son chemin.</p></div><hr/><div class="block"><p>Ces trois méthodes internes vont nous permettre enfin d’écrire la méthode
<code>step</code>, qui permettra aux insectes de faire quelque chose (et même tout élément
doté d’une méthode <code>agit</code> ―&nbsp;nous pourrions tout aussi bien donner une telle
méthode à l’objet <code>mur</code> et les murs se déplaceraient).</p><pre class="code"><span class="variable">Terrarium</span>.<span class="property">prototype</span>.<span class="property">step</span> = <span class="keyword">function</span>() {
  <span class="variable">forEach</span>(<span class="localvariable">this</span>.<span class="property">listeCreaturesEnAction</span>(),
          <span class="variable">bind</span>(<span class="localvariable">this</span>.<span class="property">actionnerUneCreature</span>, <span class="localvariable">this</span>));
};</pre><p>Maintenant, construisons un terrarium et voyons les insectes se déplacer.</p><pre class="code"><span class="keyword">var</span> <span class="variable">terrarium</span> = <span class="keyword">new</span> <span class="variable">Terrarium</span>(<span class="variable">lePlan</span>);
<span class="variable">print</span>(<span class="variable">terrarium</span>);
<span class="variable">terrarium</span>.<span class="property">step</span>();
<span class="variable">print</span>(<span class="variable">terrarium</span>);</pre></div><hr/><div class="block"><p>Examinons un instant l’instruction ci-dessus <code>print(terrarium)</code>, comment
fait-elle pour renvoyer le contenu de notre méthode <a name="key22"></a><code>toString</code>&nbsp;? <code>print</code>
transforme les arguments qui lui sont passés en chaîne de caractères, en
utilisant la fonction <code>String</code>. Les objets sont transformés en chaîne de
caractères par l’appel de leur méthode <code>toString</code>, aussi, écrire une méthode
<code>toString</code> dans nos propres objets est un bon moyen de les rendre lisibles lors
de l’appel de <code>print</code>.</p><pre class="code"><span class="variable">Point</span>.<span class="property">prototype</span>.<span class="property">toString</span> = <span class="keyword">function</span>() {
  <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + <span class="localvariable">this</span>.<span class="property">x</span> + <span class="string">&quot;,&quot;</span> + <span class="localvariable">this</span>.<span class="property">y</span> + <span class="string">&quot;)&quot;</span>;
};
<span class="variable">print</span>(<span class="keyword">new</span> <span class="variable">Point</span>(<span class="atom">5</span>, <span class="atom">5</span>));</pre></div><hr/><div class="block"><p>Comme prévu, l’objet <code>Terrarium</code> sera doté de méthode <code>start</code> et <code>stop</code> pour
démarrer et arrêter la simulation. Pour cela, nous utiliserons deux fonctions
fournies par le navigateur web, appelées <a name="key23"></a><code>setInterval</code> et <a name="key24"></a><code>clearInterval</code>. 
La première est utilisée dans le but que son premier argument (une fonction ou
une chaîne de caractères contenant du code JavaScript) soit exécuté
périodiquement. Son deuxième argument est la durée en millisecondes (1/1000 de
seconde) entre les exécutions.  La fonction renvoie une valeur qui pourra
servir d’argument à <code>clearInterval</code> pour arrêter les exécutions périodiques.</p><pre class="code"><span class="keyword">var</span> <span class="variable">pénible</span> = <span class="variable">setInterval</span>(<span class="keyword">function</span>() {<span class="variable">print</span>(<span class="string">&quot;Quoi?&quot;</span>);}, <span class="atom">400</span>);</pre><p>Et…</p><pre class="code"><span class="variable">clearInterval</span>(<span class="variable">pénible</span>);</pre><p>Il existe des fonctions proches pour exécuter une action une seule fois après
un laps de temps. <a name="key25"></a><code>setTimeout</code> exécute une fonction ou une chaîne de
caractères après un délai exprimé en millisecondes, et <a name="key26"></a><code>clearTimeout</code> permet
d’annuler une telle action.</p></div><hr/><div class="block"><pre class="code"><span class="variable">Terrarium</span>.<span class="property">prototype</span>.<span class="property">start</span> = <span class="keyword">function</span>() {
  <span class="keyword">if</span> (!<span class="localvariable">this</span>.<span class="property">running</span>)
    <span class="localvariable">this</span>.<span class="property">running</span> = <span class="variable">setInterval</span>(<span class="variable">bind</span>(<span class="localvariable">this</span>.<span class="property">step</span>, <span class="localvariable">this</span>), <span class="atom">500</span>);
};

<span class="variable">Terrarium</span>.<span class="property">prototype</span>.<span class="property">stop</span> = <span class="keyword">function</span>() {
  <span class="keyword">if</span> (<span class="localvariable">this</span>.<span class="property">running</span>) {
    <span class="variable">clearInterval</span>(<span class="localvariable">this</span>.<span class="property">running</span>);
    <span class="localvariable">this</span>.<span class="property">running</span> = <span class="atom">null</span>;
  }
};</pre></div><hr/><div class="block"><p>À ce stade, nous avons un terrarium avec des insectes très simplistes, que nous
pouvons faire fonctionner. Mais pour voir ce qu’il s’y passe, il nous faut
constamment exécuter <code>print(terrarium)</code>. Ce n’est pas très pratique. Ce serait
agréable que le contenu s’affiche automatiquement. Ce serait encore mieux si,
au lieu d’afficher par milliers les images successives des terraria, nous
n’ayons qu’une seule image que nous mettrions à jour.  Pour ce dernier
problème, cette page offre une fonction nommée <code>inPlacePrinter</code>. Elle renvoie
une fonction comme <code>print</code> qui, au lieu d’effectuer un nouvel affichage,
remplace l’affichage précédent.</p><pre class="code"><span class="keyword">var</span> <span class="variable">printHere</span> = <span class="variable">inPlacePrinter</span>();
<span class="variable">printHere</span>(<span class="string">&quot;Actuellement vous voyez ceci.&quot;</span>);
<span class="variable">setTimeout</span>(<span class="variable">partial</span>(<span class="variable">printHere</span>, <span class="string">&quot;Plus maintenant.&quot;</span>), <span class="atom">1000</span>);</pre><p>Pour que le terrarium s’affiche à chaque changement, nous modifions la méthode
<code>step</code> comme suit:</p><pre class="code"><span class="variable">Terrarium</span>.<span class="property">prototype</span>.<span class="property">step</span> = <span class="keyword">function</span>() {
  <span class="variable">forEach</span>(<span class="localvariable">this</span>.<span class="property">listeCreaturesEnAction</span>(),
          <span class="variable">bind</span>(<span class="localvariable">this</span>.<span class="property">actionnerUneCreature</span>, <span class="localvariable">this</span>));
  <span class="keyword">if</span> (<span class="localvariable">this</span>.<span class="property">onStep</span>)
    <span class="localvariable">this</span>.<span class="property">onStep</span>();
};</pre><p>En faisant cela, si une propriété <code>onStep</code> est présente dans l’objet terrarium,
elle est appelée à chaque étape.</p><pre class="code"><span class="keyword">var</span> <span class="variable">terrarium</span> = <span class="keyword">new</span> <span class="variable">Terrarium</span>(<span class="variable">lePlan</span>);
<span class="variable">terrarium</span>.<span class="property">onStep</span> = <span class="variable">partial</span>(<span class="variable">inPlacePrinter</span>(), <span class="variable">terrarium</span>);
<span class="variable">terrarium</span>.<span class="property">start</span>();</pre><p>Remarquez l’utilisation de <code>partial</code> ―&nbsp;cette méthode <code>partial</code> renvoie une
fonction d’affichage appliquée à l’objet terrarium. La fonction d’affichage ne
demandant qu’un seul argument, après application partielle, nous obtenons une
fonction sans argument. C’est exactement ce dont nous avons besoin pour la
propriété <code>onStep</code>.</p><p>N’oubliez pas d’arrêter la simulation du terrarium, quand il perd de son
intérêt (ce qui ne devrait pas tarder), pour éviter de consommer les ressources
de votre ordinateur inutilement :</p><pre class="code"><span class="variable">terrarium</span>.<span class="property">stop</span>();</pre></div><hr/><div class="block"><p>Qui voudrait d’une simulation de terrarium avec une seule sorte d’insecte,
stupide qui plus est&nbsp;? Pas moi. Ce serait judicieux si nous pouvions ajouter
différentes sortes d’insectes. Heureusement, il nous suffit pour cela de rendre
la fonction <code>elementdApresCaractere</code> plus générale. Pour le moment, elle décrit
trois possibilités «&nbsp;codés en dur&nbsp;», c’est-à-dire de façon linéaire et sans
flexibilité :</p><pre class="code"><span class="keyword">function</span> <span class="variable">elementdApresCaractere</span>(<span class="variabledef">caractere</span>) {
  <span class="keyword">if</span> (<span class="localvariable">caractere</span> == <span class="string">&quot; &quot;</span>)
    <span class="keyword">return</span> <span class="atom">undefined</span>;
  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="localvariable">caractere</span> == <span class="string">&quot;#&quot;</span>)
    <span class="keyword">return</span> <span class="variable">mur</span>;
  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="localvariable">caractere</span> == <span class="string">&quot;o&quot;</span>)
    <span class="keyword">return</span> <span class="keyword">new</span> <span class="variable">InsecteStupide</span>();
}</pre><p>Les deux premiers cas restent tels quels, le dernier étant trop spécifique. Une
meilleure approche serait de stocker les constructeurs des objets insectes et
les caractères qui leur correspondent dans un dictionnaire, et de rechercher
dans ce dictionnaire ces caractères :</p><pre class="code"><span class="keyword">var</span> <span class="variable">typesDeCreature</span> = <span class="keyword">new</span> <span class="variable">Dictionary</span>();
<span class="variable">typesDeCreature</span>.<span class="property">enregistre</span> = <span class="keyword">function</span>(<span class="variabledef">constructeurDeInsecte</span>) {
  <span class="localvariable">this</span>.<span class="property">store</span>(<span class="localvariable">constructeurDeInsecte</span>.<span class="property">prototype</span>.<span class="property">caractere</span>, <span class="localvariable">constructeurDeInsecte</span>);
};

<span class="keyword">function</span> <span class="variable">elementdApresCaractere</span>(<span class="variabledef">caractere</span>) {
  <span class="keyword">if</span> (<span class="localvariable">caractere</span> == <span class="string">&quot; &quot;</span>)
    <span class="keyword">return</span> <span class="atom">undefined</span>;
  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="localvariable">caractere</span> == <span class="string">&quot;#&quot;</span>)
    <span class="keyword">return</span> <span class="variable">mur</span>;
  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">typesDeCreature</span>.<span class="property">contains</span>(<span class="localvariable">caractere</span>))
    <span class="keyword">return</span> <span class="keyword">new</span> (<span class="variable">typesDeCreature</span>.<span class="property">lookup</span>(<span class="localvariable">caractere</span>))();
  <span class="keyword">else</span>
    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="variable">Error</span>(<span class="string">&quot;Caractère inconnu: &quot;</span> + <span class="localvariable">caractere</span>);
}</pre><p>Remarquez qu’une méthode <code>enregistre</code> est ajoutée à l’objet <code>typesDeCreature</code>
―&nbsp;celui-ci est de type dictionnaire, ce qui n’empêche en rien de lui ajouter
une méthode. Cette fonction extrait le caractère associé au constructeur de
l’insecte, et stocke ce caractère dans le dictionnaire.  Cette méthode ne doit
être appelée que sur des objets dont le prototype possède une propriété
<code>caractere</code>.</p><p>La fonction <code>elementdApresCaractere</code> est modifiée pour rechercher le caractère
présent dans <code>typesDeCreature</code>, et provoque une exception si elle tombe sur un
caractère inconnu.</p></div><hr/><div class="block"><p>Voici une nouvelle sorte d’insecte, ainsi que les instructions pour enregistrer
son caractère dans <code>typesDeCreature</code> :</p><pre class="code"><span class="keyword">function</span> <span class="variable">InsecteaRebond</span>() {
  <span class="localvariable">this</span>.<span class="property">direction</span> = <span class="string">&quot;ne&quot;</span>;
}
<span class="variable">InsecteaRebond</span>.<span class="property">prototype</span>.<span class="property">agit</span> = <span class="keyword">function</span>(<span class="variabledef">alentours</span>) {
  <span class="keyword">if</span> (<span class="localvariable">alentours</span>[<span class="localvariable">this</span>.<span class="property">direction</span>] != <span class="string">&quot; &quot;</span>)
    <span class="localvariable">this</span>.<span class="property">direction</span> = (<span class="localvariable">this</span>.<span class="property">direction</span> == <span class="string">&quot;ne&quot;</span> ? <span class="string">&quot;so&quot;</span> : <span class="string">&quot;ne&quot;</span>);
  <span class="keyword">return</span> {<span class="property">type</span>: <span class="string">&quot;déplacement&quot;</span>, <span class="property">direction</span>: <span class="localvariable">this</span>.<span class="property">direction</span>};
};
<span class="variable">InsecteaRebond</span>.<span class="property">prototype</span>.<span class="property">caractere</span> = <span class="string">&quot;%&quot;</span>;

<span class="variable">typesDeCreature</span>.<span class="property">enregistre</span>(<span class="variable">InsecteaRebond</span>);</pre><p>Pouvez-vous comprendre ce qu’il fait&nbsp;?</p></div><hr/><div class="block"><a name="exercise6"></a><div class="exercisenum">Ex. 8.6</div><div class="exercise"><p>Créer un insecte nommé <code>InsecteIvre</code> qui essaie de se déplacer dans une
direction quelconque à chaque tour, peu importe s’il y a un mur en face de
lui.  Rappelez-vous le fonctionnement de <code>Math.random</code> dans le <a href="chapter7.html">chapitre 7</a>.</p></div><div class="solution"><p>Pour déterminer une direction de façon aléatoire, nous avons besoin d’un
tableau avec la liste des directions. Nous pourrions juste écrire un tableau de
cette façon : <code>[&quot;n&quot;, &quot;ne&quot;, …]</code>, mais cela dupliquerait des informations, et les
duplications d’information me rendent nerveux. Nous pourrions également
utiliser la méthode <code>each</code> sur le dictionnaire <code>directions</code> pour construire un
nouveau tableau, ce serait déjà mieux.</p><p>Mais vous devez comprendre qu’il y a, ici, une façon bien plus générale de
procéder.  Récupérer la liste des noms de propriété d’un dictionnaire est un
outil utile, aussi, ajoutons-le au prototype de l’objet <code>Dictionary</code>.</p><pre class="code"><span class="variable">Dictionary</span>.<span class="property">prototype</span>.<span class="property">names</span> = <span class="keyword">function</span>() {
  <span class="keyword">var</span> <span class="variabledef">noms</span> = [];
  <span class="localvariable">this</span>.<span class="property">each</span>(<span class="keyword">function</span>(<span class="variabledef">nom</span>, <span class="variabledef">valeur</span>) {<span class="localvariable">noms</span>.<span class="property">push</span>(<span class="localvariable">nom</span>);});
  <span class="keyword">return</span> <span class="localvariable">noms</span>;
};

<span class="variable">show</span>(<span class="variable">directions</span>.<span class="property">names</span>());</pre><p>Un programmeur vraiment névrosé voudrait immédiatement rétablir la symétrie en
ajoutant une méthode <code>values</code> qui retournerait la liste des valeurs d’un
dictionnaire. Mais je suppose que nous pouvons attendre d’en avoir <a href="http://www.c2.com/cgi/wiki?YouArentGonnaNeedIt">vraiment
besoin</a>.</p><p>Voici une façon de prendre un élément d’un tableau au hasard :</p><pre class="code"><span class="keyword">function</span> <span class="variable">elementAuHasard</span>(<span class="variabledef">tableau</span>) {
  <span class="keyword">if</span> (<span class="localvariable">tableau</span>.<span class="property">length</span> == <span class="atom">0</span>)
    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="variable">Error</span>(<span class="string">&quot;Le tableau est vide.&quot;</span>);
  <span class="keyword">return</span> <span class="localvariable">tableau</span>[<span class="variable">Math</span>.<span class="property">floor</span>(<span class="variable">Math</span>.<span class="property">random</span>() * <span class="localvariable">tableau</span>.<span class="property">length</span>)];
}

<span class="variable">show</span>(<span class="variable">elementAuHasard</span>([<span class="string">&quot;face&quot;</span>, <span class="string">&quot;pile&quot;</span>]));</pre><p>Et l’insecte lui-même :</p><pre class="code"><span class="keyword">function</span> <span class="variable">InsecteIvre</span>() {};
<span class="variable">InsecteIvre</span>.<span class="property">prototype</span>.<span class="property">agit</span> = <span class="keyword">function</span>(<span class="variabledef">alentours</span>) {
  <span class="keyword">return</span> {<span class="property">type</span>: <span class="string">&quot;déplacement&quot;</span>,
          <span class="property">direction</span>: <span class="variable">elementAuHasard</span>(<span class="variable">directions</span>.<span class="property">names</span>())};
};
<span class="variable">InsecteIvre</span>.<span class="property">prototype</span>.<span class="property">caractere</span> = <span class="string">&quot;~&quot;</span>;

<span class="variable">typesDeCreature</span>.<span class="property">enregistre</span>(<span class="variable">InsecteIvre</span>);</pre></div></div><hr/><div class="block"><p>Essayons maintenant ces nouveaux insectes :</p><pre class="code"><span class="keyword">var</span> <span class="variable">nouveauPlan</span> =
  [<span class="string">&quot;############################&quot;</span>,
   <span class="string">&quot;#                      #####&quot;</span>,
   <span class="string">&quot;#    ##                 ####&quot;</span>,
   <span class="string">&quot;#   ####     ~ ~          ##&quot;</span>,
   <span class="string">&quot;#    ##       ~            #&quot;</span>,
   <span class="string">&quot;#                          #&quot;</span>,
   <span class="string">&quot;#                ###       #&quot;</span>,
   <span class="string">&quot;#               #####      #&quot;</span>,
   <span class="string">&quot;#                ###       #&quot;</span>,
   <span class="string">&quot;# %        ###        %    #&quot;</span>,
   <span class="string">&quot;#        #######           #&quot;</span>,
   <span class="string">&quot;############################&quot;</span>];

<span class="keyword">var</span> <span class="variable">terrarium</span> = <span class="keyword">new</span> <span class="variable">Terrarium</span>(<span class="variable">nouveauPlan</span>);
<span class="variable">terrarium</span>.<span class="property">onStep</span> = <span class="variable">partial</span>(<span class="variable">inPlacePrinter</span>(), <span class="variable">terrarium</span>);
<span class="variable">terrarium</span>.<span class="property">start</span>();</pre><p>Vous voyez comment les insectes à rebond rebondissent sur les insectes en état
d’ébriété&nbsp;? Dramatique. De toute façon, quand vous en aurez assez de regarder
ce spectacle fascinant, vous pourrez y mettre fin :</p><pre class="code"><span class="variable">terrarium</span>.<span class="property">stop</span>();</pre></div><hr/><div class="block"><p>Nous avons maintenant deux sortes d’objets possédant chacun une méthode <code>agit</code>
et une propriété <code>caractere</code>. Comme ils partagent ces caractéristiques, le
terrarium peut dialoguer avec eux d’une façon commune. Ceci nous autorise à
avoir toutes sortes d’insectes, sans rien changer au code de l’objet terrarium.
Cette technique est appelée <a name="key27"></a>polymorphisme, et c’est sûrement l’un des aspects
les plus puissants de la programmation orientée objet.</p><p>L’idée de base du polymorphisme est que lorsqu’un morceau de programme est
écrit pour manipuler des objets ayant une certaine interface, n’importe quel
objet qui présente cette interface pourra être raccordé à ce morceau de
programme, et le tout fonctionne.  Nous avons déjà vu un exemple de cela, à
savoir la méthode <code>toString</code> de nombreux objets.  Tous les objets ayant une
méthode <code>toString</code> pertinente peuvent être passés à la fonction <code>print</code>, ou
toute autre fonction qui aura besoin de convertir un objet en chaîne de
caractères, peu importe la façon dont cette dernière est produite.</p><p>De la même façon, <code>forEach</code> travaille sur de véritables objets tableau ou sur
des objets similaires aux tableaux, <code>forEach</code> recevant cet objet tableau dans
sa variable <code>arguments</code>, car tout ce dont cette fonction a besoin, ce sont des
propriétés numérotées <code>0</code>, <code>1</code>, et ainsi de suite pour tous les éléments du
tableau.</p></div><hr/><div class="block"><p>Pour rendre la vie dans le terrarium plus réelle, nous allons y ajouter les
concepts de nourriture et de reproduction. Chaque créature vivante du terrarium
reçoit une nouvelle propriété, <code>energie</code>, qui est diminuée lorsqu’elle effectue
une action, et augmentée lorsqu’elle mange quelque chose. Lorsqu’elle a
suffisamment d’énergie, une chose vivante peut se reproduire<a class="footref" href="#footnote2">2</a>, engendrant une
nouvelle créature du même type.</p><p>S’il n’y avait que des insectes, les dépenses d’énergie de leurs déplacements,
et le fait qu’ils se mangeraient entre eux, feraient que notre terrarium
succomberait rapidement sous l’effet de l’entropie, serait à court d’énergie,
et deviendrait un lieu abandonné et sans vie.  Pour empêcher que ceci se
produise (au moins, que cela ne se produise pas trop vite), nous ajoutons du
lichen au terrarium. Les lichens ne se déplacent pas, ils utilisent la
photosynthèse pour produire de l’énergie et se reproduire.</p><p>Pour que cela fonctionne, nous aurons besoin d’un terrarium avec une méthode
<code>actionnerUneCreature</code> différente. Nous pourrions simplement changer cette
méthode dans le prototype de <code>Terrarium</code>, mais nous sommes très attachés à la
simulation des insectes sauteurs et des insectes en état d’ébriété, et ne
voulons pas casser ce premier terrarium.</p><p>Ce que nous pouvons faire est écrire un nouveau constructeur,
<code>TerrariumPlusVivant</code>, dont le prototype est basé sur le prototype de
<code>Terrarium</code>, mais qui possède une méthode <code>actionnerUneCreature</code> différente.</p></div><hr/><div class="block"><p>Il existe plusieurs façon de faire cela. Nous pourrions énumérer les propriétés
de <code>Terrarium.prototype</code>, et les ajouter une à une dans
<code>TerrariumPlusVivant.prototype</code>. Ce serait simple à faire, et dans certains cas
la meilleure solution. Mais ici nous avons une façon plus propre de faire. Si
nous faisons du prototype du premier objet terrarium le prototype du nouveau
terrarium (prenez le temps de bien comprendre cette phrase), ce nouveau
Terrarium en aurait toutes les propriétés.</p><p><a name="key28"></a>Malheureusement, JavaScript ne propose pas de moyen direct de créer
un objet dont le prototype est celui d’un autre objet. Il est possible d’écrire
une fonction qui fait cela, en utilisant l’astuce suivante :</p><pre class="code"><span class="keyword">function</span> <span class="variable">clone</span>(<span class="variabledef">objet</span>) {
  <span class="keyword">function</span> <span class="variabledef">ConstructeurNouveauPourChaqueClone</span>(){}
  <span class="localvariable">ConstructeurNouveauPourChaqueClone</span>.<span class="property">prototype</span> = <span class="localvariable">objet</span>;
  <span class="keyword">return</span> <span class="keyword">new</span> <span class="localvariable">ConstructeurNouveauPourChaqueClone</span>();
}</pre><p>Cette fonction clone déclare un constructeur nommé
ConstructeurNouveauPourChaqueClone qui est vide et unique, dont le prototype
est l’objet passé en argument.  En appelant <code>new</code> sur ce constructeur, un
nouvel objet est créé, basé sur l’objet passé en argument.</p><pre class="code"><span class="keyword">function</span> <span class="variable">TerrariumPlusVivant</span>(<span class="variabledef">plan</span>) {
  <span class="variable">Terrarium</span>.<span class="property">call</span>(<span class="localvariable">this</span>, <span class="localvariable">plan</span>);
}
<span class="variable">TerrariumPlusVivant</span>.<span class="property">prototype</span> = <span class="variable">clone</span>(<span class="variable">Terrarium</span>.<span class="property">prototype</span>);
<span class="variable">TerrariumPlusVivant</span>.<span class="property">prototype</span>.<span class="property">constructor</span> = <span class="variable">TerrariumPlusVivant</span>;</pre><p>Le nouveau constructeur n’a pas besoin de faire quoi que ce soit de plus que
l’ancien, donc il se contente d’appeler l’ancien sur l’objet <code>this</code>. Il nous
faut également restaurer la propriété <code>constructor</code> du nouveau prototype, sinon
il clamerait que son constructeur est <code>Terrarium</code> (ce qui, bien sûr, n’est un
problème que si on se sert de cette propriété, ce qui n’est pas notre cas).</p></div><hr/><div class="block"><p>Il est maintenant possible de remplacer certaines méthodes de l’objet
<code>TerrariumPlusVivant</code>, et d’en ajouter d’autres. Nous avons un type d’objet
basé sur un autre, ce qui nous épargne le travail de récrire toutes les
méthodes communes à <code>Terrarium</code> et <code>TerrariumPlusVivant</code>.  Cette technique est
appelée «&nbsp;<a name="key29"></a>héritage&nbsp;». Le nouveau type hérite des propriétés de l’ancien type.
Dans la plupart des cas, cela signifie que le nouveau type possèdera toujours
l’interface de l’ancien, bien qu’il puisse posséder des méthodes en plus, que
l’ancien n’a pas.  De cette façon, les objets du nouveau type pourraient
prendre la place (selon le polymorphisme) des objets de l’ancien type.</p><p>Dans les langages de programmation avec un support explicite de l’orientation
objet, l’héritage est une chose très simple à mettre en œuvre. JavaScript n’a
pas de moyen simple de le faire.  À cause de cela, les programmeurs en
JavaScript ont inventé différentes approches pour le faire. Malheureusement,
aucune d’entre elles n’est parfaite.</p><p>À la fin de ce chapitre, je vous montrerai d’autres façons de mettre en œuvre
l’héritage, et leurs inconvénients.</p></div><hr/><div class="block"><p>Voici une nouvelle méthode <code>actionnerUneCreature</code>. Elle est volumineuse :</p><pre class="code"><span class="variable">TerrariumPlusVivant</span>.<span class="property">prototype</span>.<span class="property">actionnerUneCreature</span> = <span class="keyword">function</span>(<span class="variabledef">creature</span>) {
  <span class="keyword">var</span> <span class="variabledef">alentours</span> = <span class="localvariable">this</span>.<span class="property">listeAlentours</span>(<span class="localvariable">creature</span>.<span class="property">point</span>);
  <span class="keyword">var</span> <span class="variabledef">action</span> = <span class="localvariable">creature</span>.<span class="property">object</span>.<span class="property">agit</span>(<span class="localvariable">alentours</span>);

  <span class="keyword">var</span> <span class="variabledef">cible</span> = <span class="atom">undefined</span>;
  <span class="keyword">var</span> <span class="variabledef">elementDansCible</span> = <span class="atom">undefined</span>;
  <span class="keyword">if</span> (<span class="localvariable">action</span>.<span class="property">direction</span> &amp;&amp; <span class="variable">directions</span>.<span class="property">contains</span>(<span class="localvariable">action</span>.<span class="property">direction</span>)) {
    <span class="keyword">var</span> <span class="variabledef">direction</span> = <span class="variable">directions</span>.<span class="property">lookup</span>(<span class="localvariable">action</span>.<span class="property">direction</span>);
    <span class="keyword">var</span> <span class="variabledef">directionSouhaitee</span> = <span class="localvariable">creature</span>.<span class="property">point</span>.<span class="property">add</span>(<span class="localvariable">direction</span>);
    <span class="keyword">if</span> (<span class="localvariable">this</span>.<span class="property">grille</span>.<span class="property">estDedans</span>(<span class="localvariable">directionSouhaitee</span> )) {
      <span class="localvariable">cible</span> = <span class="localvariable">directionSouhaitee</span>;
      <span class="localvariable">elementDansCible</span> = <span class="localvariable">this</span>.<span class="property">grille</span>.<span class="property">valeurEn</span>(<span class="localvariable">cible</span>);
    }
  }

  <span class="keyword">if</span> (<span class="localvariable">action</span>.<span class="property">type</span> == <span class="string">&quot;déplacement&quot;</span>) {
    <span class="keyword">if</span> (<span class="localvariable">cible</span> &amp;&amp; !<span class="localvariable">elementDansCible</span>) {
      <span class="localvariable">this</span>.<span class="property">grille</span>.<span class="property">deplaceElement</span>(<span class="localvariable">creature</span>.<span class="property">point</span>, <span class="localvariable">cible</span>);
      <span class="localvariable">creature</span>.<span class="property">point</span> = <span class="localvariable">cible</span>;
      <span class="localvariable">creature</span>.<span class="property">object</span>.<span class="property">energie</span> -= <span class="atom">1</span>;
    }
  }
  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="localvariable">action</span>.<span class="property">type</span> == <span class="string">&quot;manger&quot;</span>) {
    <span class="keyword">if</span> (<span class="localvariable">elementDansCible</span> &amp;&amp; <span class="localvariable">elementDansCible</span>.<span class="property">energie</span>) {
      <span class="localvariable">this</span>.<span class="property">grille</span>.<span class="property">ecritValeurEn</span>(<span class="localvariable">cible</span>, <span class="atom">undefined</span>);
      <span class="localvariable">creature</span>.<span class="property">object</span>.<span class="property">energie</span> += <span class="localvariable">elementDansCible</span>.<span class="property">energie</span>;
    }
  }
  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="localvariable">action</span>.<span class="property">type</span> == <span class="string">&quot;photosynthese&quot;</span>) {
    <span class="localvariable">creature</span>.<span class="property">object</span>.<span class="property">energie</span> += <span class="atom">1</span>;
  }
  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="localvariable">action</span>.<span class="property">type</span> == <span class="string">&quot;reproduction&quot;</span>) {
    <span class="keyword">if</span> (<span class="localvariable">cible</span> &amp;&amp; !<span class="localvariable">elementDansCible</span>) {
      <span class="keyword">var</span> <span class="variabledef">espece</span> = <span class="variable">caracteredApresElement</span>(<span class="localvariable">creature</span>.<span class="property">object</span>);
      <span class="keyword">var</span> <span class="variabledef">nouvelleCreature</span> = <span class="variable">elementdApresCaractere</span>(<span class="localvariable">espece</span>);
      <span class="comment">//la créature parente perd 2 fois la quantité d’énergie de la créature naissante</span>
      <span class="localvariable">creature</span>.<span class="property">object</span>.<span class="property">energie</span> -= <span class="localvariable">nouvelleCreature</span>.<span class="property">energie</span> * <span class="atom">2</span>;
      <span class="keyword">if</span> (<span class="localvariable">creature</span>.<span class="property">object</span>.<span class="property">energie</span> &gt; <span class="atom">0</span>)
        <span class="localvariable">this</span>.<span class="property">grille</span>.<span class="property">ecritValeurEn</span>(<span class="localvariable">cible</span>, <span class="localvariable">nouvelleCreature</span>);
    }
  }
  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="localvariable">action</span>.<span class="property">type</span> == <span class="string">&quot;attente&quot;</span>) {
    <span class="localvariable">creature</span>.<span class="property">object</span>.<span class="property">energie</span> -= <span class="atom">0.2</span>;
  }
  <span class="keyword">else</span> {
    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="variable">Error</span>(<span class="string">&quot;Action invalide : &quot;</span> + <span class="localvariable">action</span>.<span class="property">type</span>);
  }

  <span class="keyword">if</span> (<span class="localvariable">creature</span>.<span class="property">object</span>.<span class="property">energie</span> &lt;= <span class="atom">0</span>)
    <span class="localvariable">this</span>.<span class="property">grille</span>.<span class="property">ecritValeurEn</span>(<span class="localvariable">creature</span>.<span class="property">point</span>, <span class="atom">undefined</span>);
};</pre><p>La fonction commence toujours par interroger les créatures pour une action. 
Ensuite, si l’action possède une propriété <code>direction</code>, la fonction détermine
immédiatement à quel endroit de la grille cette direction amène, et ce qu’il y
a à cet endroit. Trois des cinq actions implantées dans notre simulation ont
besoin de savoir cela, et le code serait encore plus difficile à comprendre si
ces calculs étaient faits à part.  Si l’action n’a pas de propriété
<code>direction</code>, ou si celle-ci est incorrecte, les variables <code>cible</code> et
<code>elementDansCible</code> restent à leur valeur undefined.</p><p>Après cela, toutes les actions sont passées en revue. Certaines actions
demandent des vérifications supplémentaires avant leur exécution, ce qui est
fait en utilisant un <code>if</code> distinct pour que si une créature cherche, par
exemple, à passer à travers un mur, une exception <code>&quot;Action invalide&quot;</code> ne soit
pas générée.</p><p>Remarquez que dans l’action <code>&quot;reproduction&quot;</code>, la créature parente perd deux
fois la quantité d’énergie reçue par la nouvelle créature (la procréation n’est
pas une chose facile), et la nouvelle créature n’est placée sur la grille que
si son parent a suffisant d’énergie pour l’engendrer.</p><p>Après qu’une action a été effectuée, nous regardons si la créature a encore de
l’énergie. Si elle n’en a plus, elle meurt, et nous la supprimons.</p></div><hr/><div class="block"><p>Le lichen n’est pas un organisme très complexe. Nous allons utiliser le
caractère <code>&quot;*&quot;</code> pour le représenter. Vérifiez que vous avez bien défini la
fonction <code>elementAuHasard</code> pour l’<a href="chapter8.html#exercise6">exercice 8.6</a>, car elle sera utilisée de
nouveau ici.</p><pre class="code"><span class="keyword">function</span> <span class="variable">Lichen</span>() {
  <span class="localvariable">this</span>.<span class="property">energie</span> = <span class="atom">5</span>;
}
<span class="variable">Lichen</span>.<span class="property">prototype</span>.<span class="property">agit</span> = <span class="keyword">function</span>(<span class="variabledef">alentours</span>) {
  <span class="keyword">var</span> <span class="variabledef">espaceVide</span> = <span class="variable">trouverDirections</span>(<span class="localvariable">alentours</span>, <span class="string">&quot; &quot;</span>);
  <span class="keyword">if</span> (<span class="localvariable">this</span>.<span class="property">energie</span> &gt;= <span class="atom">13</span> &amp;&amp; <span class="localvariable">espaceVide</span>.<span class="property">length</span> &gt; <span class="atom">0</span>)
    <span class="keyword">return</span> {<span class="property">type</span>: <span class="string">&quot;reproduction&quot;</span>, <span class="property">direction</span>: <span class="variable">elementAuHasard</span>(<span class="localvariable">espaceVide</span>)};
  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="localvariable">this</span>.<span class="property">energie</span> &lt; <span class="atom">20</span>)
    <span class="keyword">return</span> {<span class="property">type</span>: <span class="string">&quot;photosynthese&quot;</span>};
  <span class="keyword">else</span>
    <span class="keyword">return</span> {<span class="property">type</span>: <span class="string">&quot;attente&quot;</span>};
};
<span class="variable">Lichen</span>.<span class="property">prototype</span>.<span class="property">caractere</span> = <span class="string">&quot;*&quot;</span>;

<span class="variable">typesDeCreature</span>.<span class="property">enregistre</span>(<span class="variable">Lichen</span>);

<span class="keyword">function</span> <span class="variable">trouverDirections</span>(<span class="variabledef">alentours</span>, <span class="variabledef">directionSouhaite</span>) {
  <span class="keyword">var</span> <span class="variabledef">trouve</span> = [];
  <span class="variable">directions</span>.<span class="property">each</span>(<span class="keyword">function</span>(<span class="variabledef">name</span>) {
    <span class="keyword">if</span> (<span class="localvariable">alentours</span>[<span class="localvariable">name</span>] == <span class="localvariable">directionSouhaite</span>)
      <span class="localvariable">trouve</span>.<span class="property">push</span>(<span class="localvariable">name</span>);
  });
  <span class="keyword">return</span> <span class="localvariable">trouve</span>;
}</pre><p>Les lichens ne grandissent jamais au-delà de 20 unités d’énergie, sinon ils
seraient trop imposants, quand, encerclés par d’autre lichens, ils n’ont plus
de place pour se reproduire.</p></div><hr/><div class="block"><a name="exercise7"></a><div class="exercisenum">Ex. 8.7</div><div class="exercise"><p>Créez une créature dévoreuse de lichens, <code>MangeuseLichen</code>. Elle commence avec
<code>10</code> unités d’énergie, et agit de la façon suivante :</p><ul><li>Quand elle a 30 ou plus d’énergie et une case vide près d’elle, elle se reproduit.</li><li>Sinon, s’il y a du lichen près d’elle, elle en mange un, choisi aléatoirement.</li><li>Sinon, s’il y a la place de se bouger, elle va vers une cases vide aléatoire.</li><li>Sinon elle attend.</li></ul><p>Utiliser les fonctions <code>trouverDirections</code> et <code>elementAuHasard</code> pour déterminer
le contenu de l’entourage de la créature, et faire des choix aléatoires. Donner
à cette créature le caractère <code>&quot;c&quot;</code> (pour faire penser à pac-man).</p></div><div class="solution"><pre class="code"><span class="keyword">function</span> <span class="variable">MangeuseLichen</span>() {
  <span class="localvariable">this</span>.<span class="property">energie</span> = <span class="atom">10</span>;
}
<span class="variable">MangeuseLichen</span>.<span class="property">prototype</span>.<span class="property">agit</span> = <span class="keyword">function</span>(<span class="variabledef">alentours</span>) {
  <span class="keyword">var</span> <span class="variabledef">espaceVide</span> = <span class="variable">trouverDirections</span>(<span class="localvariable">alentours</span>, <span class="string">&quot; &quot;</span>);
  <span class="keyword">var</span> <span class="variabledef">lichen</span> = <span class="variable">trouverDirections</span>(<span class="localvariable">alentours</span>, <span class="string">&quot;*&quot;</span>);

  <span class="keyword">if</span> (<span class="localvariable">this</span>.<span class="property">energie</span> &gt;= <span class="atom">30</span> &amp;&amp; <span class="localvariable">espaceVide</span>.<span class="property">length</span> &gt; <span class="atom">0</span>)
    <span class="keyword">return</span> {<span class="property">type</span>: <span class="string">&quot;reproduction&quot;</span>, <span class="property">direction</span>: <span class="variable">elementAuHasard</span>(<span class="localvariable">espaceVide</span>)};
  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="localvariable">lichen</span>.<span class="property">length</span> &gt; <span class="atom">0</span>)
    <span class="keyword">return</span> {<span class="property">type</span>: <span class="string">&quot;manger&quot;</span>, <span class="property">direction</span>: <span class="variable">elementAuHasard</span>(<span class="localvariable">lichen</span>)};
  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="localvariable">espaceVide</span>.<span class="property">length</span> &gt; <span class="atom">0</span>)
    <span class="keyword">return</span> {<span class="property">type</span>: <span class="string">&quot;déplacement&quot;</span>, <span class="property">direction</span>: <span class="variable">elementAuHasard</span>(<span class="localvariable">espaceVide</span>)};
  <span class="keyword">else</span>
    <span class="keyword">return</span> {<span class="property">type</span>: <span class="string">&quot;attente&quot;</span>};
};
<span class="variable">MangeuseLichen</span>.<span class="property">prototype</span>.<span class="property">caractere</span> = <span class="string">&quot;c&quot;</span>;

<span class="variable">typesDeCreature</span>.<span class="property">enregistre</span>(<span class="variable">MangeuseLichen</span>);</pre></div></div><hr/><div class="block"><p>Et pour l’essayer.</p><pre class="code"><span class="keyword">var</span> <span class="variable">lichenPlan</span> =
  [<span class="string">&quot;############################&quot;</span>,
   <span class="string">&quot;#                     ######&quot;</span>,
   <span class="string">&quot;#    ***                **##&quot;</span>,
   <span class="string">&quot;#   *##**         **  c  *##&quot;</span>,
   <span class="string">&quot;#    ***     c    ##**    *#&quot;</span>,
   <span class="string">&quot;#       c         ##***   *#&quot;</span>,
   <span class="string">&quot;#                 ##**    *#&quot;</span>,
   <span class="string">&quot;#   c       #*            *#&quot;</span>,
   <span class="string">&quot;#*          #**       c   *#&quot;</span>,
   <span class="string">&quot;#***        ##**    c    **#&quot;</span>,
   <span class="string">&quot;#*****     ###***       *###&quot;</span>,
   <span class="string">&quot;############################&quot;</span>];

<span class="keyword">var</span> <span class="variable">terrarium</span> = <span class="keyword">new</span> <span class="variable">TerrariumPlusVivant</span>(<span class="variable">lichenPlan</span>);
<span class="variable">terrarium</span>.<span class="property">onStep</span> = <span class="variable">partial</span>(<span class="variable">inPlacePrinter</span>(), <span class="variable">terrarium</span>);
<span class="variable">terrarium</span>.<span class="property">start</span>();</pre><p>La plupart du temps, vous devriez voir le lichen envahir rapidement le
terrarium&nbsp;; cette abondance de nourriture provoquera une abondance de créatures
voraces, si nombreuses qu’elles finiront par épuiser les ressources en lichen,
et enfin s’épuiser elles-mêmes. La nature est si tragique.</p><pre class="code"><span class="variable">terrarium</span>.<span class="property">stop</span>();</pre></div><hr/><div class="block"><p>Constater que les occupants de votre terrarium disparaissent après quelques
minutes est un peu déprimant. Pour y faire face, nous allons éduquer nos
créatures dévoreuses de lichen au principe de l’agriculture raisonnée. En
faisant qu’elles ne mangent du lichen que si elles sont à proximité de deux
d’entre eux, quel que soit l’état de leur faim, elles ne pourront plus
exterminer le lichen. Cela demande de la discipline, mais le résultat est un
biotope qui ne s’autodétruit pas.  Voici une nouvelle méthode <code>agit</code> ―&nbsp;le seul
changement est que l’action de manger ne se fait que si <code>lichen.length</code> est au
moins égal à 2.</p><pre class="code"><span class="variable">MangeuseLichen</span>.<span class="property">prototype</span>.<span class="property">agit</span> = <span class="keyword">function</span>(<span class="variabledef">alentours</span>) {
  <span class="keyword">var</span> <span class="variabledef">espaceVide</span> = <span class="variable">trouverDirections</span>(<span class="localvariable">alentours</span>, <span class="string">&quot; &quot;</span>);
  <span class="keyword">var</span> <span class="variabledef">lichen</span> = <span class="variable">trouverDirections</span>(<span class="localvariable">alentours</span>, <span class="string">&quot;*&quot;</span>);

  <span class="keyword">if</span> (<span class="localvariable">this</span>.<span class="property">energie</span> &gt;= <span class="atom">30</span> &amp;&amp; <span class="localvariable">espaceVide</span>.<span class="property">length</span> &gt; <span class="atom">0</span>)
    <span class="keyword">return</span> {<span class="property">type</span>: <span class="string">&quot;reproduction&quot;</span>, <span class="property">direction</span>: <span class="variable">elementAuHasard</span>(<span class="localvariable">espaceVide</span>)};
  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="localvariable">lichen</span>.<span class="property">length</span> &gt; <span class="atom">1</span>)
    <span class="keyword">return</span> {<span class="property">type</span>: <span class="string">&quot;manger&quot;</span>, <span class="property">direction</span>: <span class="variable">elementAuHasard</span>(<span class="localvariable">lichen</span>)};
  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="localvariable">espaceVide</span>.<span class="property">length</span> &gt; <span class="atom">0</span>)
    <span class="keyword">return</span> {<span class="property">type</span>: <span class="string">&quot;déplacement&quot;</span>, <span class="property">direction</span>: <span class="variable">elementAuHasard</span>(<span class="localvariable">espaceVide</span>)};
  <span class="keyword">else</span>
    <span class="keyword">return</span> {<span class="property">type</span>: <span class="string">&quot;attente&quot;</span>};
};</pre><p>Faites fonctionner la simulation du terrarium <code>lichenPlan</code> à nouveau et
constatez son évolution. À moins d’être très chanceux, vous allez probablement
constater l’extinction des créatures dévoreuses au bout d’un certain temps,
parce que lorsque survient la famine, ces créatures se déplacent de façon
désordonnée, au lieu de rechercher le lichen qui n’est pas très loin d’elles.</p></div><hr/><div class="block"><a name="exercise8"></a><div class="exercisenum">Ex. 8.8</div><div class="exercise"><p>Cherchez un moyen de rendre la créature <code>MangeuseLichen</code> plus apte à la survie.
Ne trichez pas ―&nbsp;une instruction <code>this.energie += 100</code> serait de la triche. Si
vous réécrivez le constructeur, n’oubliez pas de l’enregistrer à nouveau dans
le dictionnaire <code>typesDeCreature</code>, sinon le terrarium continuerait d’utiliser
l’ancien constructeur.</p></div><div class="solution"><p>Une approche serait de restreindre le caractère aléatoire des déplacements. En
choisissant systématiquement une direction aléatoire, elles reviennent très
souvent sur leurs pas, sans rien trouver à manger. En se rappelant la direction
d’où elles viennent, et en privilégiant cette direction, elles dépenseraient
moins de temps et trouveraient plus facilement de la nourriture.</p><pre class="code"><span class="keyword">function</span> <span class="variable">MangeuseLichenHabile</span>() {
  <span class="localvariable">this</span>.<span class="property">energie</span> = <span class="atom">10</span>;
  <span class="localvariable">this</span>.<span class="property">direction</span> = <span class="string">&quot;ne&quot;</span>;
}
<span class="variable">MangeuseLichenHabile</span>.<span class="property">prototype</span>.<span class="property">agit</span> = <span class="keyword">function</span>(<span class="variabledef">alentours</span>) {
  <span class="keyword">var</span> <span class="variabledef">espaceVide</span> = <span class="variable">trouverDirections</span>(<span class="localvariable">alentours</span>, <span class="string">&quot; &quot;</span>);
  <span class="keyword">var</span> <span class="variabledef">lichen</span> = <span class="variable">trouverDirections</span>(<span class="localvariable">alentours</span>, <span class="string">&quot;*&quot;</span>);

  <span class="keyword">if</span> (<span class="localvariable">this</span>.<span class="property">energie</span> &gt;= <span class="atom">30</span> &amp;&amp; <span class="localvariable">espaceVide</span>.<span class="property">length</span> &gt; <span class="atom">0</span>) {
    <span class="keyword">return</span> {<span class="property">type</span>: <span class="string">&quot;reproduction&quot;</span>,
            <span class="property">direction</span>: <span class="variable">elementAuHasard</span>(<span class="localvariable">espaceVide</span>)};
  }
  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="localvariable">lichen</span>.<span class="property">length</span> &gt; <span class="atom">1</span>) {
    <span class="keyword">return</span> {<span class="property">type</span>: <span class="string">&quot;manger&quot;</span>,
            <span class="property">direction</span>: <span class="variable">elementAuHasard</span>(<span class="localvariable">lichen</span>)};
  }
  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="localvariable">espaceVide</span>.<span class="property">length</span> &gt; <span class="atom">0</span>) {
    <span class="keyword">if</span> (<span class="localvariable">alentours</span>[<span class="localvariable">this</span>.<span class="property">direction</span>] != <span class="string">&quot; &quot;</span>)
      <span class="localvariable">this</span>.<span class="property">direction</span> = <span class="variable">elementAuHasard</span>(<span class="localvariable">espaceVide</span>);
    <span class="keyword">return</span> {<span class="property">type</span>: <span class="string">&quot;déplacement&quot;</span>,
            <span class="property">direction</span>: <span class="localvariable">this</span>.<span class="property">direction</span>};
  }
  <span class="keyword">else</span> {
    <span class="keyword">return</span> {<span class="property">type</span>: <span class="string">&quot;attente&quot;</span>};
  }
};
<span class="variable">MangeuseLichenHabile</span>.<span class="property">prototype</span>.<span class="property">caractere</span> = <span class="string">&quot;c&quot;</span>;

<span class="variable">typesDeCreature</span>.<span class="property">enregistre</span>(<span class="variable">MangeuseLichenHabile</span>);</pre><p>Essayez-la avec le plan de terrarium précédent.</p></div></div><hr/><div class="block"><a name="exercise9"></a><div class="exercisenum">Ex. 8.9</div><div class="exercise"><p>Une chaîne alimentaire à un seul maillon est un peu rudimentaire. Pouvez-vous
écrire une nouvelle créature, nommée <code>MangeuseMangeuseLichen</code>, (avec un
caractère <code>&quot;@&quot;</code>), qui survit en mangeant des dévoreuses de lichens ? Trouver
également un moyen pour cette nouvelle créature de s’intégrer dans l’écosystème
sans qu’elles ne s’éteignent trop vite. Modifiez le tableau <code>lichenPlan</code> pour
inclure quelques-unes d’entre elles, et essayez le tout.</p></div><div class="solution"><p>C’est maintenant à vous de jouer, je n’ai pas trouvé de moyen véritablement
efficace d’empêcher ces créatures de s’éteindre immédiatement ou d’engloutir
toutes les dévoreuses de lichen, et de s’éteindre ensuite.  L’astuce qui
consiste à autoriser une créature à ne manger que lorsque deux unités de
nourriture sont à proximité ne fonctionnent pas très bien pour elles, car, leur
nourriture étant souvent en déplacement, il est rare d’en trouver deux à
proximité l’une de l’autre.  Rendre les dévoreuses de dévoreuses très grasses
(avec beaucoup d’énergie) à quelque efficacité, car elles peuvent survivre
lorsque les dévoreuses de lichen se font rare et se reproduisent doucement, ce
qui empêche une raréfaction trop rapide de leur nourriture.</p><p>Les lichens et les créatures qui les mangent sont dans un mouvement périodique
―&nbsp;parfois les lichens sont abondants, ce qui provoque beaucoup de naissance de
mangeurs de lichen, ce qui provoque ensuite une rareté du lichen, puis la
rareté des mangeurs de lichen, enfin le lichen prospère à nouveau, et ainsi de
suite.  Vous pouvez essayer de faire &quot;hiberner&quot; les mangeurs de mangeurs de
lichen (utiliser l’action <code>&quot;attente&quot;</code> un certain temps), quand ils n’ont rien à
manger pour quelques tours.  Une stratégie serait de trouver la bonne durée
d’hibernation, en nombre de tours, ou de leur donner un moyen de se réveiller
lorsqu’ils sentent beaucoup de nourriture.</p></div></div><hr/><div class="block"><p>Ceci termine notre discussion sur les terraria. Le reste de ce chapitre est
dédié à une exploration en profondeur du concept d’héritage, et les problèmes
liés à l’héritage en JavaScript.</p></div><hr/><div class="block"><p>Maintenant, un peu de théorie. Les étudiants qui abordent la programmation
orientée objet sont souvent confrontés à des discussions longues et pleines de
subtilité sur les façons correctes et incorrectes d’utiliser l’héritage. Il est
important de garder à l’esprit qu’au bout du compte, l’héritage est un moyen
pour des programmeurs paresseux<a class="footref" href="#footnote3">3</a> d’écrire moins de code. Ainsi, la question de
savoir si l’héritage est correctement utilisé se résume à la question de savoir
si le code produit fonctionne correctement et n’a pas de répétition inutile.
Pour autant, les principes discutés par ces étudiants sont aussi une bonne
façon d’aborder l’héritage.</p><p>L’héritage est la création de nouveaux types d’objet, les
«&nbsp;<a name="key30"></a>sous-types&nbsp;», basés sur des types existants, les
«&nbsp;<a name="key31"></a>super-types&nbsp;». Le sous-type commence avec la totalité des
propriétés et des méthodes du super-type, il hérite de lui, ensuite, il en
modifie quelques-uns, éventuellement en ajoute.  L’héritage est mieux utilisé
quand les objets décrits par le sous-type peuvent être considérés comme <em>étant</em>
également des objets du super-type.</p><p>Ainsi, un type <code>Piano</code> peut être un sous-type du type <code>Instrument</code>, parce qu’un
piano <em>est</em> un instrument. Un piano comportant un tableau de touches, on peut
être tenté de faire de <code>Piano</code> un sous-type de <code>Array</code>, mais un piano <em>n’est
pas</em> un tableau, et l’implémenter de cette façon entraînerait de nombreux
comportements idiots. Par exemple, un piano a aussi des pédales. Pourquoi
<code>piano[0]</code> me renverrait-il la première touche, et non la première pédale&nbsp;? Il
se trouve que, évidemment, le piano <em>possède</em> des touches, il est donc
préférable de lui donner une propriété <code>touches</code>, et éventuellement une autre
propriété <code>pédales</code>, ces deux propriétés étant des tableaux.</p><p>Il est possible pour un sous-type d’être le super-type d’un autre sous-type.
Certains problèmes sont mieux résolus en construisant un arbre complexe de
types. Prenez garde à ne pas être trop enthousiaste avec l’héritage. Une
utilisation abusive de l’héritage est un bon moyen de transformer un programme
en un bazar monstrueux.</p></div><hr/><div class="block"><p>Le fonctionnement du mot-clé <code>new</code> et la propriété <code>prototype</code> d’un
constructeur suggèrent une certaine façon d’utiliser les objets. Pour des
objets simples, comme les créatures du terrarium, cette façon fonctionne bien. 
Malheureusement, quand un programme utilise l’héritage de façon plus développé,
cette approche de la programmation objet devient pesante. Ajouter des fonctions
pour prendre en charge les opérations les plus courantes peut rendre les choses
plus fluides. De nombreuses personnes définissent, par exemple, des méthodes
<code>inherit</code> et <code>method</code> sur les objets.</p><pre class="code"><span class="variable">Object</span>.<span class="property">prototype</span>.<span class="property">inherit</span> = <span class="keyword">function</span>(<span class="variabledef">constructeurDeBase</span>) {
  <span class="localvariable">this</span>.<span class="property">prototype</span> = <span class="variable">clone</span>(<span class="localvariable">constructeurDeBase</span>.<span class="property">prototype</span>);
  <span class="localvariable">this</span>.<span class="property">prototype</span>.<span class="property">constructor</span> = <span class="localvariable">this</span>;
};
<span class="variable">Object</span>.<span class="property">prototype</span>.<span class="property">method</span> = <span class="keyword">function</span>(<span class="variabledef">nom</span>, <span class="variabledef">func</span>) {
  <span class="localvariable">this</span>.<span class="property">prototype</span>[<span class="localvariable">nom</span>] = <span class="localvariable">func</span>;
};

<span class="keyword">function</span> <span class="variable">TableauEtrange</span>(){}
<span class="variable">TableauEtrange</span>.<span class="property">inherit</span>(<span class="variable">Array</span>);
<span class="variable">TableauEtrange</span>.<span class="property">method</span>(<span class="string">&quot;push&quot;</span>, <span class="keyword">function</span>(<span class="variabledef">valeur</span>) {
  <span class="variable">Array</span>.<span class="property">prototype</span>.<span class="property">push</span>.<span class="property">call</span>(<span class="localvariable">this</span>, <span class="localvariable">valeur</span>);
  <span class="variable">Array</span>.<span class="property">prototype</span>.<span class="property">push</span>.<span class="property">call</span>(<span class="localvariable">this</span>, <span class="localvariable">valeur</span>);
});

<span class="keyword">var</span> <span class="variable">etrange</span> = <span class="keyword">new</span> <span class="variable">TableauEtrange</span>();
<span class="variable">etrange</span>.<span class="property">push</span>(<span class="atom">4</span>);
<span class="variable">show</span>(<span class="variable">etrange</span>);</pre><p>Si vous cherchez sur Internet les mots «&nbsp;JavaScript&nbsp;» et «&nbsp;héritage&nbsp;», vous
trouverez de nombreuses variantes de ces fonctions, certaines sont plus
complexes et plus subtiles que celles ci-dessus.</p><p>Remarquez comment la méthode <code>push</code> écrite ici utilise la méthode <code>push</code> du
prototype de son type parent. C’est quelque chose qui se fait fréquemment lors
de l’utilisation de l’héritage ―&nbsp;une méthode du sous-type utilise en interne
une méthode du super-type, mais en la modifiant d’une manière ou d’une autre.</p></div><hr/><div class="block"><p>La plus grande difficulté dans cette approche simpliste est la dualité entre
les constructeurs et les prototypes. Les constructeurs ont un rôle vraiment
central, ils sont le moyen par lequel les objets prennent leur nom, et quand
vous avez besoin d’accéder à un prototype, vous devez passer par le
constructeur et sa propriété prototype.</p><p>Cela ajoute <em>beaucoup</em> de frappes au clavier (<code>&quot;prototype&quot;</code> prend 9 lettres),
de plus, c’est déroutant. Nous avons eu besoin d’écrire un constructeur vide et
inutile pour <code>TableauEtrange</code> dans l’exemple précédent. Quelquefois, il m’est
arrivé d’ajouter par erreur des méthodes à un constructeur au lieu de son
prototype, ou d’essayer d’appeler <code>Array.slice</code> alors que je voulais appeler
<code>Array.prototype.slice</code>. Autant que je sache, le prototype lui-même est
l’aspect le plus important d’un type d’objet, et le constructeur n’est qu’une
extension de cela, une méthode spéciale.</p></div><hr/><div class="block"><p>En ajoutant quelques méthodes simples d’aide à <code>Object.prototype</code>, il devient
possible de créer une approche alternative aux objets et à l’héritage. Dans
cette approche, un type est représenté par son prototype, et nous allons
utiliser des variables en majuscule pour stocker ces prototypes. Quand il faut
faire un peu de travail de «&nbsp;construction&nbsp;», cela est réalisé par une méthode
appelée <code>construct</code>. Nous ajoutons une méthode appelée <code>create</code> au prototype
<code>Object</code>, qui est utilisée à la place du mot-clé <code>new</code>. Elle clone l’objet, et
appelle sa méthode <code>construct</code>, si une telle méthode existe, en lui passant en
argument ceux qui ont été passés à <code>create</code>.</p><pre class="code"><span class="variable">Object</span>.<span class="property">prototype</span>.<span class="property">create</span> = <span class="keyword">function</span>() {
  <span class="keyword">var</span> <span class="variabledef">objet</span> = <span class="variable">clone</span>(<span class="localvariable">this</span>);
  <span class="keyword">if</span> (typeof <span class="localvariable">objet</span>.<span class="property">construct</span> == <span class="string">&quot;function&quot;</span>)
    <span class="localvariable">objet</span>.<span class="property">construct</span>.<span class="property">apply</span>(<span class="localvariable">objet</span>, <span class="localvariable">arguments</span>);
  <span class="keyword">return</span> <span class="localvariable">objet</span>;
};</pre><p>L’héritage peut être réalisé en clonant un objet prototype et en ajoutant ou
remplaçant certaines de ses propriétés. Nous fournissons également une aide
pratique pour réaliser cela, une méthode <code>extend</code>, qui clone l’objet sur lequel
on l’appelle et qui ajoute à ce clone les propriétés de l’objet qui lui est
donné en argument.</p><pre class="code"><span class="variable">Object</span>.<span class="property">prototype</span>.<span class="property">extend</span> = <span class="keyword">function</span>(<span class="variabledef">properties</span>) {
  <span class="keyword">var</span> <span class="variabledef">resultat</span> = <span class="variable">clone</span>(<span class="localvariable">this</span>);
  <span class="variable">forEachIn</span>(<span class="localvariable">properties</span>, <span class="keyword">function</span>(<span class="variabledef">nom</span>, <span class="variabledef">valeur</span>) {
    <span class="localvariable">resultat</span>[<span class="localvariable">nom</span>] = <span class="localvariable">valeur</span>;
  });
  <span class="keyword">return</span> <span class="localvariable">resultat</span>;
};</pre><p>Dans le cas où il n’est pas prudent de tripoter le prototype <code>Object</code>, cela
peut bien évidemment être implémenté avec des fonctions classiques (pas des
méthodes).</p></div><hr/><div class="block"><p>Voici un exemple, si vous êtes suffisamment vieux, vous avez peut-être déjà
joué à un jeu d’aventure en mode texte, où vous vous déplaciez dans un monde
virtuel en tapant au clavier des commandes, et obteniez des réponses sous forme
de texte décrivant ce qu’il y avait autour de vous et les actions que vous
effectuiez. Ces jeux ont eu leur temps.</p><p>Nous pouvons écrire un prototype pour un élément d’un jeu de ce type.</p><pre class="code"><span class="keyword">var</span> <span class="variable">Produit</span> = {
  <span class="property">construct</span>: <span class="keyword">function</span>(<span class="variabledef">nom</span>) {
    <span class="localvariable">this</span>.<span class="property">nom</span> = <span class="localvariable">nom</span>;
  },
  <span class="property">examiner</span>: <span class="keyword">function</span>() {
    <span class="variable">print</span>(<span class="string">&quot;C’est &quot;</span>, <span class="localvariable">this</span>.<span class="property">nom</span>, <span class="string">&quot;.&quot;</span>);
  },
  <span class="property">frapper</span>: <span class="keyword">function</span>() {
    <span class="variable">print</span>(<span class="string">&quot;Blang&nbsp;!&quot;</span>);
  },
  <span class="property">prendre</span>: <span class="keyword">function</span>() {
    <span class="variable">print</span>(<span class="string">&quot;Vous ne pouvez pas soulever &quot;</span>, <span class="localvariable">this</span>.<span class="property">nom</span>, <span class="string">&quot;.&quot;</span>);
  }
};

<span class="keyword">var</span> <span class="variable">lanterne</span> = <span class="variable">Produit</span>.<span class="property">create</span>(<span class="string">&quot;La lanterne en laiton&quot;</span>);
<span class="variable">lanterne</span>.<span class="property">frapper</span>();</pre><p>Héritons de ce type de cette façon…</p><pre class="code"><span class="keyword">var</span> <span class="variable">ProduitDetaille</span> = <span class="variable">Produit</span>.<span class="property">extend</span>({
  <span class="property">construct</span>: <span class="keyword">function</span>(<span class="variabledef">nom</span>, <span class="variabledef">details</span>) {
    <span class="variable">Produit</span>.<span class="property">construct</span>.<span class="property">call</span>(<span class="localvariable">this</span>, <span class="localvariable">nom</span>);
    <span class="localvariable">this</span>.<span class="property">details</span> = <span class="localvariable">details</span>;
  },
  <span class="property">examiner</span>: <span class="keyword">function</span>() {
    <span class="variable">print</span>(<span class="string">&quot;vous voyez &quot;</span>, <span class="localvariable">this</span>.<span class="property">nom</span>, <span class="string">&quot;, &quot;</span>, <span class="localvariable">this</span>.<span class="property">details</span>, <span class="string">&quot;.&quot;</span>);
  }
});

<span class="keyword">var</span> <span class="variable">paresseuxGeant</span> = <span class="variable">ProduitDetaille</span>.<span class="property">create</span>(
  <span class="string">&quot;le paresseux géant&quot;</span>,
  <span class="string">&quot;il s’accroche tranquillement sur un arbre en grignotant des feuilles&quot;</span>);
<span class="variable">paresseuxGeant</span>.<span class="property">examiner</span>();</pre><p>Mettre à part l’utilisation de <code>prototype</code> simplifie les choses, par exemple le
constructeur de <code>ProduitDetaille</code> peut appeler directement <code>Produit.contruct</code>. 
Remarquez que ce serait une mauvaise idée d’écrire simplement <code>this.nom = nom</code>
dans <code>ProduitDetaille.construct</code>. Cela duplique une ligne. Bien sûr, dupliquer
cette ligne est plus court qu’appeler la fonction <code>Produit.construct</code> mais si
on se retrouve à ajouter plus tard quelque chose dans le constructeur, nous
devrons l’ajouter à deux endroits différents.</p></div><hr/><div class="block"><p>La plupart du temps, le constructeur d’un sous-type commencera par appeler le
constructeur du super-type. De cette façon, il démarre avec un objet valide du
super-type, qu’il peut alors étendre. Dans cette nouvelle approche des
prototypes, les types qui n’ont pas besoin de constructeurs peuvent les laisser
tomber. Ils hériteront automatiquement du constructeur de leur super-type.</p><pre class="code"><span class="keyword">var</span> <span class="variable">PetitProduit</span> = <span class="variable">Produit</span>.<span class="property">extend</span>({
  <span class="property">frapper</span>: <span class="keyword">function</span>() {
    <span class="variable">print</span>(<span class="localvariable">this</span>.<span class="property">nom</span>, <span class="string">&quot; vole à travers la pièce.&quot;</span>);
  },
  <span class="property">prendre</span>: <span class="keyword">function</span>() {
    <span class="comment">// (imaginez ici du code qui déplace l’objet dans votre poche)</span>
    <span class="variable">print</span>(<span class="string">&quot;vous prenez &quot;</span>, <span class="localvariable">this</span>.<span class="property">nom</span>, <span class="string">&quot;.&quot;</span>);
  }
});

<span class="keyword">var</span> <span class="variable">stylo</span> = <span class="variable">PetitProduit</span>.<span class="property">create</span>(<span class="string">&quot;le stylo rouge&quot;</span>);
<span class="variable">stylo</span>.<span class="property">prendre</span>();</pre><p>Même si <code>PetitProduit</code> ne définit pas son propre constructeur, le créer avec un
argument <code>nom</code> fonctionne, car il hérite du constructeur du prototype
<code>Produit</code>.</p></div><hr/><div class="block"><p>JavaScript possède un opérateur appelé <a name="key32"></a><code>instanceof</code>, qui peut être utilisé
pour déterminer si un objet est basé sur un certain prototype. Vous lui donnez
l’objet du côté gauche, et le constructeur du côté droit, et il renvoie un
booléen, <code>true</code> si la propriété <code>prototype</code> du constructeur est le prototype
direct ou indirect de l’objet, et <code>false</code> sinon.</p><p>Lorsque vous utilisez des constructeurs normaux, utiliser cet opérateur devient
plutôt maladroit : il attend la fonction constructeur comme deuxième argument,
mais nous avons seulement des prototypes. Une astuce similaire à la fonction
<code>clone</code> peut être utilisée pour éviter cela . Nous utilisons un «&nbsp;faux
constructeur&nbsp;», et nous lui appliquons <code>instanceof</code>.</p><pre class="code"><span class="variable">Object</span>.<span class="property">prototype</span>.<span class="property">hasPrototype</span> = <span class="keyword">function</span>(<span class="variabledef">prototype</span>) {
  <span class="keyword">function</span> <span class="variabledef">FauxConstructeur</span>() {}
  <span class="localvariable">FauxConstructeur</span>.<span class="property">prototype</span> = <span class="localvariable">prototype</span>;
  <span class="keyword">return</span> <span class="localvariable">this</span> instanceof <span class="localvariable">FauxConstructeur</span>;
};

<span class="variable">show</span>(<span class="variable">stylo</span>.<span class="property">hasPrototype</span>(<span class="variable">Produit</span>));
<span class="variable">show</span>(<span class="variable">stylo</span>.<span class="property">hasPrototype</span>(<span class="variable">ProduitDetaille</span>));</pre></div><hr/><div class="block"><p>Ensuite, nous voulons créer un petit élément qui possède une description
détaillée. Il semblerait que cet élément devrait hériter à la fois de
<code>ProduitDetaille</code> et <code>PetitProduit</code>. JavaScript ne permet pas à un objet
d’avoir plusieurs prototypes, et même s’il le permettait, le problème ne serait
pas simple à résoudre. Par exemple, si <code>PetitProduit</code> voulait, pour une raison
quelconque, définir aussi une méthode <code>examiner</code>, quelle méthode <code>examiner</code> ce
nouveau prototype devrait-il utiliser&nbsp;?</p><p>Dériver un type d’objet de plus d’un type parent est appelé <a name="key33"></a>héritage
multiple. Certains langages se dégonflent et l’interdisent totalement,
d’autres définissent des systèmes compliqués pour le faire marcher d’une
manière pratique et bien définie. Il est possible d’implémenter un framework de
multi-héritage décent en JavaScript. En fait, il y a, comme d’habitude, de
nombreuses bonnes façons pour réaliser cela. Mais elles sont toutes trop
compliquées pour en discuter ici. À la place, je vais vous montrer une approche
très simple qui est suffisante dans la plupart des cas.</p></div><hr/><div class="block"><p>Un <a name="key34"></a>mix-in est un type spécifique de prototype qui peut être «&nbsp;incorporé&nbsp;» à
l’intérieur d’autres prototypes. <code>PetitProduit</code> peut être considéré comme un de
ces prototypes. En copiant ses méthodes <code>frapper</code> et <code>prendre</code> dans un autre
prototype, nous allons incorporer la petitesse dans ce prototype.</p><pre class="code"><span class="keyword">function</span> <span class="variable">mixInto</span>(<span class="variabledef">object</span>, <span class="variabledef">mixIn</span>) {
  <span class="variable">forEachIn</span>(<span class="localvariable">mixIn</span>, <span class="keyword">function</span>(<span class="variabledef">nom</span>, <span class="variabledef">valeur</span>) {
    <span class="localvariable">object</span>[<span class="localvariable">nom</span>] = <span class="localvariable">valeur</span>;
  });
};

<span class="keyword">var</span> <span class="variable">PetitProduitDetaille</span> = <span class="variable">clone</span>(<span class="variable">ProduitDetaille</span>);
<span class="variable">mixInto</span>(<span class="variable">PetitProduitDetaille</span>, <span class="variable">PetitProduit</span>);

<span class="keyword">var</span> <span class="variable">sourisMorte</span> = <span class="variable">PetitProduitDetaille</span>.<span class="property">create</span>(
  <span class="string">&quot;Fred la souris&quot;</span>,
  <span class="string">&quot;il est mort&quot;</span>);
<span class="variable">sourisMorte</span>.<span class="property">examiner</span>();
<span class="variable">sourisMorte</span>.<span class="property">frapper</span>();</pre><p>Rappelez-vous que <code>forEachIn</code> parcourt uniquement les <em>propres</em> propriétés de
l’objet, il copiera donc <code>frapper</code> et <code>prendre</code>, mais pas le constructeur que
<code>PetitProduit</code> a hérité de <code>Produit</code>.</p></div><hr/><div class="block"><p>Mélanger les prototypes devient plus complexe quand le mix-in a un
constructeur, ou quand certaines de ses méthodes entrent en «&nbsp;collision&nbsp;» avec
les méthodes du prototype dans lequel il est incorporé. Parfois, il est
possible de faire un mix-in «&nbsp;manuellement&nbsp;». Disons que nous avons un
prototype <code>Monstre</code>, qui a son propre constructeur, et nous voulons le mélanger
avec <code>ProduitDetaille</code>.</p><pre class="code"><span class="keyword">var</span> <span class="variable">Monstre</span> = <span class="variable">Produit</span>.<span class="property">extend</span>({
  <span class="property">construct</span>: <span class="keyword">function</span>(<span class="variabledef">nom</span>, <span class="variabledef">estDangereux</span>) {
    <span class="variable">Produit</span>.<span class="property">construct</span>.<span class="property">call</span>(<span class="localvariable">this</span>, <span class="localvariable">nom</span>);
    <span class="localvariable">this</span>.<span class="property">estDangereux</span> = <span class="localvariable">estDangereux</span>;
  },
  <span class="property">frapper</span>: <span class="keyword">function</span>() {
    <span class="keyword">if</span> (<span class="localvariable">this</span>.<span class="property">estDangereux</span>)
      <span class="variable">print</span>(<span class="localvariable">this</span>.<span class="property">nom</span>, <span class="string">&quot; arrache votre tête avec ses dents.&quot;</span>);
    <span class="keyword">else</span>
      <span class="variable">print</span>(<span class="localvariable">this</span>.<span class="property">nom</span>, <span class="string">&quot; fuit en pleurant.&quot;</span>);
  }
});

<span class="keyword">var</span> <span class="variable">MonstreDetaille</span> = <span class="variable">ProduitDetaille</span>.<span class="property">extend</span>({
  <span class="property">construct</span>: <span class="keyword">function</span>(<span class="variabledef">nom</span>, <span class="variabledef">description</span>, <span class="variabledef">estDangereux</span>) {
    <span class="variable">ProduitDetaille</span>.<span class="property">construct</span>.<span class="property">call</span>(<span class="localvariable">this</span>, <span class="localvariable">nom</span>, <span class="localvariable">description</span>);
    <span class="variable">Monstre</span>.<span class="property">construct</span>.<span class="property">call</span>(<span class="localvariable">this</span>, <span class="localvariable">nom</span>, <span class="localvariable">estDangereux</span>);
  },
  <span class="property">frapper</span>: <span class="variable">Monstre</span>.<span class="property">frapper</span>
});

<span class="keyword">var</span> <span class="variable">paresseuxGeant</span> = <span class="variable">MonstreDetaille</span>.<span class="property">create</span>(
  <span class="string">&quot;le paresseux géant&quot;</span>,
  <span class="string">&quot;il s’accroche tranquillement sur un arbre en grignotant des feuilles&quot;</span>,
  <span class="atom">true</span>);
<span class="variable">paresseuxGeant</span>.<span class="property">frapper</span>();</pre><p>Mais remarquez que cela conduit à appeler deux fois le constructeur de
<code>Produit</code> lorsqu’on crée un <code>MonstreDetaille</code> : une fois à travers le
constructeur de <code>ProduitDetaille</code>, et une fois à travers le constructeur de
<code>Monstre</code>. Dans ce cas, il n’y a pas trop de dégâts, mais il existe des
situations dans lesquelles cela pourrait poser problème.</p></div><hr/><div class="block"><p>Mais ne laissez pas ces complications vous décourager d’utiliser l’héritage.
Les héritages multiples, même s’ils sont très utiles dans certaines situations,
peuvent être ignorés sans problème la plupart du temps. C’est la raison pour
laquelle certains langages comme Java s’en sortent en interdisant les héritages
multiples. Et si, à un moment, vous pensez que vous en avez vraiment besoin,
vous pouvez chercher sur Internet, faire quelques recherches, et trouver une
approche qui fonctionne dans votre situation.</p><p>Maintenant que j’y pense, JavaScript serait probablement un fabuleux
environnement de développement pour les aventures en mode texte. Cette capacité
à modifier le comportement des objets à volonté, qui est ce que nous offre
l’héritage par prototype, est très bien adapté à cela. Si vous avez un objet
<code>herisson</code>, qui a la capacité unique de rouler quand on lui tape dedans, vous
pouvez simplement changer sa méthode <code>frapper</code>.</p><p>Malheureusement, les aventures en mode texte ont suivi le même chemin que les
disques vinyles, alors qu’ils étaient populaires à une époque, ils ne sont
joués de nos jours que par une petite population d’<a href="http://groups.google.com/group/rec.arts.int-fiction/topics">enthousiates</a>.</p></div><ol class="footnotes"><li><a name="footnote1"></a>Ces types sont souvent appelés des «&nbsp;classes&nbsp;» dans d’autres langages de
programmation.</li><li><a name="footnote2"></a>Pour rendre les choses plus simples, les créatures de notre terrarium se
reproduiront de façon asexuée, d’elles-mêmes.</li><li><a name="footnote3"></a>La paresse, pour un programmeur, n’est pas forcément un péché. Les personnes
qui, laborieusement, font et refont toujours les mêmes choses tendent à être de
bon travailleurs à la chaîne et de mauvais programmeurs.</li></ol><h1><span class="number">Chapitre 9: </span>Modularité</h1><div class="block"><p>Ce chapitre concerne les méthodes d’organisation des programmes. Pour ceux dont
la taille est modeste, la question de l’organisation est rarement un problème.
Mais quand un programme grandit, il peut atteindre une taille conséquente qui
rend difficile le contrôle de sa structure et de son interprétation. Un tel
programme commence assez facilement à ressembler à un plat de spaghettis, une
masse informe dans laquelle tout semble relié à tout le reste.</p><p>Lorsque nous structurons un programme, nous faisons deux choses. Nous le
divisons en plus petites parties appelées <a name="key1"></a>modules, chacune ayant un rôle
spécifique, et nous spécifions les relations entre ces parties.</p><p>Dans le <a href="chapter8.html">chapitre 8</a>, en développant un terrarium, nous avons utilisé un grand nombre
de fonctions décrites dans le <a href="chapter6.html">chapitre 6</a>. Ce chapitre définissait également quelques
nouveaux concepts qui n’avaient rien de spécifique aux terrariums, comme les
types <code>clone</code> et <code>Dictionary</code>. Toutes ces choses ont été ajoutées à
l’environnement sans être organisées. Une façon de découper ce programme en
modules pourrait être :</p><ul><li>Pour commencer, un module <code>FunctionalTools</code> qui inclut les fonctions du <a href="chapter6.html">chapitre 6</a> et n’a pas de dépendance.</li><li>Ensuite, <code>ObjectTools</code>, contenant des choses comme <code>clone</code> et <code>create</code>, qui dépend de <code>FunctionalTools</code>.</li><li><code>Dictionary</code> qui contient le type dictionnaire et dépend de <code>FunctionalTools</code>.</li><li>Enfin, le module <code>Terrarium</code> qui dépend de <code>ObjectTools</code> et <code>Dictionary</code>.</li></ul><p>Quand un module <a name="key2"></a>dépend d’un autre module, il utilise des fonctions
ou des variables de ce module et fonctionne uniquement si le premier module est
chargé.</p><p>C’est une bonne idée de s’assurer que les dépendances ne forment jamais une
boucle. Non seulement les dépendances circulaires créent un problème technique
(si les modules <code>A</code> et <code>B</code> dépendent l’un de l’autre, lequel doit être chargé
en premier&nbsp;?) mais elles rendent aussi les relations entre les modules moins
évidentes et peuvent aboutir à une version modulaire de type spaghetti dont je
parlais plus tôt.</p></div><hr/><div class="block"><p>La plupart des langages de programmation modernes ont un système de modules
intégrés. Ce n’est pas le cas de JavaScript. Une fois encore, il nous faut
inventer quelque chose nous-mêmes. Le plus évident pour commencer est de mettre
chaque module dans un fichier différent. Cela permet de voir précisément à quel
module appartient le code.</p><p><a name="key3"></a>Les navigateurs chargent des fichiers JavaScript quand ils
rencontrent une balise <code>&lt;script&gt;</code> avec un attribut <code>src</code> dans le HTML de la
page web. L’extension <code>.js</code> est utilisée habituellement pour les fichiers
contenant du code JavaScript. Dans la console, on fournit un raccourci pour
charger des fichiers grâce à la fonction <code>load</code>.</p><pre class="code"><span class="variable">load</span>(<span class="string">&quot;FunctionalTools.js&quot;</span>);</pre></div><hr/><div class="block"><p>Dans certains cas, lancer des commandes dans le mauvais ordre provoquera des
erreurs. Si un module essaie de créer un objet <code>Dictionary</code> alors que le module
<code>Dictionary</code> n’a pas encore été chargé, il sera incapable de trouver le
constructeur et échouera.</p><p>On pourrait croire que ça se règle facilement. On ajoute simplement quelques
appels à <code>load</code> en haut du fichier d’un module pour charger tous les modules
dont il dépend. Malheureusement, compte tenu du fonctionnement des navigateurs,
appeler <code>load</code> ne provoque pas immédiatement le chargement d’un fichier donné.
Le fichier sera chargé <em>après</em> l’exécution complète du fichier courant. C’est
généralement trop tard.</p><p>Dans la plupart des cas, la solution pragmatique consiste à gérer les
dépendances à la main : placez les balises <code>script</code> de vos documents HTML dans
le bon ordre.</p></div><hr/><div class="block"><p>Il existe deux moyens d’automatiser (partiellement) la gestion des dépendances.
Le premier consiste à conserver dans un fichier distinct les informations
concernant les dépendances entre les modules. Ce fichier peut être chargé en
premier et utilisé pour déterminer dans quel ordre charger les autres. Le
seconde moyen consiste à ne pas utiliser de balise <code>script</code> (<code>load</code> crée et
ajoute une telle balise par un mécanisme interne) mais à aller chercher le
contenu du fichier directement (voir le <a href="chapter14.html">chapitre 14</a>) puis à utiliser la fonction
<code>eval</code> afin de l’exécuter. Le chargement des scripts est alors instantané et
donc plus facile à gérer.</p><p><a name="key4"></a><code>eval</code>, abrégé pour «&nbsp;evaluate&nbsp;» ou «&nbsp;évaluer&nbsp;», est une fonction intéressante. Si vous lui attribuez une valeur de chaîne de caractères, elle exécutera le contenu de cette chaîne en tant que code JavaScript.</p><pre class="code"><span class="variable">eval</span>(<span class="string">&quot;print(\&quot;je suis une chaîne à l’intérieur d’une chaîne&nbsp;!\&quot;);&quot;</span>);</pre><p>Comme vous pouvez l’imaginer facilement, <code>eval</code> peut servir à faire des choses
intéressantes. Du code peut créer du code et l’exécuter. La plupart du temps,
cependant, les problèmes qui peuvent être résolus en utilisant astucieusement
<code>eval</code> peuvent aussi l’être avec un usage astucieux de fonctions anonymes,
lesquelles ont moins de chances de causer des problèmes bizarres.</p><p>Quand <code>eval</code> est appelé à l’intérieur d’une fonction, toutes les nouvelles
variables deviennent des variables locales de cette fonction. Ainsi, quand une
variation du <code>load</code> utilise <code>eval</code> en interne, le chargement du module
<code>Dictionary</code> crée un constructeur <code>Dictionary</code> à l’intérieur de la fonction
<code>load</code>, qui sera perdu dès que la fonction se termine. Il existe des
contournements pour éviter ce problème mais ils sont plutôt mal fichus.</p></div><hr/><div class="block"><p>Survolons rapidement la première variante de gestion de dépendances. Elle
nécessite un fichier spécifique pour les informations de dépendances, qui peut
ressembler à ceci :</p><pre class="code"><span class="keyword">var</span> <span class="variable">dependances</span> =
  {<span class="string">&quot;ObjectTools.js&quot;</span>: [<span class="string">&quot;FunctionalTools.js&quot;</span>],
   <span class="string">&quot;Dictionary.js&quot;</span>:  [<span class="string">&quot;ObjectTools.js&quot;</span>],
   <span class="string">&quot;TestModule.js&quot;</span>:  [<span class="string">&quot;FunctionalTools.js&quot;</span>, <span class="string">&quot;Dictionary.js&quot;</span>]};</pre><p>L’objet <code>dependances</code> contient une propriété pour chaque fichier qui dépend
d’autres fichiers. Les valeurs des propriétés sont des tableaux de noms de
fichier. Notez que nous ne pourrions pas utiliser ici un objet <code>Dictionary</code>,
parce que nous ne pouvons pas être sûrs que le module <code>Dictionary</code> ait déjà été
chargé. Comme toutes les propriétés dans cet objet finiront en «&nbsp;<code>.js</code>&nbsp;», il y
a peu de risques qu’elles interfèrent avec des propriétés cachées telles que
<code>__proto__</code> ou <code>hasOwnProperty</code> et un objet normal fonctionnera très bien.</p><p>Le gestionnaire de dépendances doit faire deux choses. D’abord il doit
s’assurer que les fichiers sont chargés dans le bon ordre, en chargeant le
fichier de dépendances avant les fichiers eux-mêmes. Et ensuite il doit
vérifier qu’aucun fichier n’est chargé plusieurs fois, ce qui pourrait causer
des problèmes et une sérieuse perte de temps.</p><pre class="code"><span class="keyword">var</span> <span class="variable">fichiersCharges</span> = {};

<span class="keyword">function</span> <span class="variable">require</span>(<span class="variabledef">fichier</span>) {
  <span class="keyword">if</span> (<span class="variable">dependances</span>[<span class="localvariable">fichier</span>]) {
    <span class="keyword">var</span> <span class="variabledef">fichiers</span> = <span class="variable">dependances</span>[<span class="localvariable">fichier</span>];
    <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">i</span> = <span class="atom">0</span>; <span class="localvariable">i</span> &lt; <span class="localvariable">fichiers</span>.<span class="property">length</span>; <span class="localvariable">i</span>++)
      <span class="variable">require</span>(<span class="localvariable">fichiers</span>[<span class="localvariable">i</span>]);
  }
  <span class="keyword">if</span> (!<span class="variable">fichiersCharges</span>[<span class="localvariable">fichier</span>]) {
    <span class="variable">fichiersCharges</span>[<span class="localvariable">fichier</span>] = <span class="atom">true</span>;
    <span class="variable">load</span>(<span class="localvariable">fichier</span>);
  }
}</pre><p>La fonction <a name="key5"></a><code>require</code> peut maintenant être utilisée pour charger un fichier
et toutes ses dépendances. Notez qu’il s’appelle lui-même de façon récursive
pour gérer une dépendance (et les dépendances possibles de cette dépendance).</p><pre class="code"><span class="variable">require</span>(<span class="string">&quot;TestModule.js&quot;</span>);</pre><pre class="code"><span class="variable">test</span>();</pre></div><hr/><div class="block"><p>Créer un programme sous la forme d’un jeu de petits modules bien conçus, cela
implique souvent que ce programme va utiliser beaucoup de fichiers différents.
Quand on programme pour le Web, avoir un tas de petits fichiers JavaScript sur
une page tend à allonger son temps de chargement. Mais cela ne doit pas être un
problème. Vous pouvez écrire et tester votre programme sous forme d’une série
de petits fichiers, puis les réunir dans un seul et unique fichier plus gros au
moment de «&nbsp;publier&nbsp;» le programme sur le Web.</p></div><hr/><div class="block"><p>Exactement comme un type d’objet, un module a une interface. Dans de simples
modules consistant uniquement en une collection de fonctions, telle que
<code>FunctionalTools</code>, l’interface est généralement constituée de toutes les
fonctions qui sont définies dans le module. Dans d’autres cas, l’interface du
module n’est qu’une petite partie des fonctions définies à l’intérieur. Par
exemple, notre système de manuscrit vers HTML dans le <a href="chapter6.html">chapitre 6</a> n’a besoin
d’interface que pour une seule fonction, <code>renduFichier</code> (le sous-système pour
créer le HTML serait un module distinct).</p><p>Pour les modules qui ne définissent qu’un seul type d’objet, comme
<code>Dictionary</code>, l’interface de l’objet est identique à l’interface du module.</p></div><hr/><div class="block"><p>En JavaScript, les variables globales existent toutes ensemble en un seul
endroit. Dans les navigateurs, cet endroit est un objet que l’on peut trouver
sous le nom de <code>window</code>. Ce nom est un peu étrange, <code>environment</code> ou <code>top</code>
auraient été de meilleurs choix mais puisque les navigateurs associent
l’environnement JavaScript à une fenêtre (ou un cadre), quelqu’un a dû décider
que <code>window</code> était un nom logique.</p><pre class="code"><span class="variable">show</span>(<span class="variable">window</span>);
<span class="variable">show</span>(<span class="variable">window</span>.<span class="property">print</span> == <span class="variable">print</span>);
<span class="variable">show</span>(<span class="variable">window</span>.<span class="property">window</span>.<span class="property">window</span>.<span class="property">window</span>.<span class="property">window</span>);</pre><p>Comme on le voit dans la troisième ligne, le nom <code>window</code> est juste une
propriété de cet objet d’environnement et il pointe vers lui-même.</p></div><hr/><div class="block"><p>Si un volume de code important est chargé dans un environnement, il utilisera
beaucoup de noms de variables globales. Une fois que la quantité de code
devient trop importante pour être gardée à l’esprit dans tous ses détails, il
devient très facile d’employer accidentellement un nom qui a déjà été utilisé
pour autre chose. Ce qui cassera le code qui utilisait la valeur d’origine. La
prolifération de variables globales est appelée <a name="key6"></a>pollution d’espace de noms et
elle peut causer de sérieux problèmes en JavaScript ―&nbsp;le langage ne vous
avertira pas si vous redéfinissez une variable déjà existante.</p><p>Il n’existe pas de moyen de se débarrasser entièrement de ce problème mais il
peut être en grande partie résolu si l’on prend soin de provoquer le moins de
pollution possible. Pour commencer, les modules ne devraient pas utiliser de
variables globales pour des valeurs qui ne font pas partie de leur interface
externe.</p></div><hr/><div class="block"><p>Si vous ne pouvez définir aucune fonction interne ni variable dans vos modules,
ce n’est évidemment pas très pratique. Heureusement il existe une astuce pour
contourner le problème. Nous écrivons tout le code du module à l’intérieur
d’une fonction, et ajoutons finalement à l’objet <code>window</code> les variables qui
font partie de son interface. Comme elles ont été créées dans la même fonction
parente, toutes les fonctions du module peuvent se voir mutuellement mais le
code extérieur au module ne le peut pas.</p><pre class="code"><span class="keyword">function</span> <span class="variable">moduleConstruitLeNomDuMois</span>() {
  <span class="keyword">var</span> <span class="variabledef">noms</span> = [<span class="string">&quot;Janvier&quot;</span>, <span class="string">&quot;Février&quot;</span>, <span class="string">&quot;Mars&quot;</span>, <span class="string">&quot;Avril&quot;</span>,
               <span class="string">&quot;Mai&quot;</span>, <span class="string">&quot;Juin&quot;</span>, <span class="string">&quot;Juillet&quot;</span>, <span class="string">&quot;Août&quot;</span>, <span class="string">&quot;Septembre&quot;</span>,
               <span class="string">&quot;Octobre&quot;</span>, <span class="string">&quot;Novembre&quot;</span>, <span class="string">&quot;Décembre&quot;</span>];
  <span class="keyword">function</span> <span class="variabledef">getNomDuMois</span>(<span class="variabledef">numero</span>) {
    <span class="keyword">return</span> <span class="localvariable">noms</span>[<span class="localvariable">numero</span>];
  }
  <span class="keyword">function</span> <span class="variabledef">getNumeroDuMois</span>(<span class="variabledef">nom</span>) {
    <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">numero</span> = <span class="atom">0</span>; <span class="localvariable">numero</span> &lt; <span class="localvariable">noms</span>.<span class="property">length</span>; <span class="localvariable">numero</span>++) {
      <span class="keyword">if</span> (<span class="localvariable">noms</span>[<span class="localvariable">numero</span>] == <span class="localvariable">nom</span>)
        <span class="keyword">return</span> <span class="localvariable">numero</span>;
    }
  }

  <span class="variable">window</span>.<span class="property">getNomDuMois</span> = <span class="localvariable">getNomDuMois</span>;
  <span class="variable">window</span>.<span class="property">getNumeroDuMois</span> = <span class="localvariable">getNumeroDuMois</span>;
}
<span class="variable">moduleConstruitLeNomDuMois</span>();

<span class="variable">show</span>(<span class="variable">getNomDuMois</span>(<span class="atom">11</span>));</pre><p>Ce programme crée un module très simple qui traduit les noms de mois en leur
valeur numérique (comme on le fait avec <code>Date</code>, où Janvier est <code>0</code>). Mais
remarquez que <code>moduleConstruitLeNomDuMois</code> est encore une variable globale qui
ne fait pas partie de l’interface du module. Par ailleurs nous devons répéter
trois fois les noms de fonctions de l’interface. Pas génial.</p></div><hr/><div class="block"><p>On peut résoudre le premier problème en rendant la fonction du module anonyme
et en l’appelant directement. Pour cela, nous devons ajouter une paire de
parenthèses autour de la valeur de la fonction, sinon JavaScript va estimer que
c’est une définition de fonction normale qui ne peut pas être appelée
directement.</p><p>Le deuxième problème peut être réglé avec une fonction auxiliaire, <code>provide</code>, à
laquelle on peut attribuer un objet qui contient les valeurs devant être
exportées dans l’objet <code>window</code>.</p><pre class="code"><span class="keyword">function</span> <span class="variable">provide</span>(<span class="variabledef">valeurs</span>) {
  <span class="variable">forEachIn</span>(<span class="localvariable">valeurs</span>, <span class="keyword">function</span>(<span class="variabledef">nom</span>, <span class="variabledef">valeur</span>) {
    <span class="variable">window</span>[<span class="localvariable">nom</span>] = <span class="localvariable">valeur</span>;
  });
}</pre><p>Grâce à cela, nous pouvons écrire un module comme celui-ci :</p><pre class="code">(<span class="keyword">function</span>() {
  <span class="keyword">var</span> <span class="variabledef">noms</span> = [<span class="string">&quot;Lundi&quot;</span>, <span class="string">&quot;Mardi&quot;</span>, <span class="string">&quot;Mercredi&quot;</span>, <span class="string">&quot;Jeudi&quot;</span>,
               <span class="string">&quot;Vendredi&quot;</span>, <span class="string">&quot;Samedi&quot;</span>, <span class="string">&quot;Dimanche&quot;</span>];
  <span class="variable">provide</span>({
    <span class="property">getNomDuJour</span>: <span class="keyword">function</span>(<span class="variabledef">numero</span>) {
      <span class="keyword">return</span> <span class="localvariable">noms</span>[<span class="localvariable">numero</span>];
    },
    <span class="property">getNumeroDuJour</span>: <span class="keyword">function</span>(<span class="variabledef">nom</span>) {
      <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">numero</span> = <span class="atom">0</span>; <span class="localvariable">numero</span> &lt; <span class="localvariable">noms</span>.<span class="property">length</span>; <span class="localvariable">numero</span>++) {
        <span class="keyword">if</span> (<span class="localvariable">noms</span>[<span class="localvariable">numero</span>] == <span class="localvariable">nom</span>)
          <span class="keyword">return</span> <span class="localvariable">numero</span>;
      }
    }
  });
})();

<span class="variable">show</span>(<span class="variable">getNumeroDuJour</span>(<span class="string">&quot;Mercredi&quot;</span>));</pre><p>Je ne conseille pas d’écrire des modules comme celui-ci dès le début. Pendant
que vous êtes encore en train d’écrire du code, il est plus facile d’adopter la
méthode plus simple que nous avons utilisée jusqu’à présent et de tout mettre
au niveau supérieur. En faisant ainsi, vous pourrez vérifier les valeurs
internes du module dans votre navigateur et les tester. Une fois qu’un module
est plus ou moins terminé, il n’est pas très difficile de l’insérer dans une
fonction.</p></div><hr/><div class="block"><p>Il existe des cas dans lesquels un module exportera tellement de variables que
c’est une mauvaise idée de toutes les mettre dans l’environnement global.  Dans
de tels cas, vous pouvez faire ce que fait l’objet standard <code>Math</code> et
représenter le module en tant que simple objet dont les propriétés sont les
fonctions et les valeurs qu’il exporte. Par exemple…</p><pre class="code"><span class="keyword">var</span> <span class="variable">HTML</span> = {
  <span class="property">balise</span>: <span class="keyword">function</span>(<span class="variabledef">nom</span>, <span class="variabledef">contenu</span>, <span class="variabledef">proprietes</span>) {
    <span class="keyword">return</span> {<span class="property">name</span>: <span class="localvariable">nom</span>, <span class="property">properties</span>: <span class="localvariable">proprietes</span>, <span class="property">content</span>: <span class="localvariable">contenu</span>};
  },
  <span class="property">lien</span>: <span class="keyword">function</span>(<span class="variabledef">cible</span>, <span class="variabledef">texte</span>) {
    <span class="keyword">return</span> <span class="variable">HTML</span>.<span class="property">balise</span>(<span class="string">&quot;a&quot;</span>, [<span class="localvariable">texte</span>], {<span class="property">href</span>: <span class="localvariable">cible</span>});
  }
  <span class="comment">/* … beaucoup d’autres fonctions produisant du HTML … */</span>
};</pre><p>Lorsque vous avez besoin du contenu d’un tel module si souvent que cela devient
pénible de devoir taper constamment du <code>HTML</code>, vous pouvez toujours le déplacer
dans l’environnement global en utilisant <code>provide</code>.</p><pre class="code"><span class="variable">provide</span>(<span class="variable">HTML</span>);
<span class="variable">show</span>(<span class="variable">lien</span>(<span class="string">&quot;http://download.oracle.com/docs/cd/E19957-01/816-6408-10/object.htm&quot;</span>,
          <span class="string">&quot;Voilà comment fonctionnent les objets.&quot;</span>));</pre><p>Vous pouvez même combiner les approches par fonction et par objet, en mettant
les variables internes du module dans une fonction et en faisant en sorte que
cette fonction retourne un objet qui contienne son interface externe.</p></div><hr/><div class="block"><p>Quand on ajoute des méthodes à des prototypes standards comme ceux des <code>Array</code>
et <code>Object</code>, un problème similaire à celui de la pollution des espaces de noms
apparaît. Si deux modules décident d’ajouter une méthode <code>map</code> à
<code>Array.prototype</code>, vous pourriez avoir un problème. Si ces deux versions de
<code>map</code> ont exactement le même effet, les choses vont continuer à marcher mais
seulement si vous avez de la chance.</p></div><hr/><div class="block"><p>Concevoir une interface pour un module ou un type d’objet est l’un des aspects
les plus subtils de la programmation. D’un côté, vous ne voulez pas exposer
trop de détails. Ils représenteraient une gêne lors de l’utilisation du module.
D’un autre côté, vous ne voulez pas être <em>trop</em> simple et général, car cela
pourrait rendre impossible l’utilisation du module dans des situations
complexes ou spécialisées.</p><p>Parfois la solution consiste à fournir deux interfaces, l’une détaillée et de
bas niveau pour les choses complexes, l’autre de haut niveau pour les cas les
plus simples. Cette dernière peut habituellement être construite sans peine en
utilisant les outils élaborés par la première.</p><p>Dans d’autres cas, il vous suffit de chercher un peu pour trouver la bonne idée
sur laquelle vous allez bâtir votre interface. Comparez cela aux diverses
approches de procédures héritées que nous avons vues dans le <a href="chapter8.html">chapitre 8</a>. En
choisissant les prototypes comme le concept de base plutôt que les
constructeurs, nous nous sommes arrangés pour rendre les choses bien plus
faciles.</p><p>Le meilleur moyen de comprendre l’intérêt d’une bonne interface, c’est,
malheureusement, d’utiliser de mauvaises interfaces. Lorsque vous en aurez
marre de les subir, vous trouverez un moyen de les améliorer et vous apprendrez
beaucoup en le faisant. Évitez de prétendre qu’une interface minable est «
comme ça et puis c’est tout&nbsp;». Réparez-la ou bien incluez-la dans une nouvelle
interface meilleure (vous en trouverez un exemple dans le <a href="chapter12.html">chapitre 12</a>).</p></div><hr/><div class="block"><p>Il existe des fonctions qui réclament beaucoup d’arguments. Parfois cela veut
simplement dire qu’elles sont mal conçues et on peut facilement y remédier en
les scindant en plusieurs fonctions plus modestes. Mais dans d’autres cas, il
n’y a pas de contournement possible. En particulier si ces arguments ont une
valeur «&nbsp;par défaut&nbsp;» significative. Nous pourrions par exemple écrire encore
une version étendue de <code>serie</code>.</p><pre class="code"><span class="keyword">function</span> <span class="variable">serie</span>(<span class="variabledef">debut</span>, <span class="variabledef">fin</span>, <span class="variabledef">pas</span>, <span class="variabledef">longueur</span>) {
  <span class="keyword">if</span> (<span class="localvariable">pas</span> == <span class="atom">undefined</span>)
    <span class="localvariable">pas</span> = <span class="atom">1</span>;
  <span class="keyword">if</span> (<span class="localvariable">fin</span> == <span class="atom">undefined</span>)
    <span class="localvariable">fin</span> = <span class="localvariable">debut</span> + <span class="localvariable">pas</span> * (<span class="localvariable">longueur</span> - <span class="atom">1</span>);

  <span class="keyword">var</span> <span class="variabledef">resultat</span> = [];
  <span class="keyword">for</span> (; <span class="localvariable">debut</span> &lt;= <span class="localvariable">fin</span>; <span class="localvariable">debut</span> += <span class="localvariable">pas</span>)
    <span class="localvariable">resultat</span>.<span class="property">push</span>(<span class="localvariable">debut</span>);
  <span class="keyword">return</span> <span class="localvariable">resultat</span>;
}

<span class="variable">show</span>(<span class="variable">serie</span>(<span class="atom">0</span>, <span class="atom">undefined</span>, <span class="atom">4</span>, <span class="atom">5</span>));</pre><p>Il peut être difficile de se rappeler quel argument va à quel endroit, sans
compter l’embêtement d’avoir à passer <code>undefined</code> comme second argument quand
un argument <code>longueur</code> est utilisé. Nous pouvons rendre plus facile le passage
d’arguments dans cette fonction en les incluant dans un objet.</p><pre class="code"><span class="keyword">function</span> <span class="variable">defaultTo</span>(<span class="variabledef">objet</span>, <span class="variabledef">valeurs</span>) {
  <span class="variable">forEachIn</span>(<span class="localvariable">valeurs</span>, <span class="keyword">function</span>(<span class="variabledef">nom</span>, <span class="variabledef">valeur</span>) {
    <span class="keyword">if</span> (!<span class="localvariable">objet</span>.<span class="property">hasOwnProperty</span>(<span class="localvariable">nom</span>))
      <span class="localvariable">objet</span>[<span class="localvariable">nom</span>] = <span class="localvariable">valeur</span>;
  });
}

<span class="keyword">function</span> <span class="variable">serie</span>(<span class="variabledef">args</span>) {
  <span class="variable">defaultTo</span>(<span class="localvariable">args</span>, {<span class="property">debut</span>: <span class="atom">0</span>, <span class="property">pas</span>: <span class="atom">1</span>});
  <span class="keyword">if</span> (<span class="localvariable">args</span>.<span class="property">fin</span> == <span class="atom">undefined</span>)
    <span class="localvariable">args</span>.<span class="property">fin</span> = <span class="localvariable">args</span>.<span class="property">debut</span> + <span class="localvariable">args</span>.<span class="property">pas</span> * (<span class="localvariable">args</span>.<span class="property">longueur</span> - <span class="atom">1</span>);

  <span class="keyword">var</span> <span class="variabledef">resultat</span> = [];
  <span class="keyword">for</span> (; <span class="localvariable">args</span>.<span class="property">debut</span> &lt;= <span class="localvariable">args</span>.<span class="property">fin</span>; <span class="localvariable">args</span>.<span class="property">debut</span> += <span class="localvariable">args</span>.<span class="property">pas</span>)
    <span class="localvariable">resultat</span>.<span class="property">push</span>(<span class="localvariable">args</span>.<span class="property">debut</span>);
  <span class="keyword">return</span> <span class="localvariable">resultat</span>;
}

<span class="variable">show</span>(<span class="variable">serie</span>({<span class="property">pas</span>: <span class="atom">4</span>, <span class="property">longueur</span>: <span class="atom">5</span>}));</pre><p>La fonction <code>defaultTo</code> est utile pour ajouter des valeurs par défaut à un
objet. Elle copie les propriétés du deuxième argument dans le premier, en
ignorant celles qui ont déjà une valeur.</p></div><hr/><div class="block"><p>Un module ou groupe de modules qui peut être utile dans plus d’un seul
programme s’appelle généralement une <a name="key7"></a>bibliothèque. Pour de nombreux langages
de programmation, un vaste choix de bibliothèques de qualité est disponible.
Cela signifie que les programmeurs n’ont pas à tout recommencer depuis zéro à
chaque fois, ce qui les rendrait moins productifs. Pour le JavaScript,
malheureusement, le volume de bibliothèques disponibles n’est pas très
important.</p><p>Cependant les choses s’améliorent depuis peu. Il existe un certain nombre de
bonnes bibliothèques avec des outils «&nbsp;de base&nbsp;», des choses comme <code>map</code> et
<code>clone</code>. D’autres langages ont tendance à fournir de telles choses, dont
l’utilité est évidente, en tant que fonctionnalités standard intégrée au
langage, mais pour le JavaScript vous devrez soit vous en créer une collection
vous-même soit utiliser une bibliothèque. Il est recommandé d’utiliser une
bibliothèque : c’est moins de travail et le code d’une bibliothèque a
généralement été testé plus rigoureusement que ce que vous auriez écrit
vous-même.</p><p>Pour s’occuper de ces outils de base, on trouve entre autres des bibliothèques
«&nbsp;légères&nbsp;» : <a href="http://www.prototypejs.org/">prototype</a>, <a href="http://mootools.net">mootools</a>, <a href="http://jquery.com">jQuery</a>, et <a href="http://mochikit.com">MochiKit</a>. Il existe aussi de plus gros frameworks disponibles, qui
font bien plus que de fournir des outils de base. <a href="http://developer.yahoo.com/yui/">YUI</a> (par Yahoo), et <a href="http://dojotoolkit.org/">Dojo</a> semblent être les plus populaires dans cette
catégorie. On peut les télécharger et les utiliser gratuitement. Mon favori est
MochiKit mais c’est une question de goût personnel. Quand vous vous lancez
sérieusement dans la programmation en JavaScript, c’est une bonne idée de jeter
un coup d’œil sur la documentation de chacun d’eux, pour avoir une idée
générale de la façon dont ils fonctionnent et de ce qu’ils permettent de faire.</p><p>Le fait qu’une boîte à outils de base soit presque indispensable pour faire des
programmes un peu élaborés et qu’il en existe, par ailleurs, tellement de
différentes, suscite un dilemme chez ceux qui écrivent des bibliothèques. Soit
vous devez écrire une bibliothèque qui dépend d’une des boîtes à outils, soit
vous écrivez vous-même les outils de base et les incluez dans une bibliothèque.
La première option rend la bibliothèque difficile à utiliser pour ceux qui
utilisent une boîte à outils différente. Et la seconde ajoute un bon paquet de
code pas indispensable à la bibliothèque. Ce dilemme pourrait bien être une des
raisons pour lesquelles il existe assez peu de bibliothèques JavaScript de
bonne qualité et dont l’utilisation est répandue. Il est possible qu’à l’avenir
de nouvelles versions d’ECMAScript et des modifications dans les navigateurs
rendent les boîtes à outils moins nécessaires, ce qui résoudrait partiellement
ce problème.</p></div><h1><span class="number">Chapitre 10: </span>Expressions rationnelles</h1><div class="block"><p>À diverses occasions dans les chapitres précédents, nous avons dû jeter un coup
d’œil aux structures des valeurs de chaînes. Dans le <a href="chapter4.html">chapitre 4</a> nous avons extrait
des valeurs de chaînes en notant les positions exactes dans lesquelles on peut
trouver les nombres qui indiquent une partie de la date. Plus loin, dans le
<a href="chapter6.html">chapitre 6</a>, nous avons vu des bouts de code assez laids destinés à chercher certains
types de caractères dans une chaîne, par exemple ceux qui devaient être
échappés en HTML.</p><p><a name="key1"></a>Les expressions rationnelles constituent un langage
qui décrit les structures des chaînes. Il s’agit d’un petit langage spécifique
mais qui est inclus dans le JavaScript (comme dans beaucoup d’autres langages
de programmation, d’une façon ou d’une autre). Il n’est pas très lisible ― les
expressions rationnelles volumineuses finissent par devenir complètement
illisibles. C’est pourtant un outil très utile qui peut vraiment simplifier les
programmes qui traitent les chaînes.</p></div><hr/><div class="block"><p>Tout comme on écrit les chaînes entre guillemets, les expressions rationnelles
sont écrites entre des slash(<a name="key2"></a><code>/</code>). Ce qui implique que des slash à
l’intérieur de l’expression devront être échappés.</p><pre class="code"><span class="keyword">var</span> <span class="variable">slash</span> = <span class="string">/\//</span>;
<span class="v